This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:

1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:

- File path as an attribute
- Full contents of the file
  </file_format>

<usage_guidelines>

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
  </usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
**tests**/
AnimatedRegion.test.js
.github/
ISSUE_TEMPLATE/
bug_report.yml
config.yml
workflows/
androidBuild.yml
iosBuild.yml
iosFrameworksBuild.yml
pullRequest.yml
push.yml
stale.yml
CODEOWNERS
FUNDING.yml
PULL_REQUEST_TEMPLATE.md
.husky/
commit-msg
pre-commit
android/
gradle/
wrapper/
gradle-wrapper.properties
src/
main/
java/
com/
rnmaps/
maps/
FileUtil.java
FusedLocationSource.java
ImageReadable.java
ImageReader.java
ImageUtil.java
LatLngBoundsUtils.java
MapCallout.java
MapCalloutManager.java
MapCircle.java
MapCircleManager.java
MapFeature.java
MapGradientPolyline.java
MapGradientPolylineManager.java
MapHeatmap.java
MapHeatmapManager.java
MapLocalTile.java
MapLocalTileManager.java
MapManager.java
MapMarker.java
MapMarkerManager.java
MapModule.java
MapOverlay.java
MapOverlayManager.java
MapPolygon.java
MapPolygonManager.java
MapPolyline.java
MapPolylineManager.java
MapsPackage.java
MapTileProvider.java
MapTileWorker.java
MapUIBlock.java
MapUrlTile.java
MapUrlTileManager.java
MapView.java
MapWMSTile.java
MapWMSTileManager.java
RegionChangeEvent.java
SizeReportingShadowNode.java
ViewAttacherGroup.java
ViewChangesTracker.java
AndroidManifest.xml
build.gradle
gradlew
gradlew.bat
docs/
callout.md
circle.md
examples-setup.md
geojson.md
heatmap.md
installation.md
mapview.md
marker.md
overlay.md
polygon.md
polyline.md
tiles.md
e2e/
jest.config.js
starter.test.js
example/
android/
app/
src/
debug/
AndroidManifest.xml
main/
java/
com/
rnmshowcase/
MainActivity.kt
MainApplication.kt
res/
drawable/
rn_edit_text_material.xml
values/
strings.xml
styles.xml
AndroidManifest.xml
\_BUCK
build_defs.bzl
build.gradle
proguard-rules.pro
gradle/
wrapper/
gradle-wrapper.properties
build.gradle
gradle.properties
gradlew
gradlew.bat
settings.gradle
ios/
rnmshowcase/
Images.xcassets/
AppIcon.appiconset/
Contents.json
Contents.json
AppDelegate.h
AppDelegate.mm
Info.plist
LaunchScreen.storyboard
main.m
PrivacyInfo.xcprivacy
rnmshowcase.xcodeproj/
xcshareddata/
xcschemes/
rnmshowcase.xcscheme
project.pbxproj
rnmshowcase.xcworkspace/
xcshareddata/
IDEWorkspaceChecks.plist
contents.xcworkspacedata
rnmshowcaseTests/
Info.plist
rnmshowcaseTests.m
.xcode.env
Podfile
Podfile.lock
src/
examples/
AnimatedMarkers.tsx
AnimatedNavigation.tsx
AnimatedPriceMarker.tsx
AnimatedViews.tsx
BugMarkerWontUpdate.tsx
CachedMap.tsx
CacheURLTiles.tsx
CacheWMSTiles.tsx
Callouts.tsx
CameraControl.tsx
CustomCallout.tsx
CustomMarkers.tsx
CustomOverlay.tsx
CustomOverlayXMarksTheSpot.tsx
CustomTiles.tsx
CustomTilesLocal.tsx
DefaultMarkers.tsx
DisplayLatLng.tsx
DraggableMarkers.tsx
EventListener.tsx
FitToCoordinates.tsx
FitToSuppliedMarkers.tsx
Geojson.tsx
GradientPolylines.tsx
GradientPolylinesFunctional.tsx
ImageOverlayWithAssets.tsx
ImageOverlayWithBearing.tsx
ImageOverlayWithURL.tsx
IndoorMap.tsx
LegalLabel.tsx
LiteMapView.tsx
LoadingMap.tsx
MapBoundaries.tsx
MapKml.tsx
MapStyle.tsx
MarkerTypes.tsx
MassiveCustomMarkers.tsx
MyLocationMapMarker.tsx
OnPoiClick.tsx
Overlays.tsx
PanController.tsx
PolygonCreator.tsx
PolylineCreator.tsx
PriceMarker.tsx
SetNativePropsOverlays.tsx
StaticMap.tsx
TakeSnapshot.tsx
TestIdMarkers.tsx
ThemeMap.tsx
ViewsAsMarkers.tsx
WMSTiles.tsx
ZIndexMarkers.tsx
App.tsx
declaration.d.ts
.node-version
.watchmanconfig
app.json
babel.config.js
Gemfile
index.js
metro.config.js
package.json
react-native.config.js
ios/
AirGoogleMaps/
Resources/
GoogleMapsPrivacy.bundle/
PrivacyInfo.xcprivacy
AIRDummyView.h
AIRDummyView.m
AIRGMSMarker.h
AIRGMSMarker.m
AIRGMSPolygon.h
AIRGMSPolygon.m
AIRGMSPolyline.h
AIRGMSPolyline.m
AIRGoogleMap.h
AIRGoogleMap.m
AIRGoogleMapCallout.h
AIRGoogleMapCallout.m
AIRGoogleMapCalloutManager.h
AIRGoogleMapCalloutManager.m
AIRGoogleMapCalloutSubview.h
AIRGoogleMapCalloutSubview.m
AIRGoogleMapCalloutSubviewManager.h
AIRGoogleMapCalloutSubviewManager.m
AIRGoogleMapCircle.h
AIRGoogleMapCircle.m
AIRGoogleMapCircleManager.h
AIRGoogleMapCircleManager.m
AIRGoogleMapHeatmap.h
AIRGoogleMapHeatmap.m
AIRGoogleMapHeatmapManager.h
AIRGoogleMapHeatmapManager.m
AIRGoogleMapManager.h
AIRGoogleMapManager.m
AIRGoogleMapMarker.h
AIRGoogleMapMarker.m
AIRGoogleMapMarkerManager.h
AIRGoogleMapMarkerManager.m
AIRGoogleMapOverlay.h
AIRGoogleMapOverlay.m
AIRGoogleMapOverlayManager.h
AIRGoogleMapOverlayManager.m
AIRGoogleMapPolygon.h
AIRGoogleMapPolygon.m
AIRGoogleMapPolygonManager.h
AIRGoogleMapPolygonManager.m
AIRGoogleMapPolyline.h
AIRGoogleMapPolyline.m
AIRGoogleMapPolylineManager.h
AIRGoogleMapPolylineManager.m
AIRGoogleMapUrlTile.h
AIRGoogleMapUrlTile.m
AIRGoogleMapUrlTileManager.h
AIRGoogleMapURLTileManager.m
AIRGoogleMapWMSTile.h
AIRGoogleMapWMSTile.m
AIRGoogleMapWMSTileManager.h
AIRGoogleMapWMSTileManager.m
RCTConvert+GMSMapViewType.h
RCTConvert+GMSMapViewType.m
AirMaps/
Callout/
SMCalloutView.h
SMCalloutView.m
AIRMap.h
AIRMap.m
AIRMapCallout.h
AIRMapCallout.m
AIRMapCalloutManager.h
AIRMapCalloutManager.m
AIRMapCalloutSubview.h
AIRMapCalloutSubview.m
AIRMapCalloutSubviewManager.h
AIRMapCalloutSubviewManager.m
AIRMapCircle.h
AIRMapCircle.m
AIRMapCircleManager.h
AIRMapCircleManager.m
AIRMapCoordinate.h
AIRMapCoordinate.m
AIRMapLocalTile.h
AIRMapLocalTile.m
AIRMapLocalTileManager.h
AIRMapLocalTileManager.m
AIRMapLocalTileOverlay.h
AIRMapLocalTileOverlay.m
AIRMapManager.h
AIRMapManager.m
AIRMapMarker.h
AIRMapMarker.m
AIRMapMarkerManager.h
AIRMapMarkerManager.m
AIRMapOverlay.h
AIRMapOverlay.m
AIRMapOverlayManager.h
AIRMapOverlayManager.m
AIRMapOverlayRenderer.h
AIRMapOverlayRenderer.m
AIRMapPolygon.h
AIRMapPolygon.m
AIRMapPolygonManager.h
AIRMapPolygonManager.m
AIRMapPolyline.h
AIRMapPolyline.m
AIRMapPolylineManager.h
AIRMapPolylineManager.m
AIRMapPolylineRenderer.h
AIRMapPolylineRenderer.m
AIRMapSnapshot.h
AIRMapUrlTile.h
AIRMapUrlTile.m
AIRMapUrlTileCachedOverlay.h
AIRMapUrlTileCachedOverlay.m
AIRMapUrlTileManager.h
AIRMapUrlTileManager.m
AIRMapWMSTile.h
AIRMapWMSTile.m
AIRMapWMSTileManager.h
AIRMapWMSTileManager.m
AIRWeakMapReference.h
AIRWeakMapReference.m
AIRWeakTimerReference.h
AIRWeakTimerReference.m
RCTComponentData+Maps.h
RCTComponentData+Maps.m
RCTConvert+AirMap.h
RCTConvert+AirMap.m
AirMaps.xcodeproj/
project.pbxproj
PrivacyInfo.xcprivacy
src/
AnimatedRegion.ts
decorateMapComponent.ts
Geojson.tsx
index.ts
MapCallout.tsx
MapCalloutSubview.tsx
MapCircle.tsx
MapHeatmap.tsx
MapLocalTile.tsx
MapMarker.tsx
MapMarkerNativeComponent.ts
MapOverlay.tsx
MapPolygon.tsx
MapPolygon.types.ts
MapPolyline.tsx
MapUrlTile.tsx
MapView.tsx
MapView.types.ts
MapView.web.ts
MapViewNativeComponent.ts
MapWMSTile.tsx
ProviderConstants.ts
sharedTypes.ts
sharedTypesInternal.ts
.detoxrc.js
.eslintrc.js
.gitignore
.prettierignore
.prettierrc
.releaserc.json
babel.config.js
CHANGELOG.md
commitlint.config.js
CONTRIBUTING.md
LICENSE
package.json
react-native-google-maps.podspec
react-native-maps.podspec
README.md
SECURITY.md
tsconfig.build.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/AnimatedRegion.test.js">
import {Animated} from 'react-native';
import AnimatedRegion from '../src/AnimatedRegion';

const VALUES = {
latitude: 5,
longitude: 5,
latitudeDelta: 0,
longitudeDelta: 0,
};

describe('AnimatedRegion', () => {
it('converts numbers to instances of Animated.Value', () => {
const animatedRegion = new AnimatedRegion(VALUES);

    expect(animatedRegion.latitude instanceof Animated.Value).toBe(true);
    expect(animatedRegion.longitude instanceof Animated.Value).toBe(true);
    expect(animatedRegion.latitudeDelta instanceof Animated.Value).toBe(true);
    expect(animatedRegion.longitudeDelta instanceof Animated.Value).toBe(true);

    const values = animatedRegion.__getValue();

    expect(values.latitude).toEqual(VALUES.latitude);
    expect(values.longitude).toEqual(VALUES.longitude);
    expect(values.longitudeDelta).toEqual(VALUES.longitudeDelta);
    expect(values.latitudeDelta).toEqual(VALUES.latitudeDelta);

});

it('uses Animated.Value instances', () => {
const animatedRegion = new AnimatedRegion({
latitude: new Animated.Value(VALUES.latitude),
longitude: new Animated.Value(VALUES.longitude),
});

    expect(animatedRegion.latitude instanceof Animated.Value).toBe(true);
    expect(animatedRegion.longitude instanceof Animated.Value).toBe(true);
    expect(animatedRegion.latitudeDelta instanceof Animated.Value).toBe(true);
    expect(animatedRegion.longitudeDelta instanceof Animated.Value).toBe(true);

    const values = animatedRegion.__getValue();

    expect(values.latitude).toEqual(VALUES.latitude);
    expect(values.longitude).toEqual(VALUES.longitude);
    expect(values.longitudeDelta).toEqual(VALUES.longitudeDelta);
    expect(values.latitudeDelta).toEqual(VALUES.latitudeDelta);

});

it('uses defaults converted to Animated.Value instances when none are supplied', () => {
const animatedRegion = new AnimatedRegion({});

    expect(animatedRegion.latitude instanceof Animated.Value).toBe(true);
    expect(animatedRegion.longitude instanceof Animated.Value).toBe(true);
    expect(animatedRegion.latitudeDelta instanceof Animated.Value).toBe(true);
    expect(animatedRegion.longitudeDelta instanceof Animated.Value).toBe(true);

    const values = animatedRegion.__getValue();

    expect(values.latitude).toEqual(0);
    expect(values.longitude).toEqual(0);
    expect(values.longitudeDelta).toEqual(VALUES.longitudeDelta);
    expect(values.latitudeDelta).toEqual(VALUES.latitudeDelta);

});
});
</file>

<file path=".github/ISSUE_TEMPLATE/bug_report.yml">
name: "\U0001F41B Bug Report"
description: Report a reproducible bug or regression in this library.
labels: [bug]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this bug report!

- type: textarea
  id: summary
  attributes:
  label: Summary
  description: Provide a clear and concise description of what the bug is.
  validations:
  required: true

- type: textarea
  id: reproducible-code
  attributes:
  label: Reproducible sample code
  render: TSX
  description: |
  [Minimum amount of code](https://stackoverflow.com/help/minimal-reproducible-example) to reproduce the bug.
  Please spend the time needed to trim down your code as much as possible and make sure the code you provide runs "as is",
  as failing to do so will make reproducing every bug very time consuming for the maintainers.
  **This will be automatically formatted into code, so no need for backticks.**

  placeholder: |
  import React from 'react';
  import MapView from 'react-native-maps';

      export default function App() {
        return (
          <MapView
            style={{flex: 1}}
            initialRegion={{
              latitude: 42,
              longitude: 30,
              latitudeDelta: 1,
              longitudeDelta: 1,
            }}
          />
        );
      }

  validations:
  required: true

- type: textarea
  id: steps
  attributes:
  label: Steps to reproduce
  description: Explain the steps we need to take to reproduce the issue
  validations:
  required: true

- type: textarea
  id: exptected
  attributes:
  label: Expected result
  description: How did you expect your project to behave?
  validations:
  required: true

- type: textarea
  id: actual
  attributes:
  label: Actual result
  description: |
  How did it actually behave?
  If you find that it would help understand the issue, please attach screenshot(s).
  This is mostly relevant for issues regarding UI bugs.
  validations:
  required: true

- type: input
  id: version
  attributes:
  label: React Native Maps Version
  description: What version of react-native-maps are you running?
  placeholder: 1.1.0
  validations:
  required: true

- type: dropdown
  id: platforms
  attributes:
  label: What platforms are you seeing the problem on?
  description: You can select more than one option
  multiple: true
  options: - Android - iOS (Apple Maps) - iOS (Google Maps)
  validations:
  required: true

- type: input
  id: rn-version
  attributes:
  label: React Native Version
  description: What version of react-native are you running?
  placeholder: 0.69.2
  validations:
  required: true

- type: dropdown
  id: expo
  attributes:
  label: What version of Expo are you using?
  options: - 'Not using Expo' - 'SDK 45' - 'SDK 46' - 'SDK 47' - 'SDK 48' - 'SDK 49' - 'SDK 50' - 'SDK 51' - 'SDK 52' - 'SDK 53'
  validations:
  required: true

- type: input
  id: device
  attributes:
  label: Device(s)
  description: What device(s) are you able to reproduce this on?
  placeholder: iPhone 14 Pro (12.4), Samsung Galaxy S10 (Android 11)
  validations:
  required: true

- type: textarea
  id: additional
  attributes:
  label: Additional information
  description: Anything else you want us to know about the bug?
  </file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
blank_issues_enabled: false
</file>

<file path=".github/workflows/androidBuild.yml">
name: Android build

on:
pull_request:

jobs:
build-android:
runs-on: ubuntu-latest
steps: - uses: actions/checkout@v4 - name: Setup JDK 17
uses: actions/setup-java@v4
with:
java-version: 17
distribution: temurin

      - name: Setup Android SDK
        uses: amyu/setup-android@v4
        with:
          cache-disabled: true
          sdk-version: 34
          build-tools-version: 33.0.2

      - name: Check out repository code
        uses: actions/checkout@v3

      - name: Clear Gradle Cache
        run: rm -rf $HOME/.gradle/caches/

      - name: Setup node
        uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
          cache: yarn

      - name: Install dependencies
        run: yarn --cwd example --frozen-lockfile

      - name: Write local.properties
        run: echo MAPS_API_KEY=your_api_key_here >> example/android/local.properties

      - name: Build Android
        run: cd example/android && ./gradlew assembleDebug assembleAndroidTest -DtestBuildType=debug

</file>

<file path=".github/workflows/iosBuild.yml">
name: iOS build

on:
pull_request:

jobs:
build-ios:
runs-on: macos-latest

    steps:
      - name: Check out repository code
        uses: actions/checkout@v3

      - name: Setup node
        uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
          cache: yarn

      - name: Setup ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.2'
          bundler-cache: true
          working-directory: example

      - name: Install dependencies
        run: yarn --cwd example --frozen-lockfile

      - name: Install pods
        run: yarn pod-install

      - name: Write Config.xcconfig
        run: echo MAPS_API_KEY=your_api_key_here >> example/ios/Config.xcconfig

      - name: Build iOS
        run: xcodebuild -workspace example/ios/rnmshowcase.xcworkspace -scheme rnmshowcase -configuration Debug -sdk iphonesimulator

</file>

<file path=".github/workflows/iosFrameworksBuild.yml">
name: iOS frameworks build

on:
pull_request:

jobs:
build-ios-frameworks:
runs-on: macos-latest

    steps:
      - name: Check out repository code
        uses: actions/checkout@v3

      - name: Setup node
        uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
          cache: yarn

      - name: Setup ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.2'
          bundler-cache: true
          working-directory: example

      - name: Install dependencies
        run: yarn --cwd example --frozen-lockfile

      - name: Install pods
        run: USE_FRAMEWORKS=static RCT_NEW_ARCH_ENABLED=0 NO_FLIPPER=1 bundle exec pod install
        working-directory: example/ios

      - name: Write Config.xcconfig
        run: echo MAPS_API_KEY=your_api_key_here >> example/ios/Config.xcconfig

      - name: Build iOS
        run: xcodebuild -workspace example/ios/rnmshowcase.xcworkspace -scheme rnmshowcase -configuration Debug -sdk iphonesimulator

</file>

<file path=".github/workflows/pullRequest.yml">
name: Pull Request

on:
pull_request:

jobs:
lint-test:
runs-on: ubuntu-latest

    steps:
      - name: Check out repository code
        uses: actions/checkout@v3

      - name: Setup node
        uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
          cache: yarn

      - name: Install dependencies
        run: yarn --frozen-lockfile

      - name: Install example dependencies
        run: yarn --frozen-lockfile
        working-directory: example

      - name: Lint
        run: yarn lint

      - name: TsCheck
        run: yarn tscheck

      - name: Check formatting
        run: yarn format-check

      - name: Test
        run: yarn test

</file>

<file path=".github/workflows/push.yml">
name: Push
concurrency:
  group: push
on:
  push:
    branches:
      - master
      - beta
jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      HUSKY: 0
    steps:
      - name: Check out repository code
        uses: actions/checkout@v3
        with:
          persist-credentials: false

      - name: Setup node
        uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
          cache: yarn

      - name: Install dependencies
        run: yarn --frozen-lockfile

      - name: Build
        run: yarn build

      # Latest version of npm needed for provenance
      - name: Install latest npm
        run: npm install -g npm@latest

      - name: Release
        env:
          GITHUB_TOKEN: ${{secrets.CI_GITHUB_TOKEN}}
          NPM_TOKEN: ${{secrets.NPM_TOKEN}}
          NPM_CONFIG_PROVENANCE: true
        run: yarn release

</file>

<file path=".github/workflows/stale.yml">
name: 'Run stale action'
on:
  schedule:
    - cron: '30 1 * * *'

jobs:
stale:
runs-on: ubuntu-latest
permissions:
issues: write
pull-requests: write
steps: - uses: actions/stale@v7
with:
exempt-issue-labels: reproducible
days-before-stale: 90
days-before-close: 14
stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. If the issue remains relevant, simply comment `Still relevant` and the issue will remain open. Thank you for your contributions.'
stale-pr-message: 'This PR has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. If the PR remains relevant, simply comment `Still relevant` and the PR will remain open. Thank you for your contributions.'
</file>

<file path=".github/CODEOWNERS">
/.github/workflows/ @Simon-TechForm @christopherdro @salah-ghanim @GETAWAY-DEV
/.github/CODEOWNERS @Simon-TechForm @christopherdro @salah-ghanim @GETAWAY-DEV
</file>

<file path=".github/FUNDING.yml">
# These are supported funding model platforms

github: [salah-ghanim]
</file>

<file path=".github/PULL_REQUEST_TEMPLATE.md">
<!--
PLEASE DON'T DELETE THIS TEMPLATE UNTIL YOU HAVE READ THE FIRST SECTION.

**What happens if you SKIP this step?**

Your pull request will NOT be evaluated!

PLEASE NOTE THAT PRs WITHOUT THE TEMPLATE IN PLACE WILL BE CLOSED RIGHT FROM THE START.

Thanks for helping us help you!
-->

### Does any other open PR do the same thing?

<!--
**Please keep in mind that we apply the FIFO rule for PRs, so if your PR comes after an existing one and there is no compelling reason to merge it instead of the existing one it will be discarded!**

If another PR exists that has similar scope to yours, please specify why you opened yours.
This could be one of the following (but not limited to)

 - the previous PR is stalled, as it's really old and the author didn't continue working on it
 - there are conflicts with the `master` branch and the author didn't fix them
 - the PR doesn't apply anymore (please specify why)
 - my PR is better (please specify why)
 -->

(please answer here)

### What issue is this PR fixing?

(please link the issue here)

### How did you test this PR?

<!--
Please let us know how you have verified that your changes work.

Ideally, your PR should contain a step-by-step test plan, so that reviewers can easily verify your changes.

Your PR will have much better chances of being merged if it is straightforward to verify.

Some questions you might want to think about:

- Which platform (eg. Android/iOS) & Maps API (eg. Google/Apple) does this change affect, if any?
- Did you test this on a real device, or in a simulator?
- Are there any platforms you were not able to test?
-->

(please answer here)

<!--
Thanks for your contribution :)
-->
</file>

<file path=".husky/commit-msg">
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

yarn commitlint --edit "$1"
</file>

<file path=".husky/pre-commit">
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

yarn lint
yarn tscheck
yarn format-check
yarn test
</file>

<file path="android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-all.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="android/src/main/java/com/rnmaps/maps/FileUtil.java">
package com.rnmaps.maps;

import android.content.Context;
import android.net.Uri;
import android.os.AsyncTask;

import com.facebook.common.logging.FLog;
import com.facebook.react.common.ReactConstants;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;

public class FileUtil extends AsyncTask<String, Void, InputStream> {

private Context context;

public FileUtil(Context context) {
super();

    this.context = context;

}

protected InputStream doInBackground(String... urls) {
try {
Uri fileContentUri = Uri.parse(urls[0]);

      if (fileContentUri.getScheme().startsWith("http")) {
        return getDownloadFileInputStream(context, fileContentUri);
      }
      return context.getContentResolver().openInputStream(fileContentUri);
    } catch (Exception e) {
      FLog.e(
          ReactConstants.TAG,
          "Could not retrieve file for contentUri " + urls[0],
          e);
      return null;
    }

}

private InputStream getDownloadFileInputStream(Context context, Uri uri)
throws IOException {
final File outputDir = context.getApplicationContext().getCacheDir();
String NAME = "FileUtil";
String TEMP_FILE_SUFFIX = "temp";
final File file = File.createTempFile(NAME, TEMP_FILE_SUFFIX, outputDir);
file.deleteOnExit();

    final URL url = new URL(uri.toString());
    final InputStream is = url.openStream();
    try {
      final ReadableByteChannel channel = Channels.newChannel(is);
      try {
        final FileOutputStream stream = new FileOutputStream(file);
        try {
          stream.getChannel().transferFrom(channel, 0, Long.MAX_VALUE);
          return new FileInputStream(file);
        } finally {
          stream.close();
        }
      } finally {
        channel.close();
      }
    } finally {
      is.close();
    }

}

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/FusedLocationSource.java">
package com.rnmaps.maps;

import android.annotation.SuppressLint;
import android.content.Context;
import android.location.Location;
import android.os.Looper;

import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationCallback;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.LocationResult;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.location.Priority;
import com.google.android.gms.maps.LocationSource;
import com.google.android.gms.tasks.OnSuccessListener;

import java.lang.SecurityException;

public class FusedLocationSource implements LocationSource {

    private final FusedLocationProviderClient fusedLocationClientProviderClient;
    private final LocationRequest locationRequest;
    private LocationCallback locationCallback;

    public FusedLocationSource(Context context){
        fusedLocationClientProviderClient =
                LocationServices.getFusedLocationProviderClient(context);
        locationRequest = LocationRequest.create();
        locationRequest.setPriority(Priority.PRIORITY_HIGH_ACCURACY);
        locationRequest.setInterval(5000);
    }

    public void setPriority(int priority){
        locationRequest.setPriority(priority);
    }

    public void setInterval(int interval){
        locationRequest.setInterval(interval);
    }

    public void setFastestInterval(int fastestInterval){
        locationRequest.setFastestInterval(fastestInterval);
    }

    @SuppressLint("MissingPermission")
    @Override
    public void activate(final OnLocationChangedListener onLocationChangedListener) {
        try {
            fusedLocationClientProviderClient.getLastLocation().addOnSuccessListener(new OnSuccessListener<Location>() {
                @Override
                public void onSuccess(Location location) {
                    if (location != null) {
                        onLocationChangedListener.onLocationChanged(location);
                    }
                }
            });
            locationCallback = new LocationCallback() {
                @Override
                public void onLocationResult(LocationResult locationResult) {
                    for (Location location : locationResult.getLocations()) {
                        onLocationChangedListener.onLocationChanged(location);
                    }
                }
            };
            fusedLocationClientProviderClient.requestLocationUpdates(locationRequest, locationCallback, Looper.myLooper());
        } catch (SecurityException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void deactivate() {
        fusedLocationClientProviderClient.removeLocationUpdates(locationCallback);
    }

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/ImageReadable.java">
package com.rnmaps.maps;

import android.graphics.Bitmap;

import com.google.android.gms.maps.model.BitmapDescriptor;

public interface ImageReadable {

public void setIconBitmap(Bitmap bitmap);

public void setIconBitmapDescriptor(BitmapDescriptor bitmapDescriptor);

public void update();
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/ImageReader.java">
package com.rnmaps.maps;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Animatable;
import android.net.Uri;

import androidx.annotation.Nullable;

import com.facebook.common.references.CloseableReference;
import com.facebook.datasource.DataSource;
import com.facebook.drawee.backends.pipeline.Fresco;
import com.facebook.drawee.controller.BaseControllerListener;
import com.facebook.drawee.controller.ControllerListener;
import com.facebook.drawee.drawable.ScalingUtils;
import com.facebook.drawee.generic.GenericDraweeHierarchy;
import com.facebook.drawee.generic.GenericDraweeHierarchyBuilder;
import com.facebook.drawee.interfaces.DraweeController;
import com.facebook.drawee.view.DraweeHolder;
import com.facebook.imagepipeline.core.ImagePipeline;
import com.facebook.imagepipeline.image.CloseableImage;
import com.facebook.imagepipeline.image.CloseableStaticBitmap;
import com.facebook.imagepipeline.image.ImageInfo;
import com.facebook.imagepipeline.request.ImageRequest;
import com.facebook.imagepipeline.request.ImageRequestBuilder;
import com.google.android.gms.maps.model.BitmapDescriptor;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;

public class ImageReader {

private final ImageReadable imp;
private final Context context;
private final Resources resources;

private final DraweeHolder<?> logoHolder;
private DataSource<CloseableReference<CloseableImage>> dataSource;

private final ControllerListener<ImageInfo> mLogoControllerListener =
new BaseControllerListener<ImageInfo>() {
@Override
public void onFinalImageSet(
String id,
@Nullable final ImageInfo imageInfo,
@Nullable Animatable animatable) {
CloseableReference<CloseableImage> imageReference = null;
try {
imageReference = dataSource.getResult();
if (imageReference != null) {
CloseableImage image = imageReference.get();
if (image instanceof CloseableStaticBitmap) {
CloseableStaticBitmap closeableStaticBitmap = (CloseableStaticBitmap) image;
Bitmap bitmap = closeableStaticBitmap.getUnderlyingBitmap();
if (bitmap != null) {
bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);
imp.setIconBitmap(bitmap);
imp.setIconBitmapDescriptor(BitmapDescriptorFactory.fromBitmap(bitmap));
}
}
}
} finally {
dataSource.close();
if (imageReference != null) {
CloseableReference.closeSafely(imageReference);
}
}
imp.update();
}
};

public ImageReader(Context context, Resources resources, ImageReadable imp) {
this.context = context;
this.resources = resources;
this.imp = imp;
logoHolder = DraweeHolder.create(createDraweeHeirarchy(resources), context);
logoHolder.onAttach();
}

private GenericDraweeHierarchy createDraweeHeirarchy(Resources resources){
return new GenericDraweeHierarchyBuilder(resources)
.setActualImageScaleType(ScalingUtils.ScaleType.FIT_CENTER)
.setFadeDuration(0)
.build();
}

public void setImage(String uri) {
if (uri == null) {
imp.setIconBitmapDescriptor(null);
imp.update();
} else if (uri.startsWith("http://") || uri.startsWith("https://") ||
uri.startsWith("file://") || uri.startsWith("asset://") || uri.startsWith("data:")) {
ImageRequest imageRequest = ImageRequestBuilder
.newBuilderWithSource(Uri.parse(uri))
.build();
ImagePipeline imagePipeline = Fresco.getImagePipeline();
dataSource = imagePipeline.fetchDecodedImage(imageRequest, this);

      DraweeController controller = Fresco.newDraweeControllerBuilder()
          .setImageRequest(imageRequest)
          .setControllerListener(mLogoControllerListener)
          .setOldController(logoHolder.getController())
          .build();
      logoHolder.setController(controller);
    } else {
      BitmapDescriptor iconBitmapDescriptor = getBitmapDescriptorByName(uri);
      imp.setIconBitmapDescriptor(iconBitmapDescriptor);
      imp.setIconBitmap(BitmapFactory.decodeResource(this.resources, getDrawableResourceByName
          (uri)));
      imp.update();
    }

}

private int getDrawableResourceByName(String name) {
return this.resources.getIdentifier(
name,
"drawable",
this.context.getPackageName());
}

private BitmapDescriptor getBitmapDescriptorByName(String name) {
return BitmapDescriptorFactory.fromResource(getDrawableResourceByName(name));
}

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/ImageUtil.java">
package com.rnmaps.maps;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.util.Base64;

import java.io.ByteArrayOutputStream;

public class ImageUtil {
public static Bitmap convert(String base64Str) throws IllegalArgumentException {
byte[] decodedBytes = Base64.decode(
base64Str.substring(base64Str.indexOf(",") + 1),
Base64.DEFAULT
);

    return BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.length);

}

public static String convert(Bitmap bitmap) {
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);

    return Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);

}

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/LatLngBoundsUtils.java">
package com.rnmaps.maps;

import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.LatLngBounds;

public class LatLngBoundsUtils {
public static boolean BoundsAreDifferent(LatLngBounds a, LatLngBounds b) {
LatLng centerA = a.getCenter();
double latA = centerA.latitude;
double lngA = centerA.longitude;
double latDeltaA = a.northeast.latitude - a.southwest.latitude;
double lngDeltaA = a.northeast.longitude - a.southwest.longitude;

    LatLng centerB = b.getCenter();
    double latB = centerB.latitude;
    double lngB = centerB.longitude;
    double latDeltaB = b.northeast.latitude - b.southwest.latitude;
    double lngDeltaB = b.northeast.longitude - b.southwest.longitude;

    double latEps = LatitudeEpsilon(a, b);
    double lngEps = LongitudeEpsilon(a, b);

    return
        different(latA, latB, latEps) ||
            different(lngA, lngB, lngEps) ||
            different(latDeltaA, latDeltaB, latEps) ||
            different(lngDeltaA, lngDeltaB, lngEps);

}

private static boolean different(double a, double b, double epsilon) {
return Math.abs(a - b) > epsilon;
}

private static double LatitudeEpsilon(LatLngBounds a, LatLngBounds b) {
double sizeA = a.northeast.latitude - a.southwest.latitude; // something mod 180?
double sizeB = b.northeast.latitude - b.southwest.latitude; // something mod 180?
double size = Math.min(Math.abs(sizeA), Math.abs(sizeB));
return size / 2560;
}

private static double LongitudeEpsilon(LatLngBounds a, LatLngBounds b) {
double sizeA = a.northeast.longitude - a.southwest.longitude;
double sizeB = b.northeast.longitude - b.southwest.longitude;
double size = Math.min(Math.abs(sizeA), Math.abs(sizeB));
return size / 2560;
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapCallout.java">
package com.rnmaps.maps;

import android.content.Context;

import com.facebook.react.views.view.ReactViewGroup;

public class MapCallout extends ReactViewGroup {
private boolean tooltip = false;
public int width;
public int height;

public MapCallout(Context context) {
super(context);
}

public void setTooltip(boolean tooltip) {
this.tooltip = tooltip;
}

public boolean getTooltip() {
return this.tooltip;
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapCalloutManager.java">
package com.rnmaps.maps;

import androidx.annotation.Nullable;

import com.facebook.react.common.MapBuilder;
import com.facebook.react.uimanager.LayoutShadowNode;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;

import java.util.Map;

public class MapCalloutManager extends ViewGroupManager<MapCallout> {

@Override
public String getName() {
return "AIRMapCallout";
}

@Override
public MapCallout createViewInstance(ThemedReactContext context) {
return new MapCallout(context);
}

@ReactProp(name = "tooltip", defaultBoolean = false)
public void setTooltip(MapCallout view, boolean tooltip) {
view.setTooltip(tooltip);
}

@Override
@Nullable
public Map getExportedCustomDirectEventTypeConstants() {
return MapBuilder.of("onPress", MapBuilder.of("registrationName", "onPress"));
}

@Override
public LayoutShadowNode createShadowNodeInstance() {
// we use a custom shadow node that emits the width/height of the view
// after layout with the updateExtraData method. Without this, we can't generate
// a bitmap of the appropriate width/height of the rendered view.
return new SizeReportingShadowNode();
}

@Override
public void updateExtraData(MapCallout view, Object extraData) {
// This method is called from the shadow node with the width/height of the rendered
// marker view.
//noinspection unchecked
Map<String, Float> data = (Map<String, Float>) extraData;
float width = data.get("width");
float height = data.get("height");
view.width = (int) width;
view.height = (int) height;
}

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapCircle.java">
package com.rnmaps.maps;

import android.content.Context;

import com.google.android.gms.maps.model.Circle;
import com.google.android.gms.maps.model.CircleOptions;
import com.google.android.gms.maps.model.LatLng;
import com.google.maps.android.collections.CircleManager;

public class MapCircle extends MapFeature {

private CircleOptions circleOptions;
private Circle circle;

private LatLng center;
private double radius;
private int strokeColor;
private int fillColor;
private float strokeWidth;
private float zIndex;

public MapCircle(Context context) {
super(context);
}

public void setCenter(LatLng center) {
this.center = center;
if (circle != null) {
circle.setCenter(this.center);
}
}

public void setRadius(double radius) {
this.radius = radius;
if (circle != null) {
circle.setRadius(this.radius);
}
}

public void setFillColor(int color) {
this.fillColor = color;
if (circle != null) {
circle.setFillColor(color);
}
}

public void setStrokeColor(int color) {
this.strokeColor = color;
if (circle != null) {
circle.setStrokeColor(color);
}
}

public void setStrokeWidth(float width) {
this.strokeWidth = width;
if (circle != null) {
circle.setStrokeWidth(width);
}
}

public void setZIndex(float zIndex) {
this.zIndex = zIndex;
if (circle != null) {
circle.setZIndex(zIndex);
}
}

public CircleOptions getCircleOptions() {
if (circleOptions == null) {
circleOptions = createCircleOptions();
}
return circleOptions;
}

private CircleOptions createCircleOptions() {
CircleOptions options = new CircleOptions();
options.center(center);
options.radius(radius);
options.fillColor(fillColor);
options.strokeColor(strokeColor);
options.strokeWidth(strokeWidth);
options.zIndex(zIndex);
return options;
}

@Override
public Object getFeature() {
return circle;
}

@Override
public void addToMap(Object collection) {
CircleManager.Collection circleCollection = (CircleManager.Collection) collection;
circle = circleCollection.addCircle(getCircleOptions());
}

@Override
public void removeFromMap(Object collection) {
CircleManager.Collection circleCollection = (CircleManager.Collection) collection;
circleCollection.remove(circle);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapCircleManager.java">
package com.rnmaps.maps;

import android.content.Context;
import android.graphics.Color;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;
import com.google.android.gms.maps.model.LatLng;

public class MapCircleManager extends ViewGroupManager<MapCircle> {
private final DisplayMetrics metrics;

public MapCircleManager(ReactApplicationContext reactContext) {
super();
metrics = new DisplayMetrics();
((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
.getDefaultDisplay()
.getRealMetrics(metrics);
}

@Override
public String getName() {
return "AIRMapCircle";
}

@Override
public MapCircle createViewInstance(ThemedReactContext context) {
return new MapCircle(context);
}

@ReactProp(name = "center")
public void setCenter(MapCircle view, ReadableMap center) {
view.setCenter(new LatLng(center.getDouble("latitude"), center.getDouble("longitude")));
}

@ReactProp(name = "radius", defaultDouble = 0)
public void setRadius(MapCircle view, double radius) {
view.setRadius(radius);
}

@ReactProp(name = "strokeWidth", defaultFloat = 1f)
public void setStrokeWidth(MapCircle view, float widthInPoints) {
float widthInScreenPx = metrics.density \* widthInPoints; // done for parity with iOS
view.setStrokeWidth(widthInScreenPx);
}

@ReactProp(name = "fillColor", defaultInt = Color.RED, customType = "Color")
public void setFillColor(MapCircle view, int color) {
view.setFillColor(color);
}

@ReactProp(name = "strokeColor", defaultInt = Color.RED, customType = "Color")
public void setStrokeColor(MapCircle view, int color) {
view.setStrokeColor(color);
}

@ReactProp(name = "zIndex", defaultFloat = 1.0f)
public void setZIndex(MapCircle view, float zIndex) {
view.setZIndex(zIndex);
}

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapFeature.java">
package com.rnmaps.maps;

import android.content.Context;

import com.facebook.react.views.view.ReactViewGroup;

public abstract class MapFeature extends ReactViewGroup {
public MapFeature(Context context) {
super(context);
}

public abstract void addToMap(Object mapOrCollection);

public abstract void removeFromMap(Object mapOrCollection);

public abstract Object getFeature();
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapGradientPolyline.java">
package com.rnmaps.maps;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Shader;
import android.util.Log;

import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.Tile;
import com.google.android.gms.maps.model.TileOverlay;
import com.google.android.gms.maps.model.TileOverlayOptions;
import com.google.android.gms.maps.model.TileProvider;
import com.google.maps.android.SphericalUtil;
import com.google.maps.android.geometry.Point;
import com.google.maps.android.projection.SphericalMercatorProjection;

import java.io.ByteArrayOutputStream;
import java.util.List;

/\*\*

- Tile overlay used to display a colored polyline as a replacement for the
- non-existence of gradient polylines for google maps. Implementation borrowed
- from Dagothig/ColoredPolylineOverlay
- (https://gist.github.com/Dagothig/5f9cf0a4a7a42901a7b2)
  \*/
  public class MapGradientPolyline extends MapFeature {
  private List<LatLng> points;
  private int[] colors;
  private float zIndex;
  private float width;

private GoogleMap map;

private TileOverlay tileOverlay;
protected final Context context;

public MapGradientPolyline(Context context) {
super(context);
this.context = context;
}

public void setCoordinates(List<LatLng> coordinates) {
this.points = coordinates;
if (tileOverlay != null) {
tileOverlay.remove();
}
if (map != null) {
tileOverlay = map.addTileOverlay(createTileOverlayOptions());
}
}

public void setStrokeColors(int[] colors) {
this.colors = colors;
if (tileOverlay != null) {
tileOverlay.remove();
}
if (map != null) {
tileOverlay = map.addTileOverlay(createTileOverlayOptions());
}
}

public void setZIndex(float zIndex) {
this.zIndex = zIndex;
if (tileOverlay != null) {
tileOverlay.setZIndex(zIndex);
}
}

public void setWidth(float width) {
this.width = width;
if (tileOverlay != null) {
tileOverlay.remove();
}
if (map != null) {
tileOverlay = map.addTileOverlay(createTileOverlayOptions());
}
}

private TileOverlayOptions createTileOverlayOptions() {
TileOverlayOptions options = new TileOverlayOptions();
options.zIndex(zIndex);
AirMapGradientPolylineProvider tileProvider = new AirMapGradientPolylineProvider(context, points, colors, width);
options.tileProvider(tileProvider);
return options;
}

public static int interpolateColor(int[] colors, float proportion) {
int rTotal = 0, gTotal = 0, bTotal = 0;
// We correct the ratio to colors.length - 1 so that
// for i == colors.length - 1 and p == 1, then the final ratio is 1 (see below)
float p = proportion \* (colors.length - 1);

    for (int i = 0; i < colors.length; i++) {
      // The ratio mostly resides on the 1 - Math.abs(p - i) calculation :
      // Since for p == i, then the ratio is 1 and for p == i + 1 or p == i -1, then the ratio is 0
      // This calculation works BECAUSE p lies within [0, length - 1] and i lies within [0, length - 1] as well
      float iRatio = Math.max(1 - Math.abs(p - i), 0.0f);
      rTotal += (int) (Color.red(colors[i]) * iRatio);
      gTotal += (int) (Color.green(colors[i]) * iRatio);
      bTotal += (int) (Color.blue(colors[i]) * iRatio);
    }

    return Color.rgb(rTotal, gTotal, bTotal);

}

public class AirMapGradientPolylineProvider implements TileProvider {

    public static final int BASE_TILE_SIZE = 256;

    protected final List<LatLng> points;
    protected final int[] colors;
    protected final float width;
    protected final float density;
    protected final int tileDimension;
    protected final SphericalMercatorProjection projection;

    // Caching calculation-related stuff
    protected LatLng[] trailLatLngs;
    protected Point[] projectedPts;
    protected Point[] projectedPtMids;

    public AirMapGradientPolylineProvider(Context context, List<LatLng> points, int[] colors,
        float width) {
      super();

      this.points = points;
      this.colors = colors;
      this.width = width;
      density = context.getResources().getDisplayMetrics().density;
      tileDimension = (int) (BASE_TILE_SIZE * density);
      projection = new SphericalMercatorProjection(BASE_TILE_SIZE);
      calculatePoints();
    }

    public void calculatePoints() {
      trailLatLngs = new LatLng[points.size()];
      projectedPts = new Point[points.size()];
      projectedPtMids = new Point[Math.max(points.size() - 1, 0)];

      for (int i = 0; i < points.size(); i++) {
        LatLng latLng = points.get(i);
        trailLatLngs[i] = latLng;
        projectedPts[i] = projection.toPoint(latLng);

        // Mids
        if (i > 0) {
          LatLng previousLatLng = points.get(i - 1);
          LatLng latLngMid = SphericalUtil.interpolate(previousLatLng, latLng, 0.5);
          projectedPtMids[i - 1] = projection.toPoint(latLngMid);
        }
      }
    }

    @Override
    public Tile getTile(int x, int y, int zoom) {
      // Because getTile can be called asynchronously by multiple threads, none of the info we keep in the class will be modified
      // (getTile is essentially side-effect-less) :
      // Instead, we create the bitmap, the canvas and the paints specifically for the call to getTile

      Bitmap bitmap = Bitmap.createBitmap(tileDimension, tileDimension, Bitmap.Config.ARGB_8888);

      // Normally, instead of the later calls for drawing being offset, we would offset them using scale() and translate() right here
      // However, there seems to be funky issues related to float imprecisions that happen at large scales when using this method, so instead
      // The points are offset properly when drawing
      Canvas canvas = new Canvas(bitmap);

      Matrix shaderMat = new Matrix();
      Paint gradientPaint = new Paint();
      gradientPaint.setStyle(Paint.Style.STROKE);
      gradientPaint.setStrokeWidth(width);
      gradientPaint.setStrokeCap(Paint.Cap.BUTT);
      gradientPaint.setStrokeJoin(Paint.Join.ROUND);
      gradientPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
      gradientPaint.setShader(new LinearGradient(0, 0, 1, 0, colors, null,
          Shader.TileMode.CLAMP));
      gradientPaint.getShader().setLocalMatrix(shaderMat);

      Paint colorPaint = new Paint();
      colorPaint.setStyle(Paint.Style.STROKE);
      colorPaint.setStrokeWidth(width);
      colorPaint.setStrokeCap(Paint.Cap.BUTT);
      colorPaint.setStrokeJoin(Paint.Join.ROUND);
      colorPaint.setFlags(Paint.ANTI_ALIAS_FLAG);

      // See https://developers.google.com/maps/documentation/android/views#zoom for handy info regarding what zoom is
      float scale = (float) (Math.pow(2, zoom) * density);

      renderTrail(canvas, shaderMat, gradientPaint, colorPaint, scale, x, y);

      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);
      return new Tile(tileDimension, tileDimension, baos.toByteArray());
    }

    public void renderTrail(Canvas canvas, Matrix shaderMat, Paint gradientPaint, Paint colorPaint,
        float scale, int x, int y) {
      MutPoint pt1 = new MutPoint(), pt2 = new MutPoint(), pt3 = new MutPoint(), pt1mid2 =
          new MutPoint(), pt2mid3 = new MutPoint();

      if (points.size() == 1) {
        pt1.set(projectedPts[0], scale, x, y, tileDimension);

        colorPaint.setStyle(Paint.Style.FILL);
        colorPaint.setColor(interpolateColor(colors, 1));
        canvas
            .drawCircle((float) pt1.x, (float) pt1.y, colorPaint.getStrokeWidth() / 2f, colorPaint);
        colorPaint.setStyle(Paint.Style.STROKE);

        return;
      }


      if (points.size() == 2) {
        pt1.set(projectedPts[0], scale, x, y, tileDimension);
        pt2.set(projectedPts[1], scale, x, y, tileDimension);

        drawLine(canvas, colorPaint, pt1, pt2, 0);

        return;
      }

      for (int i = 2; i < points.size(); i++) {
        pt1.set(projectedPts[i - 2], scale, x, y, tileDimension);
        pt2.set(projectedPts[i - 1], scale, x, y, tileDimension);
        pt3.set(projectedPts[i], scale, x, y, tileDimension);

        // Because we want to split the lines in two to ease over the corners, we need the middle points
        pt1mid2.set(projectedPtMids[i - 2], scale, x, y, tileDimension);
        pt2mid3.set(projectedPtMids[i - 1], scale, x, y, tileDimension);

        float interp1 = ((float)i - 2) / points.size();
        float interp2 = ((float)i - 1) / points.size();
        float interp1to2 = (interp1 + interp2) / 2;

        Log.d("AirMapGradientPolyline", String.valueOf(interp1to2));

        // Circle for the corner (removes the weird empty corners that occur otherwise)
        colorPaint.setStyle(Paint.Style.FILL);
        colorPaint.setColor(interpolateColor(colors, interp1to2));
        canvas
            .drawCircle((float) pt2.x, (float) pt2.y, colorPaint.getStrokeWidth() / 2f, colorPaint);
        colorPaint.setStyle(Paint.Style.STROKE);

        // Corner
        // Note that since for the very first point and the very last point we don't split it in two, we used them instead.
        drawLine(canvas, shaderMat, gradientPaint, colorPaint, i - 2 == 0 ? pt1 : pt1mid2,
            pt2, interp1, interp1to2);
        drawLine(canvas, shaderMat, gradientPaint, colorPaint, pt2, i == points.size() - 1 ?
            pt3 : pt2mid3, interp1to2, interp2);
      }
    }

    /**
     * Note: it is assumed the shader is 0, 0, 1, 0 (horizontal) so that it lines up with the rotation
     * (rotations are usually setup so that the angle 0 points right)
     */
    public void drawLine(Canvas canvas, Matrix shaderMat, Paint gradientPaint, Paint colorPaint,
        MutPoint pt1, MutPoint pt2, float ratio1, float ratio2) {
      // Degenerate case: both ratios are the same; we just handle it using the colorPaint (handling it using the shader is just messy and ineffective)
      if (ratio1 == ratio2) {
        drawLine(canvas, colorPaint, pt1, pt2, ratio1);
        return;
      }
      shaderMat.reset();

      // PS: don't ask me why this specfic orders for calls works but other orders will fuck up
      // Since every call is pre, this is essentially ordered as (or my understanding is that it is):
      // ratio translate -> ratio scale -> scale to pt length -> translate to pt start -> rotate
      // (my initial intuition was to use only post calls and to order as above, but it resulted in odd corruptions)

      // Setup based on points:
      // We translate the shader so that it is based on the first point, rotated towards the second and since the length of the
      // gradient is 1, then scaling to the length of the distance between the points makes it exactly as long as needed
      shaderMat.preRotate((float) Math.toDegrees(Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x)),
          (float) pt1.x, (float) pt1.y);
      shaderMat.preTranslate((float) pt1.x, (float) pt1.y);
      float scale = (float) Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      shaderMat.preScale(scale, scale);

      // Setup based on ratio
      // By basing the shader to the first ratio, we ensure that the start of the gradient corresponds to it
      // The inverse scaling of the shader means that it takes the full length of the call to go to the second ratio
      // For instance; if d(ratio1, ratio2) is 0.5, then the shader needs to be twice as long so that an entire call (1)
      // Results in only half of the gradient being used
      shaderMat.preScale(1f / (ratio2 - ratio1), 1f / (ratio2 - ratio1));
      shaderMat.preTranslate(-ratio1, 0);

      gradientPaint.getShader().setLocalMatrix(shaderMat);

      canvas.drawLine(
          (float) pt1.x,
          (float) pt1.y,
          (float) pt2.x,
          (float) pt2.y,
          gradientPaint
      );
    }

    public void drawLine(Canvas canvas, Paint colorPaint, MutPoint pt1, MutPoint pt2, float ratio) {
      colorPaint.setColor(interpolateColor(colors, ratio));
      canvas.drawLine(
          (float) pt1.x,
          (float) pt1.y,
          (float) pt2.x,
          (float) pt2.y,
          colorPaint
      );
    }

}

@Override
public Object getFeature() {
return tileOverlay;
}

@Override
public void addToMap(Object map) {
this.map = (GoogleMap) map;
this.tileOverlay = this.map.addTileOverlay(createTileOverlayOptions());
}

@Override
public void removeFromMap(Object map) {
tileOverlay.remove();
}

public static class MutPoint {
public double x, y;

    public MutPoint set(Point point, float scale, int x, int y, int tileDimension) {
      this.x = point.x * scale - x * tileDimension;
      this.y = point.y * scale - y * tileDimension;
      return this;
    }

}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapGradientPolylineManager.java">
package com.rnmaps.maps;

import android.content.Context;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;
import com.google.android.gms.maps.model.LatLng;

import java.util.List;
import java.util.ArrayList;

public class MapGradientPolylineManager extends ViewGroupManager<MapGradientPolyline> {
private final DisplayMetrics metrics;

public MapGradientPolylineManager(ReactApplicationContext reactContext) {
super();
metrics = new DisplayMetrics();
((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
.getDefaultDisplay()
.getRealMetrics(metrics);
}

@Override
public String getName() {
return "AIRMapGradientPolyline";
}

@Override
public MapGradientPolyline createViewInstance(ThemedReactContext context) {
return new MapGradientPolyline(context);
}

@ReactProp(name = "coordinates")
public void setCoordinates(MapGradientPolyline view, ReadableArray coordinates) {
List<LatLng> p = new ArrayList<LatLng>();
for (int i = 0; i < coordinates.size(); i++) {
ReadableMap point = coordinates.getMap(i);
LatLng latLng = new LatLng(point.getDouble("latitude"), point.getDouble("longitude"));
p.add(latLng);
}
view.setCoordinates(p);
}

@ReactProp(name = "strokeColors", customType = "ColorArray")
public void setStrokeColors(MapGradientPolyline view, ReadableArray colors) {
if (colors != null) {
if (colors.size() == 0) {
int[] colorValues = {0,0};
view.setStrokeColors(colorValues);
} else if (colors.size() == 1) {
int[] colorValues = { colors.getInt(0), colors.getInt(0) };
view.setStrokeColors(colorValues);
} else {
int[] colorValues = new int[colors.size()];
for (int i = 0; i < colors.size(); i++) {
colorValues[i] = colors.getInt(i);
}
view.setStrokeColors(colorValues);
}
} else {
int[] colorValues = {0,0};
view.setStrokeColors(colorValues);
}
}

@ReactProp(name = "zIndex", defaultFloat = 1.0f)
public void setZIndex(MapGradientPolyline view, float zIndex) {
view.setZIndex(zIndex);
}

@ReactProp(name = "strokeWidth", defaultFloat = 1f)
public void setStrokeWidth(MapGradientPolyline view, float widthInPoints) {
float widthInScreenPx = metrics.density \* widthInPoints; // done for parity with iOS
view.setWidth(widthInScreenPx);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapHeatmap.java">
package com.rnmaps.maps;

import android.content.Context;
import android.util.Log;

import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.model.TileOverlay;
import com.google.android.gms.maps.model.TileOverlayOptions;
import com.google.maps.android.heatmaps.HeatmapTileProvider;
import com.google.maps.android.heatmaps.WeightedLatLng;
import com.google.maps.android.heatmaps.Gradient;

import java.util.Arrays;
import java.util.List;

public class MapHeatmap extends MapFeature {

    private TileOverlayOptions heatmapOptions;
    private TileOverlay heatmap;
    private HeatmapTileProvider heatmapTileProvider;

    private List<WeightedLatLng> points;
    private Gradient gradient;
    private Double opacity;
    private Integer radius;

    public MapHeatmap(Context context) {
        super(context);
    }

    public void setPoints(WeightedLatLng[] points) {
        this.points = Arrays.asList(points);
        if (heatmapTileProvider != null) {
            heatmapTileProvider.setWeightedData(this.points);
        }
        if (heatmap != null) {
            heatmap.clearTileCache();
        }
    }

    public void setGradient(Gradient gradient) {
        this.gradient = gradient;
        if (heatmapTileProvider != null) {
            heatmapTileProvider.setGradient(gradient);
        }
        if (heatmap != null) {
            heatmap.clearTileCache();
        }
    }

    public void setOpacity(double opacity) {
        this.opacity = opacity;
        if (heatmapTileProvider != null) {
            heatmapTileProvider.setOpacity(opacity);
        }
        if (heatmap != null) {
            heatmap.clearTileCache();
        }
    }

    public void setRadius(int radius) {
        this.radius = radius;
        if (heatmapTileProvider != null) {
            heatmapTileProvider.setRadius(radius);
        }
        if (heatmap != null) {
            heatmap.clearTileCache();
        }
    }

    public TileOverlayOptions getHeatmapOptions() {
        if (heatmapOptions == null) {
            heatmapOptions = createHeatmapOptions();
        }
        return heatmapOptions;
    }

    private TileOverlayOptions createHeatmapOptions() {
        TileOverlayOptions options = new TileOverlayOptions();
        if (heatmapTileProvider == null) {
            HeatmapTileProvider.Builder builder =
                new HeatmapTileProvider.Builder().weightedData(this.points);
            if (radius != null) {
                builder.radius(radius);
            }
            if (opacity != null) {
                builder.opacity(opacity);
            }
            if (gradient != null) {
                builder.gradient(gradient);
            }
            heatmapTileProvider = builder.build();
        }
        options.tileProvider(heatmapTileProvider);
        return options;
    }

    @Override
    public Object getFeature() {
        return heatmap;
    }

    @Override
    public void addToMap(Object map) {
        heatmap = ((GoogleMap) map).addTileOverlay(getHeatmapOptions());
    }

    @Override
    public void removeFromMap(Object map) {
        heatmap.remove();
    }

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapHeatmapManager.java">
package com.rnmaps.maps;

import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.uimanager.annotations.ReactProp;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;

import com.google.android.gms.maps.model.LatLng;
import com.google.maps.android.heatmaps.WeightedLatLng;
import com.google.maps.android.heatmaps.Gradient;

public class MapHeatmapManager extends ViewGroupManager<MapHeatmap> {

    @Override
    public String getName() {
        return "AIRMapHeatmap";
    }

    @Override
    public MapHeatmap createViewInstance(ThemedReactContext context) {
        return new MapHeatmap(context);
    }

    @ReactProp(name = "points")
    public void setPoints(MapHeatmap view, ReadableArray points) {
        WeightedLatLng[] p = new WeightedLatLng[points.size()];
        for (int i = 0; i < points.size(); i++) {
            ReadableMap point = points.getMap(i);
            WeightedLatLng weightedLatLng;
            LatLng latLng = new LatLng(point.getDouble("latitude"), point.getDouble("longitude"));
            if (point.hasKey("weight")) {
                weightedLatLng = new WeightedLatLng(latLng, point.getDouble("weight"));
            } else {
                weightedLatLng = new WeightedLatLng(latLng);
            }
            p[i] = weightedLatLng;
        }
        view.setPoints(p);
    }

    @ReactProp(name = "gradient")
    public void setGradient(MapHeatmap view, ReadableMap gradient) {
        ReadableArray srcColors = gradient.getArray("colors");
        int[] colors = new int[srcColors.size()];
        for (int i = 0; i < srcColors.size(); i++) {
            colors[i] = srcColors.getInt(i);
        }

        ReadableArray srcStartPoints = gradient.getArray("startPoints");
        float[] startPoints = new float[srcStartPoints.size()];
        for (int i = 0; i < srcStartPoints.size(); i++) {
            startPoints[i] = (float)srcStartPoints.getDouble(i);
        }

        if (gradient.hasKey("colorMapSize")) {
            int colorMapSize = gradient.getInt("colorMapSize");
            view.setGradient(new Gradient(colors, startPoints, colorMapSize));
        } else {
            view.setGradient(new Gradient(colors, startPoints));
        }
    }

    @ReactProp(name = "opacity")
    public void setOpacity(MapHeatmap view, double opacity) {
        view.setOpacity(opacity);
    }

    @ReactProp(name = "radius")
    public void setRadius(MapHeatmap view, int radius) {
        view.setRadius(radius);
    }

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapLocalTile.java">
package com.rnmaps.maps;

import android.content.Context;

import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.model.Tile;
import com.google.android.gms.maps.model.TileOverlay;
import com.google.android.gms.maps.model.TileOverlayOptions;
import com.google.android.gms.maps.model.TileProvider;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class MapLocalTile extends MapFeature {

    class AIRMapLocalTileProvider implements TileProvider {
        private static final int BUFFER_SIZE = 16 * 1024;
        private int tileSize;
        private String pathTemplate;
        private final boolean useAssets;


        public AIRMapLocalTileProvider(int tileSizet, String pathTemplate, boolean useAssets) {
            this.tileSize = tileSizet;
            this.pathTemplate = pathTemplate;
            this.useAssets = useAssets;
        }

        @Override
        public Tile getTile(int x, int y, int zoom) {
            byte[] image = readTileImage(x, y, zoom);
            return image == null ? TileProvider.NO_TILE : new Tile(this.tileSize, this.tileSize, image);
        }

        public void setPathTemplate(String pathTemplate) {
            this.pathTemplate = pathTemplate;
        }

        public void setTileSize(int tileSize) {
            this.tileSize = tileSize;
        }

        private byte[] readTileImage(int x, int y, int zoom) {
            InputStream in = null;
            ByteArrayOutputStream buffer = null;
            String tileFilename = getTileFilename(x, y, zoom);

            try {
                in = useAssets ? getContext().getAssets().open(tileFilename) : new FileInputStream(tileFilename);
                buffer = new ByteArrayOutputStream();

                int nRead;
                byte[] data = new byte[BUFFER_SIZE];

                while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
                    buffer.write(data, 0, nRead);
                }
                buffer.flush();

                return buffer.toByteArray();
            } catch (IOException | OutOfMemoryError e) {
                e.printStackTrace();
                return null;
            } finally {
                if (in != null) try { in.close(); } catch (Exception ignored) {}
                if (buffer != null) try { buffer.close(); } catch (Exception ignored) {}
            }
        }

        private String getTileFilename(int x, int y, int zoom) {
            String s = this.pathTemplate
                    .replace("{x}", Integer.toString(x))
                    .replace("{y}", Integer.toString(y))
                    .replace("{z}", Integer.toString(zoom));
            return s;
        }
    }

    private TileOverlayOptions tileOverlayOptions;
    private TileOverlay tileOverlay;
    private MapLocalTile.AIRMapLocalTileProvider tileProvider;

    private String pathTemplate;
    private float tileSize;
    private float zIndex;
    private boolean useAssets;

    public MapLocalTile(Context context) {
        super(context);
    }

    public void setPathTemplate(String pathTemplate) {
        this.pathTemplate = pathTemplate;
        if (tileProvider != null) {
            tileProvider.setPathTemplate(pathTemplate);
        }
        if (tileOverlay != null) {
            tileOverlay.clearTileCache();
        }
    }

    public void setZIndex(float zIndex) {
        this.zIndex = zIndex;
        if (tileOverlay != null) {
            tileOverlay.setZIndex(zIndex);
        }
    }

    public void setTileSize(float tileSize) {
        this.tileSize = tileSize;
        if (tileProvider != null) {
            tileProvider.setTileSize((int)tileSize);
        }
    }

    public void setUseAssets(boolean useAssets) {
        this.useAssets = useAssets;
    }

    public TileOverlayOptions getTileOverlayOptions() {
        if (tileOverlayOptions == null) {
            tileOverlayOptions = createTileOverlayOptions();
        }
        return tileOverlayOptions;
    }

    private TileOverlayOptions createTileOverlayOptions() {
        TileOverlayOptions options = new TileOverlayOptions();
        options.zIndex(zIndex);
        this.tileProvider = new MapLocalTile.AIRMapLocalTileProvider((int)this.tileSize, this.pathTemplate, this.useAssets);
        options.tileProvider(this.tileProvider);
        return options;
    }

    @Override
    public Object getFeature() {
        return tileOverlay;
    }

    @Override
    public void addToMap(Object map) {
        this.tileOverlay = ((GoogleMap) map).addTileOverlay(getTileOverlayOptions());
    }

    @Override
    public void removeFromMap(Object map) {
        tileOverlay.remove();
    }

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapLocalTileManager.java">
package com.rnmaps.maps;

import android.content.Context;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;

/\*\*

- Created by zavadpe on 30/11/2017.
  \*/
  public class MapLocalTileManager extends ViewGroupManager<MapLocalTile> {

      public MapLocalTileManager(ReactApplicationContext reactContext) {
          super();
          DisplayMetrics metrics = new DisplayMetrics();
          ((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
                  .getDefaultDisplay()
                  .getRealMetrics(metrics);
      }

      @Override
      public String getName() {
          return "AIRMapLocalTile";
      }

      @Override
      public MapLocalTile createViewInstance(ThemedReactContext context) {
          return new MapLocalTile(context);
      }

      @ReactProp(name = "pathTemplate")
      public void setPathTemplate(MapLocalTile view, String pathTemplate) {
          view.setPathTemplate(pathTemplate);
      }

      @ReactProp(name = "tileSize", defaultFloat = 256f)
      public void setTileSize(MapLocalTile view, float tileSize) {
          view.setTileSize(tileSize);
      }

      @ReactProp(name = "zIndex", defaultFloat = -1.0f)
      public void setZIndex(MapLocalTile view, float zIndex) {
          view.setZIndex(zIndex);
      }

      @ReactProp(name = "useAssets", defaultBoolean = false)
      public void setUseAssets(MapLocalTile view, boolean useAssets) {
          view.setUseAssets(useAssets);
      }

  }
  </file>

<file path="android/src/main/java/com/rnmaps/maps/MapManager.java">
package com.rnmaps.maps;

import android.view.View;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.facebook.react.R;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.common.MapBuilder;
import com.facebook.react.modules.core.DeviceEventManagerModule;
import com.facebook.react.uimanager.LayoutShadowNode;
import com.facebook.react.uimanager.ReactStylesDiffMap;
import com.facebook.react.uimanager.StateWrapper;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;
import com.facebook.react.uimanager.events.RCTEventEmitter;
import com.google.android.gms.location.Priority;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.GoogleMapOptions;
import com.google.android.gms.maps.MapsInitializer;
import com.google.android.gms.maps.model.CameraPosition;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.LatLngBounds;

import java.util.Map;

public class MapManager extends ViewGroupManager<MapView> {

    private static final String REACT_CLASS = "AIRMap";

    private final Map<String, Integer> MAP_TYPES = MapBuilder.of(
            "standard", GoogleMap.MAP_TYPE_NORMAL,
            "satellite", GoogleMap.MAP_TYPE_SATELLITE,
            "hybrid", GoogleMap.MAP_TYPE_HYBRID,
            "terrain", GoogleMap.MAP_TYPE_TERRAIN,
            "none", GoogleMap.MAP_TYPE_NONE
    );

    private final Map<String, Integer> MY_LOCATION_PRIORITY = MapBuilder.of(
            "balanced", Priority.PRIORITY_BALANCED_POWER_ACCURACY,
            "high", Priority.PRIORITY_HIGH_ACCURACY,
            "low", Priority.PRIORITY_LOW_POWER,
            "passive", Priority.PRIORITY_PASSIVE
    );

    private final ReactApplicationContext appContext;
    private MapMarkerManager markerManager;

    protected GoogleMapOptions googleMapOptions;

    protected MapsInitializer.Renderer renderer;

    public MapManager(ReactApplicationContext context) {
        this.appContext = context;
    }

    public MapMarkerManager getMarkerManager() {
        return this.markerManager;
    }

    public void setMarkerManager(MapMarkerManager markerManager) {
        this.markerManager = markerManager;
    }

    @Override
    public String getName() {
        return REACT_CLASS;
    }

    @Override
    protected MapView createViewInstance(@NonNull ThemedReactContext context) {
        return new MapView(context, this.appContext, this, googleMapOptions);
    }

    @Override
    protected MapView createViewInstance(int reactTag, @NonNull ThemedReactContext reactContext, @Nullable ReactStylesDiffMap initialProps, @Nullable StateWrapper stateWrapper) {
        this.googleMapOptions = new GoogleMapOptions();
        if (initialProps != null) {
            if (initialProps.getString("googleMapId") != null) {
                googleMapOptions.mapId(initialProps.getString("googleMapId"));
            }
            if (initialProps.hasKey("liteMode")) {
                googleMapOptions.liteMode(initialProps.getBoolean("liteMode", false));
            }
            if (initialProps.hasKey("initialCamera")) {
                CameraPosition position = MapView.cameraPositionFromMap(initialProps.getMap("initialCamera"));
                if (position != null) {
                    googleMapOptions.camera(position);
                }
            } else if (initialProps.hasKey("camera")) {
                CameraPosition position = MapView.cameraPositionFromMap(initialProps.getMap("camera"));
                if (position != null) {
                    googleMapOptions.camera(position);
                }
            }
            if (initialProps.hasKey("googleRenderer") && "LEGACY".equals(initialProps.getString("googleRenderer"))) {
                renderer = MapsInitializer.Renderer.LEGACY;
            } else {
                renderer = MapsInitializer.Renderer.LATEST;
            }
        }
        return super.createViewInstance(reactTag, reactContext, initialProps, stateWrapper);
    }

    private void emitMapError(ThemedReactContext context, String message, String type) {
        WritableMap error = Arguments.createMap();
        error.putString("message", message);
        error.putString("type", type);

        context
                .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                .emit("onError", error);
    }

    @ReactProp(name = "region")
    public void setRegion(MapView view, ReadableMap region) {
        view.setRegion(region);
    }

    @ReactProp(name = "googleRenderer")
    public void setGoogleRenderer(MapView view, @Nullable String googleRenderer) {
        // do nothing, passed as part of the InitialProps
    }

    @ReactProp(name = "liteMode", defaultBoolean = false)
    public void setLiteMode(MapView view, boolean liteMode) {
        googleMapOptions.liteMode(liteMode);
    }

    @ReactProp(name = "googleMapId")
    public void setGoogleMapId(MapView view, @Nullable String googleMapId) {
        if (googleMapId != null) {
            googleMapOptions.mapId(googleMapId);
        }
    }

    @ReactProp(name = "initialRegion")
    public void setInitialRegion(MapView view, ReadableMap initialRegion) {
        view.setInitialRegion(initialRegion);
    }

    @ReactProp(name = "camera")
    public void setCamera(MapView view, ReadableMap camera) {
        view.setCamera(camera);
    }

    @ReactProp(name = "initialCamera")
    public void setInitialCamera(MapView view, ReadableMap initialCamera) {
        view.setInitialCamera(initialCamera);
    }

    @ReactProp(name = "mapType")
    public void setMapType(MapView view, @Nullable String mapType) {
        int typeId = MAP_TYPES.get(mapType);
        view.map.setMapType(typeId);
    }

    @ReactProp(name = "customMapStyleString")
    public void setMapStyle(MapView view, @Nullable String customMapStyleString) {
        view.setMapStyle(customMapStyleString);
    }

    @ReactProp(name = "mapPadding")
    public void setMapPadding(MapView view, @Nullable ReadableMap padding) {
        int left = 0;
        int top = 0;
        int right = 0;
        int bottom = 0;
        double density = (double) view.getResources().getDisplayMetrics().density;

        if (padding != null) {
            if (padding.hasKey("left")) {
                left = (int) (padding.getDouble("left") * density);
            }

            if (padding.hasKey("top")) {
                top = (int) (padding.getDouble("top") * density);
            }

            if (padding.hasKey("right")) {
                right = (int) (padding.getDouble("right") * density);
            }

            if (padding.hasKey("bottom")) {
                bottom = (int) (padding.getDouble("bottom") * density);
            }
        }

        view.applyBaseMapPadding(left, top, right, bottom);
        view.map.setPadding(left, top, right, bottom);
    }

    @ReactProp(name = "showsUserLocation", defaultBoolean = false)
    public void setShowsUserLocation(MapView view, boolean showUserLocation) {
        view.setShowsUserLocation(showUserLocation);
    }

    @ReactProp(name = "userLocationPriority")
    public void setUserLocationPriority(MapView view, @Nullable String accuracy) {
        view.setUserLocationPriority(MY_LOCATION_PRIORITY.get(accuracy));
    }

    @ReactProp(name = "userLocationUpdateInterval", defaultInt = 5000)
    public void setUserLocationUpdateInterval(MapView view, int updateInterval) {
        view.setUserLocationUpdateInterval(updateInterval);
    }

    @ReactProp(name = "userLocationFastestInterval", defaultInt = 5000)
    public void setUserLocationFastestInterval(MapView view, int fastestInterval) {
        view.setUserLocationFastestInterval(fastestInterval);
    }

    @ReactProp(name = "showsMyLocationButton", defaultBoolean = true)
    public void setShowsMyLocationButton(MapView view, boolean showMyLocationButton) {
        view.setShowsMyLocationButton(showMyLocationButton);
    }

    @ReactProp(name = "toolbarEnabled", defaultBoolean = true)
    public void setToolbarEnabled(MapView view, boolean toolbarEnabled) {
        view.setToolbarEnabled(toolbarEnabled);
    }

    // This is a private prop to improve performance of panDrag by disabling it when the callback
    // is not set
    @ReactProp(name = "handlePanDrag", defaultBoolean = false)
    public void setHandlePanDrag(MapView view, boolean handlePanDrag) {
        view.setHandlePanDrag(handlePanDrag);
    }

    @ReactProp(name = "showsTraffic", defaultBoolean = false)
    public void setShowTraffic(MapView view, boolean showTraffic) {
        view.map.setTrafficEnabled(showTraffic);
    }

    @ReactProp(name = "showsBuildings", defaultBoolean = false)
    public void setShowBuildings(MapView view, boolean showBuildings) {
        view.map.setBuildingsEnabled(showBuildings);
    }

    @ReactProp(name = "showsIndoors", defaultBoolean = false)
    public void setShowIndoors(MapView view, boolean showIndoors) {
        view.map.setIndoorEnabled(showIndoors);
    }

    @ReactProp(name = "showsIndoorLevelPicker", defaultBoolean = false)
    public void setShowsIndoorLevelPicker(MapView view, boolean showsIndoorLevelPicker) {
        view.map.getUiSettings().setIndoorLevelPickerEnabled(showsIndoorLevelPicker);
    }

    @ReactProp(name = "showsCompass", defaultBoolean = false)
    public void setShowsCompass(MapView view, boolean showsCompass) {
        view.map.getUiSettings().setCompassEnabled(showsCompass);
    }

    @ReactProp(name = "scrollEnabled", defaultBoolean = false)
    public void setScrollEnabled(MapView view, boolean scrollEnabled) {
        view.map.getUiSettings().setScrollGesturesEnabled(scrollEnabled);
    }

    @ReactProp(name = "zoomEnabled", defaultBoolean = false)
    public void setZoomEnabled(MapView view, boolean zoomEnabled) {
        view.map.getUiSettings().setZoomGesturesEnabled(zoomEnabled);
    }

    @ReactProp(name = "zoomControlEnabled", defaultBoolean = true)
    public void setZoomControlEnabled(MapView view, boolean zoomControlEnabled) {
        view.map.getUiSettings().setZoomControlsEnabled(zoomControlEnabled);
    }

    @ReactProp(name = "rotateEnabled", defaultBoolean = false)
    public void setRotateEnabled(MapView view, boolean rotateEnabled) {
        view.map.getUiSettings().setRotateGesturesEnabled(rotateEnabled);
    }

    @ReactProp(name = "scrollDuringRotateOrZoomEnabled", defaultBoolean = true)
    public void setScrollDuringRotateOrZoomEnabled(MapView view, boolean scrollDuringRotateOrZoomEnabled) {
        view.map.getUiSettings().setScrollGesturesEnabledDuringRotateOrZoom(scrollDuringRotateOrZoomEnabled);
    }

    @ReactProp(name = "cacheEnabled", defaultBoolean = false)
    public void setCacheEnabled(MapView view, boolean cacheEnabled) {
        view.setCacheEnabled(cacheEnabled);
    }

      @ReactProp(name = "poiClickEnabled", defaultBoolean = true)
        public void setPoiClickEnabled(MapView view, boolean poiClickEnabled) {
            view.setPoiClickEnabled(poiClickEnabled);
        }

    @ReactProp(name = "loadingEnabled", defaultBoolean = false)
    public void setLoadingEnabled(MapView view, boolean loadingEnabled) {
        view.enableMapLoading(loadingEnabled);
    }

    @ReactProp(name = "moveOnMarkerPress", defaultBoolean = true)
    public void setMoveOnMarkerPress(MapView view, boolean moveOnPress) {
        view.setMoveOnMarkerPress(moveOnPress);
    }

    @ReactProp(name = "loadingBackgroundColor", customType = "Color")
    public void setLoadingBackgroundColor(MapView view, @Nullable Integer loadingBackgroundColor) {
        view.setLoadingBackgroundColor(loadingBackgroundColor);
    }

    @ReactProp(name = "loadingIndicatorColor", customType = "Color")
    public void setLoadingIndicatorColor(MapView view, @Nullable Integer loadingIndicatorColor) {
        view.setLoadingIndicatorColor(loadingIndicatorColor);
    }

    @ReactProp(name = "pitchEnabled", defaultBoolean = false)
    public void setPitchEnabled(MapView view, boolean pitchEnabled) {
        view.map.getUiSettings().setTiltGesturesEnabled(pitchEnabled);
    }

    @ReactProp(name = "minZoomLevel")
    public void setMinZoomLevel(MapView view, float minZoomLevel) {
        view.map.setMinZoomPreference(minZoomLevel);
    }

    @ReactProp(name = "maxZoomLevel")
    public void setMaxZoomLevel(MapView view, float maxZoomLevel) {
        view.map.setMaxZoomPreference(maxZoomLevel);
    }

    @ReactProp(name = "kmlSrc")
    public void setKmlSrc(MapView view, String kmlUrl) {
        if (kmlUrl != null) {
            view.setKmlSrc(kmlUrl);
        }
    }

    @ReactProp(name = "accessibilityLabel")
    public void setAccessibilityLabel(MapView view, @Nullable String accessibilityLabel) {
        view.setTag(R.id.accessibility_label, accessibilityLabel);
    }

    @Override
    public void receiveCommand(@NonNull MapView view, String commandId, @Nullable ReadableArray args) {
        int duration;
        double lat;
        double lng;
        double lngDelta;
        double latDelta;
        ReadableMap region;
        ReadableMap camera;

        switch (commandId) {
            case "setCamera":
                if (args == null) {
                    break;
                }
                camera = args.getMap(0);
                view.animateToCamera(camera, 0);
                break;

            case "animateCamera":
                if (args == null) {
                    break;
                }
                camera = args.getMap(0);
                duration = args.getInt(1);
                view.animateToCamera(camera, duration);
                break;

            case "animateToRegion":
                if (args == null) {
                    break;
                }
                region = args.getMap(0);
                duration = args.getInt(1);
                lng = region.getDouble("longitude");
                lat = region.getDouble("latitude");
                lngDelta = region.getDouble("longitudeDelta");
                latDelta = region.getDouble("latitudeDelta");
                LatLngBounds bounds = new LatLngBounds(
                        new LatLng(lat - latDelta / 2, lng - lngDelta / 2), // southwest
                        new LatLng(lat + latDelta / 2, lng + lngDelta / 2)  // northeast
                );
                view.animateToRegion(bounds, duration);
                break;

            case "fitToElements":
                if (args == null) {
                    break;
                }
                view.fitToElements(args.getMap(0), args.getBoolean(1));
                break;

            case "fitToSuppliedMarkers":
                if (args == null) {
                    break;
                }
                view.fitToSuppliedMarkers(args.getArray(0), args.getMap(1), args.getBoolean(2));
                break;

            case "fitToCoordinates":
                if (args == null) {
                    break;
                }
                view.fitToCoordinates(args.getArray(0), args.getMap(1), args.getBoolean(2));
                break;

            case "setMapBoundaries":
                if (args == null) {
                    break;
                }
                view.setMapBoundaries(args.getMap(0), args.getMap(1));
                break;

            case "setIndoorActiveLevelIndex":
                if (args == null) {
                    break;
                }
                view.setIndoorActiveLevelIndex(args.getInt(0));
                break;
        }
    }

    @Override
    @Nullable
    public Map getExportedCustomDirectEventTypeConstants() {
        Map<String, Map<String, String>> map = MapBuilder.of(
                "onMapReady", MapBuilder.of("registrationName", "onMapReady"),
                "onPress", MapBuilder.of("registrationName", "onPress"),
                "onLongPress", MapBuilder.of("registrationName", "onLongPress"),
                "onMarkerPress", MapBuilder.of("registrationName", "onMarkerPress"),
                "onCalloutPress", MapBuilder.of("registrationName", "onCalloutPress")
        );

        map.putAll(MapBuilder.of(
                "onUserLocationChange", MapBuilder.of("registrationName", "onUserLocationChange"),
                "onMarkerDragStart", MapBuilder.of("registrationName", "onMarkerDragStart"),
                "onMarkerDrag", MapBuilder.of("registrationName", "onMarkerDrag"),
                "onMarkerDragEnd", MapBuilder.of("registrationName", "onMarkerDragEnd"),
                "onPanDrag", MapBuilder.of("registrationName", "onPanDrag"),
                "onKmlReady", MapBuilder.of("registrationName", "onKmlReady"),
                "onPoiClick", MapBuilder.of("registrationName", "onPoiClick")
        ));

        map.putAll(MapBuilder.of(
                "onIndoorLevelActivated", MapBuilder.of("registrationName", "onIndoorLevelActivated"),
                "onIndoorBuildingFocused", MapBuilder.of("registrationName", "onIndoorBuildingFocused"),
                "onDoublePress", MapBuilder.of("registrationName", "onDoublePress"),
                "onMapLoaded", MapBuilder.of("registrationName", "onMapLoaded"),
                "onMarkerSelect", MapBuilder.of("registrationName", "onMarkerSelect"),
                "onMarkerDeselect", MapBuilder.of("registrationName", "onMarkerDeselect"),
                "onRegionChangeStart", MapBuilder.of("registrationName", "onRegionChangeStart")
        ));

        return map;
    }

    @Override
    public LayoutShadowNode createShadowNodeInstance() {
        // A custom shadow node is needed in order to pass back the width/height of the map to the
        // view manager so that it can start applying camera moves with bounds.
        return new SizeReportingShadowNode();
    }

    @Override
    public void addView(MapView parent, View child, int index) {
        parent.addFeature(child, index);
    }

    @Override
    public int getChildCount(MapView view) {
        return view.getFeatureCount();
    }

    @Override
    public View getChildAt(MapView view, int index) {
        return view.getFeatureAt(index);
    }

    @Override
    public void removeViewAt(MapView parent, int index) {
        parent.removeFeatureAt(index);
    }

    @Override
    public void updateExtraData(MapView view, Object extraData) {
        view.updateExtraData(extraData);
    }

    void pushEvent(ThemedReactContext context, View view, String name, WritableMap data) {
        context
                .getReactApplicationContext()
                .getJSModule(RCTEventEmitter.class)
                .receiveEvent(view.getId(), name, data);
    }

    @Override
    public void onDropViewInstance(MapView view) {
        view.doDestroy();
        super.onDropViewInstance(view);
    }

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapMarker.java">
package com.rnmaps.maps;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.drawable.Animatable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.view.View;
import android.widget.LinearLayout;
import android.animation.ObjectAnimator;
import android.util.Property;
import android.animation.TypeEvaluator;

import androidx.annotation.Nullable;

import com.facebook.common.references.CloseableReference;
import com.facebook.datasource.DataSource;
import com.facebook.drawee.backends.pipeline.Fresco;
import com.facebook.drawee.controller.BaseControllerListener;
import com.facebook.drawee.controller.ControllerListener;
import com.facebook.drawee.drawable.ScalingUtils;
import com.facebook.drawee.generic.GenericDraweeHierarchy;
import com.facebook.drawee.generic.GenericDraweeHierarchyBuilder;
import com.facebook.drawee.interfaces.DraweeController;
import com.facebook.drawee.view.DraweeHolder;
import com.facebook.imagepipeline.core.ImagePipeline;
import com.facebook.imagepipeline.image.CloseableImage;
import com.facebook.imagepipeline.image.CloseableStaticBitmap;
import com.facebook.imagepipeline.image.ImageInfo;
import com.facebook.imagepipeline.request.ImageRequest;
import com.facebook.imagepipeline.request.ImageRequestBuilder;
import com.facebook.react.bridge.ReadableMap;
import com.google.android.gms.maps.model.BitmapDescriptor;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.Marker;
import com.google.android.gms.maps.model.MarkerOptions;
import com.google.maps.android.collections.MarkerManager;

public class MapMarker extends MapFeature {

private MarkerOptions markerOptions;
private Marker marker;
private int width;
private int height;
private String identifier;

private LatLng position;
private String title;
private String snippet;

private boolean anchorIsSet;
private float anchorX;
private float anchorY;

private MapCallout calloutView;
private View wrappedCalloutView;
private final Context context;

private float markerHue = 0.0f; // should be between 0 and 360
private BitmapDescriptor iconBitmapDescriptor;
private Bitmap iconBitmap;

private float rotation = 0.0f;
private boolean flat = false;
private boolean draggable = false;
private int zIndex = 0;
private float opacity = 1.0f;

private float calloutAnchorX;
private float calloutAnchorY;
private boolean calloutAnchorIsSet;

private boolean tracksViewChanges = true;
private boolean tracksViewChangesActive = false;

private boolean hasCustomMarkerView = false;
private final MapMarkerManager markerManager;
private String imageUri;

private final DraweeHolder<?> logoHolder;
private DataSource<CloseableReference<CloseableImage>> dataSource;
private final ControllerListener<ImageInfo> mLogoControllerListener =
new BaseControllerListener<ImageInfo>() {
@Override
public void onFinalImageSet(
String id,
@Nullable final ImageInfo imageInfo,
@Nullable Animatable animatable) {
CloseableReference<CloseableImage> imageReference = null;
try {
imageReference = dataSource.getResult();
if (imageReference != null) {
CloseableImage image = imageReference.get();
if (image instanceof CloseableStaticBitmap) {
CloseableStaticBitmap closeableStaticBitmap = (CloseableStaticBitmap) image;
Bitmap bitmap = closeableStaticBitmap.getUnderlyingBitmap();
if (bitmap != null) {
bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);
iconBitmap = bitmap;
iconBitmapDescriptor = BitmapDescriptorFactory.fromBitmap(bitmap);
}
}
}
} finally {
dataSource.close();
if (imageReference != null) {
CloseableReference.closeSafely(imageReference);
}
}
if (MapMarker.this.markerManager != null && MapMarker.this.imageUri != null) {
MapMarker.this.markerManager.getSharedIcon(MapMarker.this.imageUri)
.updateIcon(iconBitmapDescriptor, iconBitmap);
}
update(true);
}
};

public MapMarker(Context context, MapMarkerManager markerManager) {
super(context);
this.context = context;
this.markerManager = markerManager;
logoHolder = DraweeHolder.create(createDraweeHierarchy(), context);
logoHolder.onAttach();
}

public MapMarker(Context context, MarkerOptions options, MapMarkerManager markerManager) {
super(context);
this.context = context;
this.markerManager = markerManager;
logoHolder = DraweeHolder.create(createDraweeHierarchy(), context);
logoHolder.onAttach();

    position = options.getPosition();
    setAnchor(options.getAnchorU(), options.getAnchorV());
    setCalloutAnchor(options.getInfoWindowAnchorU(), options.getInfoWindowAnchorV());
    setTitle(options.getTitle());
    setSnippet(options.getSnippet());
    setRotation(options.getRotation());
    setFlat(options.isFlat());
    setDraggable(options.isDraggable());
    setZIndex(Math.round(options.getZIndex()));
    setAlpha(options.getAlpha());
    iconBitmapDescriptor = options.getIcon();

}

private GenericDraweeHierarchy createDraweeHierarchy() {
return new GenericDraweeHierarchyBuilder(getResources())
.setActualImageScaleType(ScalingUtils.ScaleType.FIT_CENTER)
.setFadeDuration(0)
.build();
}

public void setCoordinate(ReadableMap coordinate) {
position = new LatLng(coordinate.getDouble("latitude"), coordinate.getDouble("longitude"));
if (marker != null) {
marker.setPosition(position);
}
update(false);
}

public void setIdentifier(String identifier) {
this.identifier = identifier;
update(false);
}

public String getIdentifier() {
return this.identifier;
}

public void setTitle(String title) {
this.title = title;
if (marker != null) {
marker.setTitle(title);
}
update(false);
}

public void setSnippet(String snippet) {
this.snippet = snippet;
if (marker != null) {
marker.setSnippet(snippet);
}
update(false);
}

public void setRotation(float rotation) {
this.rotation = rotation;
if (marker != null) {
marker.setRotation(rotation);
}
update(false);
}

public void setFlat(boolean flat) {
this.flat = flat;
if (marker != null) {
marker.setFlat(flat);
}
update(false);
}

public void setDraggable(boolean draggable) {
this.draggable = draggable;
if (marker != null) {
marker.setDraggable(draggable);
}
update(false);
}

public void setZIndex(int zIndex) {
this.zIndex = zIndex;
if (marker != null) {
marker.setZIndex(zIndex);
}
update(false);
}

public void setOpacity(float opacity) {
this.opacity = opacity;
if (marker != null) {
marker.setAlpha(opacity);
}
update(false);
}

public void setMarkerHue(float markerHue) {
this.markerHue = markerHue;
update(false);
}

public void setAnchor(double x, double y) {
anchorIsSet = true;
anchorX = (float) x;
anchorY = (float) y;
if (marker != null) {
marker.setAnchor(anchorX, anchorY);
}
update(false);
}

public void setCalloutAnchor(double x, double y) {
calloutAnchorIsSet = true;
calloutAnchorX = (float) x;
calloutAnchorY = (float) y;
if (marker != null) {
marker.setInfoWindowAnchor(calloutAnchorX, calloutAnchorY);
}
update(false);
}

public void setTracksViewChanges(boolean tracksViewChanges) {
this.tracksViewChanges = tracksViewChanges;
updateTracksViewChanges();
}

private void updateTracksViewChanges() {
boolean shouldTrack = tracksViewChanges && hasCustomMarkerView && marker != null;
if (shouldTrack == tracksViewChangesActive) return;
tracksViewChangesActive = shouldTrack;

    if (shouldTrack) {
      ViewChangesTracker.getInstance().addMarker(this);
    } else {
      ViewChangesTracker.getInstance().removeMarker(this);

      // Let it render one more time to avoid race conditions.
      // i.e. Image onLoad ->
      //      ViewChangesTracker may not get a chance to render ->
      //      setState({ tracksViewChanges: false }) ->
      //      image loaded but not rendered.
      updateMarkerIcon();
    }

}

public LatLng getPosition() {
return position;
}

public boolean updateCustomForTracking() {
if (!tracksViewChangesActive)
return false;

    updateMarkerIcon();

    return true;

}

public void updateMarkerIcon() {
if (marker == null) return;

    marker.setIcon(getIcon());

}

public LatLng interpolate(float fraction, LatLng a, LatLng b) {
double lat = (b.latitude - a.latitude) _ fraction + a.latitude;
double lng = (b.longitude - a.longitude) _ fraction + a.longitude;
return new LatLng(lat, lng);
}

public void animateToCoodinate(LatLng finalPosition, Integer duration) {
TypeEvaluator<LatLng> typeEvaluator = new TypeEvaluator<LatLng>() {
@Override
public LatLng evaluate(float fraction, LatLng startValue, LatLng endValue) {
return interpolate(fraction, startValue, endValue);
}
};
Property<Marker, LatLng> property = Property.of(Marker.class, LatLng.class, "position");
ObjectAnimator animator = ObjectAnimator.ofObject(
marker,
property,
typeEvaluator,
finalPosition);
animator.setDuration(duration);
animator.start();
}

public void setImage(String uri) {

    boolean shouldLoadImage = true;

    if (this.markerManager != null) {
      // remove marker from previous shared icon if needed, to avoid future updates from it.
      // remove the shared icon completely if no markers on it as well.
      // this is to avoid memory leak due to orphan bitmaps.
      //
      // However in case where client want to update all markers from icon A to icon B
      // and after some time to update back from icon B to icon A
      // it may be better to keep it though. We assume that is rare.
      if (this.imageUri != null) {
        this.markerManager.getSharedIcon(this.imageUri).removeMarker(this);
        this.markerManager.removeSharedIconIfEmpty(this.imageUri);
      }
      if (uri != null) {
        // listening for marker bitmap descriptor update, as well as check whether to load the image.
        MapMarkerManager.AirMapMarkerSharedIcon sharedIcon = this.markerManager.getSharedIcon(uri);
        sharedIcon.addMarker(this);
        shouldLoadImage = sharedIcon.shouldLoadImage();
      }
    }

    this.imageUri = uri;
    if (!shouldLoadImage) {return;}

    if (uri == null) {
      iconBitmapDescriptor = null;
      update(true);
    } else if (uri.startsWith("http://") || uri.startsWith("https://") ||
        uri.startsWith("file://") || uri.startsWith("asset://") || uri.startsWith("data:")) {
      ImageRequest imageRequest = ImageRequestBuilder
          .newBuilderWithSource(Uri.parse(uri))
          .build();

      ImagePipeline imagePipeline = Fresco.getImagePipeline();
      dataSource = imagePipeline.fetchDecodedImage(imageRequest, this);
      DraweeController controller = Fresco.newDraweeControllerBuilder()
          .setImageRequest(imageRequest)
          .setControllerListener(mLogoControllerListener)
          .setOldController(logoHolder.getController())
          .build();
      logoHolder.setController(controller);
    } else {
      iconBitmapDescriptor = getBitmapDescriptorByName(uri);
      int drawableId = getDrawableResourceByName(uri);
      iconBitmap = BitmapFactory.decodeResource(getResources(), drawableId);
      if (iconBitmap == null) { // VectorDrawable or similar
          Drawable drawable = getResources().getDrawable(drawableId);
          iconBitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
          drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
          Canvas canvas = new Canvas(iconBitmap);
          drawable.draw(canvas);
      }
      if (this.markerManager != null) {
        this.markerManager.getSharedIcon(uri).updateIcon(iconBitmapDescriptor, iconBitmap);
      }
      update(true);
    }

}

public void setIconBitmapDescriptor(BitmapDescriptor bitmapDescriptor, Bitmap bitmap) {
this.iconBitmapDescriptor = bitmapDescriptor;
this.iconBitmap = bitmap;
this.update(true);
}

public void setIconBitmap(Bitmap bitmap) {
this.iconBitmap = bitmap;
}

public MarkerOptions getMarkerOptions() {
if (markerOptions == null) {
markerOptions = new MarkerOptions();
}

    fillMarkerOptions(markerOptions);
    return markerOptions;

}

@Override
public void addView(View child, int index) {
super.addView(child, index);
// if children are added, it means we are rendering a custom marker
if (!(child instanceof MapCallout)) {
hasCustomMarkerView = true;
updateTracksViewChanges();
}
update(true);
}

@Override
public void requestLayout() {
super.requestLayout();

    if (getChildCount() == 0) {
      if (hasCustomMarkerView) {
        hasCustomMarkerView = false;
        clearDrawableCache();
        updateTracksViewChanges();
        update(true);
      }

    }

}

@Override
public Object getFeature() {
return marker;
}

@Override
public void addToMap(Object collection) {
MarkerManager.Collection markerCollection = (MarkerManager.Collection) collection;
marker = markerCollection.addMarker(getMarkerOptions());
updateTracksViewChanges();
}

@Override
public void removeFromMap(Object collection) {
if (marker == null) {
return;
}
MarkerManager.Collection markerCollection = (MarkerManager.Collection) collection;
markerCollection.remove(marker);
marker = null;
updateTracksViewChanges();
}

private BitmapDescriptor getIcon() {
if (hasCustomMarkerView) {
// creating a bitmap from an arbitrary view
if (iconBitmapDescriptor != null) {
Bitmap viewBitmap = createDrawable();
int width = Math.max(iconBitmap.getWidth(), viewBitmap.getWidth());
int height = Math.max(iconBitmap.getHeight(), viewBitmap.getHeight());
Bitmap combinedBitmap = Bitmap.createBitmap(width, height, iconBitmap.getConfig());
Canvas canvas = new Canvas(combinedBitmap);
canvas.drawBitmap(iconBitmap, 0, 0, null);
canvas.drawBitmap(viewBitmap, 0, 0, null);
return BitmapDescriptorFactory.fromBitmap(combinedBitmap);
} else {
return BitmapDescriptorFactory.fromBitmap(createDrawable());
}
} else if (iconBitmapDescriptor != null) {
// use local image as a marker
return iconBitmapDescriptor;
} else {
// render the default marker pin
return BitmapDescriptorFactory.defaultMarker(this.markerHue);
}
}

private MarkerOptions fillMarkerOptions(MarkerOptions options) {
options.position(position);
if (anchorIsSet) options.anchor(anchorX, anchorY);
if (calloutAnchorIsSet) options.infoWindowAnchor(calloutAnchorX, calloutAnchorY);
options.title(title);
options.snippet(snippet);
options.rotation(rotation);
options.flat(flat);
options.draggable(draggable);
options.zIndex(zIndex);
options.alpha(opacity);
options.icon(getIcon());
return options;
}

public void update(boolean updateIcon) {
if (marker == null) {
return;
}

    if (updateIcon)
      updateMarkerIcon();

    if (anchorIsSet) {
      marker.setAnchor(anchorX, anchorY);
    } else {
      marker.setAnchor(0.5f, 1.0f);
    }

    if (calloutAnchorIsSet) {
      marker.setInfoWindowAnchor(calloutAnchorX, calloutAnchorY);
    } else {
      marker.setInfoWindowAnchor(0.5f, 0);
    }

}

public void update(int width, int height) {
this.width = width;
this.height = height;

    update(true);

}

private Bitmap mLastBitmapCreated = null;

private void clearDrawableCache() {
mLastBitmapCreated = null;
}

private Bitmap createDrawable() {
int width = this.width <= 0 ? 100 : this.width;
int height = this.height <= 0 ? 100 : this.height;
this.buildDrawingCache();

    // Do not create the doublebuffer-bitmap each time. reuse it to save memory.
    Bitmap bitmap = mLastBitmapCreated;

    if (bitmap == null ||
            bitmap.isRecycled() ||
            bitmap.getWidth() != width ||
            bitmap.getHeight() != height) {
      bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
      mLastBitmapCreated = bitmap;
    } else {
      bitmap.eraseColor(Color.TRANSPARENT);
    }

    Canvas canvas = new Canvas(bitmap);
    this.draw(canvas);

    return bitmap;

}

public void setCalloutView(MapCallout view) {
this.calloutView = view;
}

public MapCallout getCalloutView() {
return this.calloutView;
}

public View getCallout() {
if (this.calloutView == null) return null;

    if (this.wrappedCalloutView == null) {
      this.wrapCalloutView();
    }

    if (this.calloutView.getTooltip()) {
      return this.wrappedCalloutView;
    } else {
      return null;
    }

}

public View getInfoContents() {
if (this.calloutView == null) return null;

    if (this.wrappedCalloutView == null) {
      this.wrapCalloutView();
    }

    if (this.calloutView.getTooltip()) {
      return null;
    } else {
      return this.wrappedCalloutView;
    }

}

private void wrapCalloutView() {
// some hackery is needed to get the arbitrary infowindow view to render centered, and
// with only the width/height that it needs.
if (this.calloutView == null || this.calloutView.getChildCount() == 0) {
return;
}

    LinearLayout LL = new LinearLayout(context);
    LL.setOrientation(LinearLayout.VERTICAL);
    LL.setLayoutParams(new LinearLayout.LayoutParams(
        this.calloutView.width,
        this.calloutView.height,
        0f
    ));


    LinearLayout LL2 = new LinearLayout(context);
    LL2.setOrientation(LinearLayout.HORIZONTAL);
    LL2.setLayoutParams(new LinearLayout.LayoutParams(
        this.calloutView.width,
        this.calloutView.height,
        0f
    ));

    LL.addView(LL2);
    LL2.addView(this.calloutView);

    this.wrappedCalloutView = LL;

}

private int getDrawableResourceByName(String name) {
return getResources().getIdentifier(
name,
"drawable",
getContext().getPackageName());
}

private BitmapDescriptor getBitmapDescriptorByName(String name) {
return BitmapDescriptorFactory.fromResource(getDrawableResourceByName(name));
}

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapMarkerManager.java">
package com.rnmaps.maps;

import android.graphics.Bitmap;
import android.graphics.Color;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.facebook.react.R;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.common.MapBuilder;
import com.facebook.react.uimanager.LayoutShadowNode;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;
import com.google.android.gms.maps.model.Marker;
import com.google.android.gms.maps.model.BitmapDescriptor;
import com.google.android.gms.maps.model.LatLng;

import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;

public class MapMarkerManager extends ViewGroupManager<MapMarker> {

    public static class AirMapMarkerSharedIcon {
        private BitmapDescriptor iconBitmapDescriptor;
        private Bitmap bitmap;
        private final Map<MapMarker, Boolean> markers;
        private boolean loadImageStarted;

        public AirMapMarkerSharedIcon() {
            this.markers = new WeakHashMap<>();
            this.loadImageStarted = false;
        }

        /**
         * check whether the load image process started.
         * caller AirMapMarker will only need to load it when this returns true.
         *
         * @return true if it is not started, false otherwise.
         */
        public synchronized boolean shouldLoadImage() {
            if (!this.loadImageStarted) {
                this.loadImageStarted = true;
                return true;
            }
            return false;
        }

        /**
         * subscribe icon update for given marker.
         * <p>
         * The marker is wrapped in weakReference, so no need to remove it explicitly.
         *
         * @param marker
         */
        public synchronized void addMarker(MapMarker marker) {
            this.markers.put(marker, true);
            if (this.iconBitmapDescriptor != null) {
                marker.setIconBitmapDescriptor(this.iconBitmapDescriptor, this.bitmap);
            }
        }

        /**
         * Remove marker from this shared icon.
         * <p>
         * Marker will only need to call it when the marker receives a different marker image uri.
         *
         * @param marker
         */
        public synchronized void removeMarker(MapMarker marker) {
            this.markers.remove(marker);
        }

        /**
         * check if there is markers still listening on this icon.
         * when there are not markers listen on it, we can remove it.
         *
         * @return true if there is, false otherwise
         */
        public synchronized boolean hasMarker() {
            return this.markers.isEmpty();
        }

        /**
         * Update the bitmap descriptor and bitmap for the image uri.
         * And notify all subscribers about the update.
         *
         * @param bitmapDescriptor
         * @param bitmap
         */
        public synchronized void updateIcon(BitmapDescriptor bitmapDescriptor, Bitmap bitmap) {

            this.iconBitmapDescriptor = bitmapDescriptor;
            this.bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);

            if (this.markers.isEmpty()) {
                return;
            }

            for (Map.Entry<MapMarker, Boolean> markerEntry : markers.entrySet()) {
                if (markerEntry.getKey() != null) {
                    markerEntry.getKey().setIconBitmapDescriptor(bitmapDescriptor, bitmap);
                }
            }
        }
    }

    private final Map<String, AirMapMarkerSharedIcon> sharedIcons = new ConcurrentHashMap<>();

    /**
     * get the shared icon object, if not existed, create a new one and store it.
     *
     * @param uri
     * @return the icon object for the given uri.
     */
    public AirMapMarkerSharedIcon getSharedIcon(String uri) {
        AirMapMarkerSharedIcon icon = this.sharedIcons.get(uri);
        if (icon == null) {
            synchronized (this) {
                if ((icon = this.sharedIcons.get(uri)) == null) {
                    icon = new AirMapMarkerSharedIcon();
                    this.sharedIcons.put(uri, icon);
                }
            }
        }
        return icon;
    }

    /**
     * Remove the share icon object from our sharedIcons map when no markers are listening for it.
     *
     * @param uri
     */
    public void removeSharedIconIfEmpty(String uri) {
        AirMapMarkerSharedIcon icon = this.sharedIcons.get(uri);
        if (icon == null) {
            return;
        }
        if (!icon.hasMarker()) {
            synchronized (this) {
                if ((icon = this.sharedIcons.get(uri)) != null && !icon.hasMarker()) {
                    this.sharedIcons.remove(uri);
                }
            }
        }
    }

    public MapMarkerManager() {
    }

    @Override
    public String getName() {
        return "AIRMapMarker";
    }

    @Override
    public MapMarker createViewInstance(ThemedReactContext context) {
        return new MapMarker(context, this);
    }

    @ReactProp(name = "coordinate")
    public void setCoordinate(MapMarker view, ReadableMap map) {
        view.setCoordinate(map);
    }

    @ReactProp(name = "title")
    public void setTitle(MapMarker view, String title) {
        view.setTitle(title);
    }

    @ReactProp(name = "identifier")
    public void setIdentifier(MapMarker view, String identifier) {
        view.setIdentifier(identifier);
    }

    @ReactProp(name = "description")
    public void setDescription(MapMarker view, String description) {
        view.setSnippet(description);
    }

    // NOTE(lmr):
    // android uses normalized coordinate systems for this, and is provided through the
    // `anchor` property  and `calloutAnchor` instead.  Perhaps some work could be done
    // to normalize iOS and android to use just one of the systems.

// @ReactProp(name = "centerOffset")
// public void setCenterOffset(AirMapMarker view, ReadableMap map) {
//
// }
//
// @ReactProp(name = "calloutOffset")
// public void setCalloutOffset(AirMapMarker view, ReadableMap map) {
//
// }

    @ReactProp(name = "anchor")
    public void setAnchor(MapMarker view, ReadableMap map) {
        // should default to (0.5, 1) (bottom middle)
        double x = map != null && map.hasKey("x") ? map.getDouble("x") : 0.5;
        double y = map != null && map.hasKey("y") ? map.getDouble("y") : 1.0;
        view.setAnchor(x, y);
    }

    @ReactProp(name = "calloutAnchor")
    public void setCalloutAnchor(MapMarker view, ReadableMap map) {
        // should default to (0.5, 0) (top middle)
        double x = map != null && map.hasKey("x") ? map.getDouble("x") : 0.5;
        double y = map != null && map.hasKey("y") ? map.getDouble("y") : 0.0;
        view.setCalloutAnchor(x, y);
    }

    @ReactProp(name = "image")
    public void setImage(MapMarker view, @Nullable String source) {
        view.setImage(source);
    }

// public void setImage(AirMapMarker view, ReadableMap image) {
// view.setImage(image);
// }

    @ReactProp(name = "icon")
    public void setIcon(MapMarker view, @Nullable String source) {
        view.setImage(source);
    }

    @ReactProp(name = "pinColor", defaultInt = Color.RED, customType = "Color")
    public void setPinColor(MapMarker view, int pinColor) {
        float[] hsv = new float[3];
        Color.colorToHSV(pinColor, hsv);
        // NOTE: android only supports a hue
        view.setMarkerHue(hsv[0]);
    }

    @ReactProp(name = "rotation", defaultFloat = 0.0f)
    public void setMarkerRotation(MapMarker view, float rotation) {
        view.setRotation(rotation);
    }

    @ReactProp(name = "flat", defaultBoolean = false)
    public void setFlat(MapMarker view, boolean flat) {
        view.setFlat(flat);
    }

    @ReactProp(name = "draggable", defaultBoolean = false)
    public void setDraggable(MapMarker view, boolean draggable) {
        view.setDraggable(draggable);
    }

    @Override
    @ReactProp(name = "zIndex", defaultFloat = 0.0f)
    public void setZIndex(MapMarker view, float zIndex) {
        super.setZIndex(view, zIndex);
        int integerZIndex = Math.round(zIndex);
        view.setZIndex(integerZIndex);
    }

    @Override
    @ReactProp(name = "opacity", defaultFloat = 1.0f)
    public void setOpacity(MapMarker view, float opacity) {
        super.setOpacity(view, opacity);
        view.setOpacity(opacity);
    }

    @ReactProp(name = "tracksViewChanges", defaultBoolean = true)
    public void setTracksViewChanges(MapMarker view, boolean tracksViewChanges) {
        view.setTracksViewChanges(tracksViewChanges);
    }

    @ReactProp(name = "accessibilityLabel")
    public void setAccessibilityLabel(MapMarker view, @Nullable String accessibilityLabel) {
        view.setTag(R.id.accessibility_label, accessibilityLabel);
    }

    @Override
    public void addView(MapMarker parent, View child, int index) {
        // if an <Callout /> component is a child, then it is a callout view, NOT part of the
        // marker.
        if (child instanceof MapCallout) {
            parent.setCalloutView((MapCallout) child);
        } else {
            super.addView(parent, child, index);
            parent.update(true);
        }
    }

    @Override
    public void removeViewAt(MapMarker parent, int index) {
        super.removeViewAt(parent, index);
        parent.update(true);
    }

    @Override
    public void receiveCommand(@NonNull MapMarker view, String commandId, @Nullable ReadableArray args) {
        int duration;
        double lat;
        double lng;
        ReadableMap region;

        switch (commandId) {
            case "showCallout":
                ((Marker) view.getFeature()).showInfoWindow();
                break;

            case "hideCallout":
                ((Marker) view.getFeature()).hideInfoWindow();
                break;

            case "animateMarkerToCoordinate":
                if (args == null) {
                    break;
                }
                region = args.getMap(0);
                duration = args.getInt(1);

                lng = region.getDouble("longitude");
                lat = region.getDouble("latitude");
                view.animateToCoodinate(new LatLng(lat, lng), duration);
                break;

            case "redraw":
                view.updateMarkerIcon();
                break;
        }
    }

    @Override
    @Nullable
    public Map getExportedCustomDirectEventTypeConstants() {
        return MapBuilder.<String, Map<String, String>>builder()
                .put("onPress", MapBuilder.of("registrationName", "onPress"))
                .put("onCalloutPress", MapBuilder.of("registrationName", "onCalloutPress"))
                .put("onDragStart", MapBuilder.of("registrationName", "onDragStart"))
                .put("onDrag", MapBuilder.of("registrationName", "onDrag"))
                .put("onDragEnd", MapBuilder.of("registrationName", "onDragEnd"))
                .build();
    }

    @Override
    @Nullable
    public Map getExportedCustomBubblingEventTypeConstants() {
        return MapBuilder.<String, Map<String, Object>>builder()
                .put("onSelect", MapBuilder.of("phasedRegistrationNames", MapBuilder.of("bubbled", "onSelect")))
                .put("onDeselect", MapBuilder.of("phasedRegistrationNames", MapBuilder.of("bubbled", "onDeselect")))
                .build();
    }


    @Override
    public LayoutShadowNode createShadowNodeInstance() {
        // we use a custom shadow node that emits the width/height of the view
        // after layout with the updateExtraData method. Without this, we can't generate
        // a bitmap of the appropriate width/height of the rendered view.
        return new SizeReportingShadowNode();
    }

    @Override
    public void updateExtraData(MapMarker view, Object extraData) {
        // This method is called from the shadow node with the width/height of the rendered
        // marker view.
        HashMap<String, Float> data = (HashMap<String, Float>) extraData;
        float width = data.get("width");
        float height = data.get("height");
        view.update((int) width, (int) height);
    }

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapModule.java">
package com.rnmaps.maps;

import android.app.Activity;
import android.graphics.Bitmap;
import android.graphics.Point;
import android.location.Address;
import android.location.Geocoder;
import android.net.Uri;
import android.util.Base64;
import android.util.DisplayMetrics;

import androidx.annotation.Nullable;

import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.module.annotations.ReactModule;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.model.CameraPosition;
import com.google.android.gms.maps.model.LatLng;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ReactModule(name = MapModule.NAME)
public class MapModule extends ReactContextBaseJavaModule {

public static final String NAME = "AirMapModule";
private static final String SNAPSHOT_RESULT_FILE = "file";
private static final String SNAPSHOT_RESULT_BASE64 = "base64";
private static final String SNAPSHOT_FORMAT_PNG = "png";
private static final String SNAPSHOT_FORMAT_JPG = "jpg";

public MapModule(ReactApplicationContext reactContext) {
super(reactContext);
}

@Override
public String getName() {
return NAME;
}

@Override
public Map<String, Object> getConstants() {
final Map<String, Object> constants = new HashMap<>();
constants.put("legalNotice", "This license information is displayed in Settings > Google > Open Source on any device running Google Play services.");
return constants;
}

public Activity getActivity() {
return getCurrentActivity();
}

public static void closeQuietly(Closeable closeable) {
if (closeable == null) return;
try {
closeable.close();
} catch (IOException ignored) {
}
}

@ReactMethod
public void takeSnapshot(final int tag, final ReadableMap options, final Promise promise) {

    // Parse and verity options
    final ReactApplicationContext context = getReactApplicationContext();
    final String format = options.hasKey("format") ? options.getString("format") : "png";
    final Bitmap.CompressFormat compressFormat =
        format.equals(SNAPSHOT_FORMAT_PNG) ? Bitmap.CompressFormat.PNG :
            format.equals(SNAPSHOT_FORMAT_JPG) ? Bitmap.CompressFormat.JPEG : null;
    final double quality = options.hasKey("quality") ? options.getDouble("quality") : 1.0;
    final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
    final Integer width =
        options.hasKey("width") ? (int) (displayMetrics.density * options.getDouble("width")) : 0;
    final Integer height =
        options.hasKey("height") ? (int) (displayMetrics.density * options.getDouble("height")) : 0;
    final String result = options.hasKey("result") ? options.getString("result") : "file";

    MapUIBlock uiBlock = new MapUIBlock(tag, promise, context, view -> {
        view.map.snapshot(new GoogleMap.SnapshotReadyCallback() {
          public void onSnapshotReady(@Nullable Bitmap snapshot) {

            // Convert image to requested width/height if necessary
            if (snapshot == null) {
              promise.reject("Failed to generate bitmap, snapshot = null");
              return;
            }
            if ((width != 0) && (height != 0) &&
                (width != snapshot.getWidth() || height != snapshot.getHeight())) {
              snapshot = Bitmap.createScaledBitmap(snapshot, width, height, true);
            }

            // Save the snapshot to disk
            if (result.equals(SNAPSHOT_RESULT_FILE)) {
              File tempFile;
              FileOutputStream outputStream;
              try {
                tempFile =
                    File.createTempFile("AirMapSnapshot", "." + format, context.getCacheDir());
                outputStream = new FileOutputStream(tempFile);
              } catch (Exception e) {
                promise.reject(e);
                return;
              }
              snapshot.compress(compressFormat, (int) (100.0 * quality), outputStream);
              closeQuietly(outputStream);
              String uri = Uri.fromFile(tempFile).toString();
              promise.resolve(uri);
            } else if (result.equals(SNAPSHOT_RESULT_BASE64)) {
              ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
              snapshot.compress(compressFormat, (int) (100.0 * quality), outputStream);
              closeQuietly(outputStream);
              byte[] bytes = outputStream.toByteArray();
              String data = Base64.encodeToString(bytes, Base64.NO_WRAP);
              promise.resolve(data);
            }
          }
        });

        return null;
      });

    // Add UI-block so we can get a valid reference to the map-view

    uiBlock.addToUIManager();

}

@ReactMethod
public void getCamera(final int tag, final Promise promise) {
final ReactApplicationContext context = getReactApplicationContext();

    MapUIBlock uiBlock = new MapUIBlock(tag, promise, context, view -> {
        CameraPosition position = view.map.getCameraPosition();

        WritableMap centerJson = new WritableNativeMap();
        centerJson.putDouble("latitude", position.target.latitude);
        centerJson.putDouble("longitude", position.target.longitude);

        WritableMap cameraJson = new WritableNativeMap();
        cameraJson.putMap("center", centerJson);
        cameraJson.putDouble("heading", (double)position.bearing);
        cameraJson.putDouble("zoom", (double)position.zoom);
        cameraJson.putDouble("pitch", (double)position.tilt);

        promise.resolve(cameraJson);

        return null;
    });

    uiBlock.addToUIManager();

}

@ReactMethod
public void getAddressFromCoordinates(final int tag, final ReadableMap coordinate, final Promise promise) {
final ReactApplicationContext context = getReactApplicationContext();

    MapUIBlock uiBlock = new MapUIBlock(tag, promise, context, mapView -> {
        if (coordinate == null ||
                !coordinate.hasKey("latitude") ||
                !coordinate.hasKey("longitude")) {
          promise.reject("Invalid coordinate format");
          return null;
        }
        Geocoder geocoder = new Geocoder(context);
        try {
          List<Address> list =
                  geocoder.getFromLocation(coordinate.getDouble("latitude"),coordinate.getDouble("longitude"),1);
          if (list.isEmpty()) {
            promise.reject("Can not get address location");
            return null;
          }
          Address address = list.get(0);

          WritableMap addressJson = new WritableNativeMap();
          addressJson.putString("name", address.getFeatureName());
          addressJson.putString("locality", address.getLocality());
          addressJson.putString("thoroughfare", address.getThoroughfare());
          addressJson.putString("subThoroughfare", address.getSubThoroughfare());
          addressJson.putString("subLocality", address.getSubLocality());
          addressJson.putString("administrativeArea", address.getAdminArea());
          addressJson.putString("subAdministrativeArea", address.getSubAdminArea());
          addressJson.putString("postalCode", address.getPostalCode());
          addressJson.putString("countryCode", address.getCountryCode());
          addressJson.putString("country", address.getCountryName());

          promise.resolve(addressJson);
        } catch (IOException e) {
          promise.reject("Can not get address location");
        }

        return null;
    });

    uiBlock.addToUIManager();

}

@ReactMethod
public void pointForCoordinate(final int tag, ReadableMap coordinate, final Promise promise) {
final ReactApplicationContext context = getReactApplicationContext();
final double density = (double) context.getResources().getDisplayMetrics().density;

    final LatLng coord = new LatLng(
            coordinate.hasKey("latitude") ? coordinate.getDouble("latitude") : 0.0,
            coordinate.hasKey("longitude") ? coordinate.getDouble("longitude") : 0.0
    );

    MapUIBlock uiBlock = new MapUIBlock(tag, promise, context, view -> {
        Point pt = view.map.getProjection().toScreenLocation(coord);

        WritableMap ptJson = new WritableNativeMap();
        ptJson.putDouble("x", (double)pt.x / density);
        ptJson.putDouble("y", (double)pt.y / density);

        promise.resolve(ptJson);

        return null;
    });

    uiBlock.addToUIManager();

}

@ReactMethod
public void coordinateForPoint(final int tag, ReadableMap point, final Promise promise) {
final ReactApplicationContext context = getReactApplicationContext();
final double density = (double) context.getResources().getDisplayMetrics().density;

    final Point pt = new Point(
            point.hasKey("x") ? (int)(point.getDouble("x") * density) : 0,
            point.hasKey("y") ? (int)(point.getDouble("y") * density) : 0
    );

    MapUIBlock uiBlock = new MapUIBlock(tag, promise, context, view -> {
        LatLng coord = view.map.getProjection().fromScreenLocation(pt);

        WritableMap coordJson = new WritableNativeMap();
        coordJson.putDouble("latitude", coord.latitude);
        coordJson.putDouble("longitude", coord.longitude);

        promise.resolve(coordJson);

        return null;
    });

    uiBlock.addToUIManager();

}

@ReactMethod
public void getMapBoundaries(final int tag, final Promise promise) {
final ReactApplicationContext context = getReactApplicationContext();

    MapUIBlock uiBlock = new MapUIBlock(tag, promise, context, view -> {
        double[][] boundaries = view.getMapBoundaries();

        WritableMap coordinates = new WritableNativeMap();
        WritableMap northEastHash = new WritableNativeMap();
        WritableMap southWestHash = new WritableNativeMap();

        northEastHash.putDouble("longitude", boundaries[0][0]);
        northEastHash.putDouble("latitude", boundaries[0][1]);
        southWestHash.putDouble("longitude", boundaries[1][0]);
        southWestHash.putDouble("latitude", boundaries[1][1]);

        coordinates.putMap("northEast", northEastHash);
        coordinates.putMap("southWest", southWestHash);

        promise.resolve(coordinates);

        return null;
    });

    uiBlock.addToUIManager();

}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapOverlay.java">
package com.rnmaps.maps;

import android.content.Context;
import android.graphics.Bitmap;

import com.facebook.react.bridge.ReadableArray;
import com.google.android.gms.maps.model.BitmapDescriptor;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.GroundOverlay;
import com.google.android.gms.maps.model.GroundOverlayOptions;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.LatLngBounds;
import com.google.maps.android.collections.GroundOverlayManager;

public class MapOverlay extends MapFeature implements ImageReadable {

private GroundOverlayOptions groundOverlayOptions;
private GroundOverlay groundOverlay;
private LatLngBounds bounds;
private float bearing;
private BitmapDescriptor iconBitmapDescriptor;
private boolean tappable;
private float zIndex;
private float transparency;

private final ImageReader mImageReader;
private GroundOverlayManager.Collection groundOverlayCollection;

public MapOverlay(Context context) {
super(context);
this.mImageReader = new ImageReader(context, getResources(), this);
}

public void setBounds(ReadableArray bounds) {
LatLng sw = new LatLng(bounds.getArray(0).getDouble(0), bounds.getArray(0).getDouble(1));
LatLng ne = new LatLng(bounds.getArray(1).getDouble(0), bounds.getArray(1).getDouble(1));
this.bounds = new LatLngBounds(sw, ne);
if (this.groundOverlay != null) {
this.groundOverlay.setPositionFromBounds(this.bounds);
}
}

public void setBearing(float bearing){
this.bearing = bearing;
if (this.groundOverlay != null) {
this.groundOverlay.setBearing(bearing);
}
}

public void setZIndex(float zIndex) {
this.zIndex = zIndex;
if (this.groundOverlay != null) {
this.groundOverlay.setZIndex(zIndex);
}
}

public void setTransparency(float transparency) {
this.transparency = transparency;
if (groundOverlay != null) {
groundOverlay.setTransparency(transparency);
}
}

public void setImage(String uri) {
this.mImageReader.setImage(uri);
}

public void setTappable(boolean tapabble) {
this.tappable = tapabble;
if (groundOverlay != null) {
groundOverlay.setClickable(tappable);
}
}

public GroundOverlayOptions getGroundOverlayOptions() {
if (this.groundOverlayOptions == null) {
this.groundOverlayOptions = createGroundOverlayOptions();
}
return this.groundOverlayOptions;
}

private GroundOverlayOptions createGroundOverlayOptions() {
if (this.groundOverlayOptions != null) {
return this.groundOverlayOptions;
}
GroundOverlayOptions options = new GroundOverlayOptions();
if (this.iconBitmapDescriptor != null) {
options.image(iconBitmapDescriptor);
} else {
// add stub image to be able to instantiate the overlay
// and store a reference to it in MapView
options.image(BitmapDescriptorFactory.defaultMarker());
// hide overlay until real image gets added
options.visible(false);
}
options.positionFromBounds(bounds);
options.zIndex(zIndex);
options.bearing(bearing);
options.transparency(transparency);
return options;
}

@Override
public Object getFeature() {
return groundOverlay;
}

@Override
public void addToMap(Object collection) {
GroundOverlayManager.Collection groundOverlayCollection = (GroundOverlayManager.Collection) collection;
GroundOverlayOptions groundOverlayOptions = getGroundOverlayOptions();
if (groundOverlayOptions != null) {
groundOverlay = groundOverlayCollection.addGroundOverlay(groundOverlayOptions);
groundOverlay.setClickable(this.tappable);
} else {
this.groundOverlayCollection = groundOverlayCollection;
}
}

@Override
public void removeFromMap(Object collection) {
if (groundOverlay != null) {
GroundOverlayManager.Collection groundOverlayCollection = (GroundOverlayManager.Collection) collection;
groundOverlayCollection.remove(groundOverlay);
groundOverlay = null;
groundOverlayOptions = null;
}
groundOverlayCollection = null;
}

@Override
public void setIconBitmap(Bitmap bitmap) {
}

@Override
public void setIconBitmapDescriptor(
BitmapDescriptor iconBitmapDescriptor) {
this.iconBitmapDescriptor = iconBitmapDescriptor;
}

@Override
public void update() {
this.groundOverlay = getGroundOverlay();
if (this.groundOverlay != null) {
this.groundOverlay.setVisible(true);
this.groundOverlay.setImage(this.iconBitmapDescriptor);
this.groundOverlay.setTransparency(this.transparency);
this.groundOverlay.setClickable(this.tappable);
}
}

private GroundOverlay getGroundOverlay() {
if (this.groundOverlay != null) {
return this.groundOverlay;
}
if (this.groundOverlayCollection == null) {
return null;
}
GroundOverlayOptions groundOverlayOptions = getGroundOverlayOptions();
if (groundOverlayOptions != null) {
return this.groundOverlayCollection.addGroundOverlay(groundOverlayOptions);
}
return null;
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapOverlayManager.java">
package com.rnmaps.maps;

import android.content.Context;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import androidx.annotation.Nullable;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.common.MapBuilder;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;

import java.util.Map;

public class MapOverlayManager extends ViewGroupManager<MapOverlay> {

public MapOverlayManager(ReactApplicationContext reactContext) {
super();
DisplayMetrics metrics = new DisplayMetrics();
((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
.getDefaultDisplay()
.getRealMetrics(metrics);
}

@Override
public String getName() {
return "AIRMapOverlay";
}

@Override
public MapOverlay createViewInstance(ThemedReactContext context) {
return new MapOverlay(context);
}

@ReactProp(name = "bounds")
public void setBounds(MapOverlay view, ReadableArray bounds) {
view.setBounds(bounds);
}

@ReactProp(name = "bearing")
public void setBearing(MapOverlay view, float bearing){
view.setBearing(bearing);
}

@ReactProp(name = "zIndex", defaultFloat = 1.0f)
public void setZIndex(MapOverlay view, float zIndex) {
view.setZIndex(zIndex);
}

@ReactProp(name = "opacity", defaultFloat = 1.0f)
public void setOpacity(MapOverlay view, float opacity) {
view.setTransparency(1 - opacity);
}

@ReactProp(name = "image")
public void setImage(MapOverlay view, @Nullable String source) {
view.setImage(source);
}

@ReactProp(name = "tappable", defaultBoolean = false)
public void setTappable(MapOverlay view, boolean tapabble) {
view.setTappable(tapabble);
}

@Override
@Nullable
public Map getExportedCustomDirectEventTypeConstants() {
return MapBuilder.of(
"onPress", MapBuilder.of("registrationName", "onPress")
);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapPolygon.java">
package com.rnmaps.maps;

import android.content.Context;

import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.google.android.gms.maps.model.Dash;
import com.google.android.gms.maps.model.Gap;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.PatternItem;
import com.google.android.gms.maps.model.Polygon;
import com.google.android.gms.maps.model.PolygonOptions;
import com.google.maps.android.collections.PolygonManager;

import java.util.ArrayList;
import java.util.List;

public class MapPolygon extends MapFeature {

private PolygonOptions polygonOptions;
private Polygon polygon;

private List<LatLng> coordinates;
private List<List<LatLng>> holes;
private int strokeColor;
private int fillColor;
private float strokeWidth;
private boolean geodesic;
private boolean tappable;
private float zIndex;
private ReadableArray patternValues;
private List<PatternItem> pattern;

public MapPolygon(Context context) {
super(context);
}

public void setCoordinates(ReadableArray coordinates) {
// it's kind of a bummer that we can't run map() or anything on the ReadableArray
this.coordinates = new ArrayList<>(coordinates.size());
for (int i = 0; i < coordinates.size(); i++) {
ReadableMap coordinate = coordinates.getMap(i);
this.coordinates.add(i,
new LatLng(coordinate.getDouble("latitude"), coordinate.getDouble("longitude")));
}
if (polygon != null) {
polygon.setPoints(this.coordinates);
}
}

public void setHoles(ReadableArray holes) {
if (holes == null) { return; }

    this.holes = new ArrayList<>(holes.size());

    for (int i = 0; i < holes.size(); i++) {
      ReadableArray hole = holes.getArray(i);

      if (hole.size() < 3) { continue; }

      List<LatLng> coordinates = new ArrayList<>();
      for (int j = 0; j < hole.size(); j++) {
        ReadableMap coordinate = hole.getMap(j);
        coordinates.add(new LatLng(
            coordinate.getDouble("latitude"),
            coordinate.getDouble("longitude")));
      }

      // If hole is triangle
      if (coordinates.size() == 3) {
        coordinates.add(coordinates.get(0));
      }

      this.holes.add(coordinates);
    }

    if (polygon != null) {
      polygon.setHoles(this.holes);
    }

}

public void setFillColor(int color) {
this.fillColor = color;
if (polygon != null) {
polygon.setFillColor(color);
}
}

public void setStrokeColor(int color) {
this.strokeColor = color;
if (polygon != null) {
polygon.setStrokeColor(color);
}
}

public void setStrokeWidth(float width) {
this.strokeWidth = width;
if (polygon != null) {
polygon.setStrokeWidth(width);
}
}

public void setTappable(boolean tapabble) {
this.tappable = tapabble;
if (polygon != null) {
polygon.setClickable(tappable);
}
}

public void setGeodesic(boolean geodesic) {
this.geodesic = geodesic;
if (polygon != null) {
polygon.setGeodesic(geodesic);
}
}

public void setZIndex(float zIndex) {
this.zIndex = zIndex;
if (polygon != null) {
polygon.setZIndex(zIndex);
}
}

public void setLineDashPattern(ReadableArray patternValues) {
this.patternValues = patternValues;
this.applyPattern();
}

private void applyPattern() {
if(patternValues == null) {
return;
}
this.pattern = new ArrayList<>(patternValues.size());
for (int i = 0; i < patternValues.size(); i++) {
float patternValue = (float) patternValues.getDouble(i);
boolean isGap = i % 2 != 0;
if(isGap) {
this.pattern.add(new Gap(patternValue));
}else {
PatternItem patternItem;
patternItem = new Dash(patternValue);
this.pattern.add(patternItem);
}
}
if(polygon != null) {
polygon.setStrokePattern(this.pattern);
}
}

public PolygonOptions getPolygonOptions() {
if (polygonOptions == null) {
polygonOptions = createPolygonOptions();
}
return polygonOptions;
}

private PolygonOptions createPolygonOptions() {
PolygonOptions options = new PolygonOptions();
options.addAll(coordinates);
options.fillColor(fillColor);
options.strokeColor(strokeColor);
options.strokeWidth(strokeWidth);
options.geodesic(geodesic);
options.zIndex(zIndex);
options.strokePattern(this.pattern);

    if (this.holes != null) {
      for (int i = 0; i < holes.size(); i++) {
        options.addHole(holes.get(i));
      }
    }

    return options;

}

@Override
public Object getFeature() {
return polygon;
}

@Override
public void addToMap(Object collection) {
PolygonManager.Collection polygonCollection = (PolygonManager.Collection) collection;
polygon = polygonCollection.addPolygon(getPolygonOptions());
polygon.setClickable(this.tappable);
}

@Override
public void removeFromMap(Object collection) {
PolygonManager.Collection polygonCollection = (PolygonManager.Collection) collection;
polygonCollection.remove(polygon);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapPolygonManager.java">
package com.rnmaps.maps;

import android.content.Context;
import android.graphics.Color;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import androidx.annotation.Nullable;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.common.MapBuilder;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;

import java.util.Map;

public class MapPolygonManager extends ViewGroupManager<MapPolygon> {
private final DisplayMetrics metrics;

public MapPolygonManager(ReactApplicationContext reactContext) {
super();
metrics = new DisplayMetrics();
((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
.getDefaultDisplay()
.getRealMetrics(metrics);
}

@Override
public String getName() {
return "AIRMapPolygon";
}

@Override
public MapPolygon createViewInstance(ThemedReactContext context) {
return new MapPolygon(context);
}

@ReactProp(name = "coordinates")
public void setCoordinate(MapPolygon view, ReadableArray coordinates) {
view.setCoordinates(coordinates);
}

@ReactProp(name = "holes")
public void setHoles(MapPolygon view, ReadableArray holes) {
view.setHoles(holes);
}

@ReactProp(name = "strokeWidth", defaultFloat = 1f)
public void setStrokeWidth(MapPolygon view, float widthInPoints) {
float widthInScreenPx = metrics.density \* widthInPoints; // done for parity with iOS
view.setStrokeWidth(widthInScreenPx);
}

@ReactProp(name = "fillColor", defaultInt = Color.RED, customType = "Color")
public void setFillColor(MapPolygon view, int color) {
view.setFillColor(color);
}

@ReactProp(name = "strokeColor", defaultInt = Color.RED, customType = "Color")
public void setStrokeColor(MapPolygon view, int color) {
view.setStrokeColor(color);
}

@ReactProp(name = "tappable", defaultBoolean = false)
public void setTappable(MapPolygon view, boolean tapabble) {
view.setTappable(tapabble);
}

@ReactProp(name = "geodesic", defaultBoolean = false)
public void setGeodesic(MapPolygon view, boolean geodesic) {
view.setGeodesic(geodesic);
}

@ReactProp(name = "zIndex", defaultFloat = 1.0f)
public void setZIndex(MapPolygon view, float zIndex) {
view.setZIndex(zIndex);
}

@ReactProp(name = "lineDashPattern")
public void setLineDashPattern(MapPolygon view, ReadableArray patternValues) {
view.setLineDashPattern(patternValues);
}

@Override
@Nullable
public Map getExportedCustomDirectEventTypeConstants() {
return MapBuilder.of(
"onPress", MapBuilder.of("registrationName", "onPress")
);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapPolyline.java">
package com.rnmaps.maps;

import android.content.Context;

import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.google.android.gms.maps.model.Cap;
import com.google.android.gms.maps.model.Dash;
import com.google.android.gms.maps.model.Dot;
import com.google.android.gms.maps.model.Gap;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.PatternItem;
import com.google.android.gms.maps.model.Polyline;
import com.google.android.gms.maps.model.PolylineOptions;
import com.google.android.gms.maps.model.RoundCap;
import com.google.maps.android.collections.PolylineManager;

import java.util.ArrayList;
import java.util.List;

public class MapPolyline extends MapFeature {

private PolylineOptions polylineOptions;
private Polyline polyline;

private List<LatLng> coordinates;
private int color;
private float width;
private boolean tappable;
private boolean geodesic;
private float zIndex;
private Cap lineCap = new RoundCap();
private ReadableArray patternValues;
private List<PatternItem> pattern;

public MapPolyline(Context context) {
super(context);
}

public void setCoordinates(ReadableArray coordinates) {
this.coordinates = new ArrayList<>(coordinates.size());
for (int i = 0; i < coordinates.size(); i++) {
ReadableMap coordinate = coordinates.getMap(i);
this.coordinates.add(i,
new LatLng(coordinate.getDouble("latitude"), coordinate.getDouble("longitude")));
}
if (polyline != null) {
polyline.setPoints(this.coordinates);
}
}

public void setColor(int color) {
this.color = color;
if (polyline != null) {
polyline.setColor(color);
}
}

public void setWidth(float width) {
this.width = width;
if (polyline != null) {
polyline.setWidth(width);
}
}

public void setZIndex(float zIndex) {
this.zIndex = zIndex;
if (polyline != null) {
polyline.setZIndex(zIndex);
}
}

public void setTappable(boolean tapabble) {
this.tappable = tapabble;
if (polyline != null) {
polyline.setClickable(tappable);
}
}

public void setGeodesic(boolean geodesic) {
this.geodesic = geodesic;
if (polyline != null) {
polyline.setGeodesic(geodesic);
}
}

public void setLineCap(Cap cap) {
this.lineCap = cap;
if (polyline != null) {
polyline.setStartCap(cap);
polyline.setEndCap(cap);
}
this.applyPattern();
}

public void setLineDashPattern(ReadableArray patternValues) {
this.patternValues = patternValues;
this.applyPattern();
}

private void applyPattern() {
if(patternValues == null) {
return;
}
this.pattern = new ArrayList<>(patternValues.size());
for (int i = 0; i < patternValues.size(); i++) {
float patternValue = (float) patternValues.getDouble(i);
boolean isGap = i % 2 != 0;
if(isGap) {
this.pattern.add(new Gap(patternValue));
}else {
PatternItem patternItem;
boolean isLineCapRound = this.lineCap instanceof RoundCap;
if(isLineCapRound) {
patternItem = new Dot();
}else {
patternItem = new Dash(patternValue);
}
this.pattern.add(patternItem);
}
}
if(polyline != null) {
polyline.setPattern(this.pattern);
}
}

public PolylineOptions getPolylineOptions() {
if (polylineOptions == null) {
polylineOptions = createPolylineOptions();
}
return polylineOptions;
}

private PolylineOptions createPolylineOptions() {
PolylineOptions options = new PolylineOptions();
options.addAll(coordinates);
options.color(color);
options.width(width);
options.geodesic(geodesic);
options.zIndex(zIndex);
options.startCap(lineCap);
options.endCap(lineCap);
options.pattern(this.pattern);
return options;
}

@Override
public Object getFeature() {
return polyline;
}

@Override
public void addToMap(Object collection) {
PolylineManager.Collection polylineCollection = (PolylineManager.Collection) collection;
polyline = polylineCollection.addPolyline(getPolylineOptions());
polyline.setClickable(this.tappable);
}

@Override
public void removeFromMap(Object collection) {
PolylineManager.Collection polylineCollection = (PolylineManager.Collection) collection;
polylineCollection.remove(polyline);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapPolylineManager.java">
package com.rnmaps.maps;

import android.content.Context;
import android.graphics.Color;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import androidx.annotation.Nullable;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.common.MapBuilder;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;
import com.google.android.gms.maps.model.ButtCap;
import com.google.android.gms.maps.model.Cap;
import com.google.android.gms.maps.model.RoundCap;
import com.google.android.gms.maps.model.SquareCap;

import java.util.Map;

public class MapPolylineManager extends ViewGroupManager<MapPolyline> {
private final DisplayMetrics metrics;

public MapPolylineManager(ReactApplicationContext reactContext) {
super();
metrics = new DisplayMetrics();
((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
.getDefaultDisplay()
.getRealMetrics(metrics);
}

@Override
public String getName() {
return "AIRMapPolyline";
}

@Override
public MapPolyline createViewInstance(ThemedReactContext context) {
return new MapPolyline(context);
}

@ReactProp(name = "coordinates")
public void setCoordinate(MapPolyline view, ReadableArray coordinates) {
view.setCoordinates(coordinates);
}

@ReactProp(name = "strokeWidth", defaultFloat = 1f)
public void setStrokeWidth(MapPolyline view, float widthInPoints) {
float widthInScreenPx = metrics.density \* widthInPoints; // done for parity with iOS
view.setWidth(widthInScreenPx);
}

@ReactProp(name = "strokeColor", defaultInt = Color.RED, customType = "Color")
public void setStrokeColor(MapPolyline view, int color) {
view.setColor(color);
}

@ReactProp(name = "tappable", defaultBoolean = false)
public void setTappable(MapPolyline view, boolean tapabble) {
view.setTappable(tapabble);
}

@ReactProp(name = "geodesic", defaultBoolean = false)
public void setGeodesic(MapPolyline view, boolean geodesic) {
view.setGeodesic(geodesic);
}

@ReactProp(name = "zIndex", defaultFloat = 1.0f)
public void setZIndex(MapPolyline view, float zIndex) {
view.setZIndex(zIndex);
}

@ReactProp(name = "lineCap")
public void setlineCap(MapPolyline view, String lineCap) {
Cap cap = null;
switch (lineCap) {
case "butt":
cap = new ButtCap();
break;
case "round":
cap = new RoundCap();
break;
case "square":
cap = new SquareCap();
break;
default:
cap = new RoundCap();
break;
}
view.setLineCap(cap);
}

@ReactProp(name = "lineDashPattern")
public void setLineDashPattern(MapPolyline view, ReadableArray patternValues) {
view.setLineDashPattern(patternValues);
}

@Override
@Nullable
public Map getExportedCustomDirectEventTypeConstants() {
return MapBuilder.of(
"onPress", MapBuilder.of("registrationName", "onPress")
);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapsPackage.java">
package com.rnmaps.maps;

import com.facebook.react.ReactPackage;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ViewManager;

import java.util.ArrayList;
import java.util.List;

public class MapsPackage implements ReactPackage {

@Override
public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
List<NativeModule> modules = new ArrayList<>();

    modules.add(new MapModule(reactContext));

    return modules;

}

@Override
public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
MapManager mapManager = new MapManager(reactContext);
MapMarkerManager annotationManager = new MapMarkerManager();
mapManager.setMarkerManager(annotationManager);

    List<ViewManager> viewManagers = new ArrayList<>();

    viewManagers.add(mapManager);
    viewManagers.add(annotationManager);
    viewManagers.add(new MapCalloutManager());
    viewManagers.add(new MapPolylineManager(reactContext));
    viewManagers.add(new MapGradientPolylineManager(reactContext));
    viewManagers.add(new MapPolygonManager(reactContext));
    viewManagers.add(new MapCircleManager(reactContext));
    viewManagers.add(new MapUrlTileManager(reactContext));
    viewManagers.add(new MapWMSTileManager(reactContext));
    viewManagers.add(new MapLocalTileManager(reactContext));
    viewManagers.add(new MapOverlayManager(reactContext));
    viewManagers.add(new MapHeatmapManager());

    return viewManagers;

}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapTileProvider.java">
package com.rnmaps.maps;

import android.content.Context;

import android.util.Log;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Future;
import java.util.List;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;

import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Data;
import androidx.work.Constraints;
import androidx.work.NetworkType;
import androidx.work.ExistingWorkPolicy;
import androidx.work.Operation;
import androidx.work.WorkInfo;

import com.google.android.gms.maps.model.Tile;
import com.google.android.gms.maps.model.TileProvider;
import com.google.android.gms.maps.model.UrlTileProvider;

import java.lang.System;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;

public class MapTileProvider implements TileProvider {

    class AIRMapUrlTileProvider extends UrlTileProvider {
    private String urlTemplate;

    public AIRMapUrlTileProvider(int width, int height, String urlTemplate) {
      super(width, height);
      this.urlTemplate = urlTemplate;
    }

    @Override
    public URL getTileUrl(int x, int y, int zoom) {

      if (MapTileProvider.this.flipY) {
        y = (1 << zoom) - y - 1;
      }

      String s = this.urlTemplate
          .replace("{x}", Integer.toString(x))
          .replace("{y}", Integer.toString(y))
          .replace("{z}", Integer.toString(zoom));
      URL url;

      if(MapTileProvider.this.maximumZ > 0 && zoom > MapTileProvider.this.maximumZ) {
        return null;
      }

      if(MapTileProvider.this.minimumZ > 0 && zoom < MapTileProvider.this.minimumZ) {
        return null;
      }

      try {
        url = new URL(s);
      } catch (MalformedURLException e) {
        throw new AssertionError(e);
      }
      return url;
    }

    public void setUrlTemplate(String urlTemplate) {
      this.urlTemplate = urlTemplate;
    }

}

    protected static final int BUFFER_SIZE = 16 * 1024;
    protected static final int TARGET_TILE_SIZE = 512;
    protected UrlTileProvider tileProvider;
    protected String urlTemplate;
    protected int tileSize;

protected boolean doubleTileSize;
protected int maximumZ;
protected int maximumNativeZ;
protected int minimumZ;
protected boolean flipY;
protected String tileCachePath;
protected int tileCacheMaxAge;
protected boolean offlineMode;
protected Context context;
protected boolean customMode;

    public MapTileProvider(int tileSizet, boolean doubleTileSize, String urlTemplate,
                           int maximumZ, int maximumNativeZ, int minimumZ, boolean flipY, String tileCachePath,
                           int tileCacheMaxAge, boolean offlineMode, Context context, boolean customMode) {
    	this.tileProvider = new AIRMapUrlTileProvider(tileSizet, tileSizet, urlTemplate);

    	this.tileSize = tileSizet;
    this.doubleTileSize = doubleTileSize;
    	this.urlTemplate = urlTemplate;
    	this.maximumZ = maximumZ;
    this.maximumNativeZ = maximumNativeZ;
    	this.minimumZ = minimumZ;
    	this.flipY = flipY;
    	this.tileCachePath = tileCachePath;
    	this.tileCacheMaxAge = tileCacheMaxAge;
    this.offlineMode = offlineMode;
    	this.context = context;
    	this.customMode = customMode;
    }

    @Override
    public Tile getTile(int x, int y, int zoom) {
    	if (!this.customMode) return this.tileProvider.getTile(x, y, zoom);

    	byte[] image = null;
    	int maximumZ = this.maximumZ > 0 ? this.maximumZ : Integer.MAX_VALUE;

    	if (this.tileSize == 256 && this.doubleTileSize && zoom + 1 <= this.maximumNativeZ && zoom + 1 <= maximumZ) {
      Log.d("urlTile", "pullTilesFromHigherZoom");
    		image = pullTilesFromHigherZoom(x, y, zoom);
    	}

    if (zoom > this.maximumNativeZ) {
      Log.d("urlTile", "scaleLowerZoomTile");
    		image = scaleLowerZoomTile(x, y, zoom, this.maximumNativeZ);
    	}

    if (image == null && zoom <= maximumZ) {
      Log.d("urlTile", "getTileImage");
    		image = getTileImage(x, y, zoom);
    	}

    if (image == null && this.tileCachePath != null && this.offlineMode) {
      Log.d("urlTile", "findLowerZoomTileForScaling");
      int zoomLevelToStart = (zoom > this.maximumNativeZ) ? this.maximumNativeZ - 1 : zoom - 1;
      int minimumZoomToSearch = Math.max(this.minimumZ, zoom - 3);
      for (int tryZoom = zoomLevelToStart; tryZoom >= minimumZoomToSearch; tryZoom--) {

image = scaleLowerZoomTile(x, y, zoom, tryZoom);
if (image != null) {
break;
}
}
}

    	return image == null ? null : new Tile(this.tileSize, this.tileSize, image);
    }

    byte[] getTileImage(int x, int y, int zoom) {
    	byte[] image = null;

    	if (this.tileCachePath != null) {
    		image = readTileImage(x, y, zoom);
    		if (image != null) {
    			Log.d("urlTile", "tile cache HIT for " + zoom +
    				"/" + x + "/" + y);
    		} else {
    			Log.d("urlTile", "tile cache MISS for " + zoom +
        	"/" + x + "/" + y);
    		}
    		if (image != null && !this.offlineMode) {
    			checkForRefresh(x, y, zoom);
    		}
    	}

    	if (image == null && !this.offlineMode && this.tileCachePath != null) {
    		String fileName = getTileFilename(x, y, zoom);
    		Constraints constraints = new Constraints.Builder()
    			.setRequiredNetworkType(NetworkType.CONNECTED)
    			.build();
    		OneTimeWorkRequest tileRefreshWorkRequest = new OneTimeWorkRequest.Builder(MapTileWorker.class)
    			.setConstraints(constraints)
    			.addTag(fileName)
    			.setInputData(
    				new Data.Builder()
    					.putString("url", getTileUrl(x, y, zoom).toString())
    					.putString("filename", fileName)
    					.putInt("maxAge", -1)
    					.build()
    				)
    			.build();
    		WorkManager workManager = WorkManager.getInstance(this.context.getApplicationContext());
    		Operation fetchOperation = workManager
    			.enqueueUniqueWork(fileName, ExistingWorkPolicy.KEEP, tileRefreshWorkRequest);
    		Future<Operation.State.SUCCESS> operationFuture = fetchOperation.getResult();
    		try {
    			operationFuture.get(1L, TimeUnit.SECONDS);
    			Thread.sleep(500);
    			Future<List<WorkInfo>> fetchFuture = workManager.getWorkInfosByTag(fileName);
    			List<WorkInfo> workInfo = fetchFuture.get(1L, TimeUnit.SECONDS);
    			Log.d("urlTile: ", workInfo.get(0).toString());
    			if (this.tileCachePath != null) {
    				image = readTileImage(x, y, zoom);
    				if (image != null) {
    					Log.d("urlTile","tile cache fetch HIT for " + zoom +
    						"/" + x + "/" + y);
    				} else {
    						Log.d("urlTile","tile cache fetch MISS for " + zoom +
    							"/" + x + "/" + y);
    				}
    			}
    		} catch (Exception e) {
    		  e.printStackTrace();
    		}
    	} else if (image == null && !this.offlineMode) {
    		Log.d("urlTile", "Normal fetch");
    		image = fetchTile(x, y, zoom);
    		if (image == null) {
    			Log.d("urlTile", "tile fetch TIMEOUT / FAIL for " + zoom +
    				"/" + x + "/" + y);
    		}
    	}

    	return image;
    }

    byte[] pullTilesFromHigherZoom(int x, int y, int zoom) {
    byte[] data;
    Bitmap image = getNewBitmap();
    Canvas canvas = new Canvas(image);
    Paint paint = new Paint();

    x = x * 2;
    y = y * 2;
    byte[] leftTop = getTileImage(x, y, zoom + 1);
    byte[] leftBottom = getTileImage(x, y + 1, zoom + 1);
    byte[] rightTop = getTileImage(x + 1, y, zoom + 1);
    byte[] rightBottom = getTileImage(x + 1, y + 1, zoom + 1);

    if (leftTop == null || leftBottom == null || rightTop == null || rightBottom == null) {
      return null;
    }

    Bitmap bitmap;

    bitmap = BitmapFactory.decodeByteArray(leftTop, 0, leftTop.length);
    canvas.drawBitmap(bitmap, 0, 0, paint);
    bitmap.recycle();

    bitmap = BitmapFactory.decodeByteArray(leftBottom, 0, leftBottom.length);
    canvas.drawBitmap(bitmap, 0, 256, paint);
    bitmap.recycle();

    bitmap = BitmapFactory.decodeByteArray(rightTop, 0, rightTop.length);
    canvas.drawBitmap(bitmap, 256, 0, paint);
    bitmap.recycle();

    bitmap = BitmapFactory.decodeByteArray(rightBottom, 0, rightBottom.length);
    canvas.drawBitmap(bitmap, 256, 256, paint);
    bitmap.recycle();

    data = bitmapToByteArray(image);
    image.recycle();
    return data;

}

Bitmap getNewBitmap() {
Bitmap image = Bitmap.createBitmap(TARGET_TILE_SIZE, TARGET_TILE_SIZE, Bitmap.Config.ARGB_8888);
image.eraseColor(Color.TRANSPARENT);
return image;
}

byte[] bitmapToByteArray(Bitmap bm) {
ByteArrayOutputStream bos = new ByteArrayOutputStream();
bm.compress(Bitmap.CompressFormat.PNG, 100, bos);

    byte[] data = bos.toByteArray();
    try {
      bos.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
    return data;

}

    byte[] scaleLowerZoomTile(int x, int y, int zoom, int maximumZoom) {
    int overZoomLevel = zoom - maximumZoom;
    int zoomFactor = 1 << overZoomLevel;

    int xParent = x >> overZoomLevel;
    int yParent = y >> overZoomLevel;
    int zoomParent = zoom - overZoomLevel;

    int xOffset = x % zoomFactor;
    int yOffset = y % zoomFactor;

    byte[] data;
    Bitmap image = getNewBitmap();
    Canvas canvas = new Canvas(image);
    Paint paint = new Paint();

    	data = getTileImage(xParent, yParent, zoomParent);
    if (data == null) return null;

    Bitmap sourceImage;
    sourceImage = BitmapFactory.decodeByteArray(data, 0, data.length);

    int subTileSize = this.tileSize / zoomFactor;
    Rect sourceRect = new Rect(xOffset * subTileSize, yOffset * subTileSize, xOffset * subTileSize + subTileSize , yOffset * subTileSize + subTileSize);
    Rect targetRect = new Rect(0,0,TARGET_TILE_SIZE, TARGET_TILE_SIZE);
    canvas.drawBitmap(sourceImage, sourceRect, targetRect, paint);
    sourceImage.recycle();

    data = bitmapToByteArray(image);
    image.recycle();
    return data;
    }

    void checkForRefresh(int x, int y, int zoom) {
    	String fileName =  getTileFilename(x, y, zoom);
    	File file = new File(fileName);
    	long lastModified = file.lastModified();
    	long now = System.currentTimeMillis();

    	if ((now - lastModified) / 1000 > this.tileCacheMaxAge) {
      Log.d("urlTile", "Refreshing");
    		Constraints constraints = new Constraints.Builder()
    			.setRequiredNetworkType(NetworkType.CONNECTED)
    			.build();
    		OneTimeWorkRequest tileRefreshWorkRequest = new OneTimeWorkRequest.Builder(MapTileWorker.class)
    			.setConstraints(constraints)
    			.addTag(fileName)
    			.setInputData(
    				new Data.Builder()
    					.putString("url", getTileUrl(x, y, zoom).toString())
    					.putString("filename", fileName)
    					.putInt("maxAge", this.tileCacheMaxAge)
    					.build()
    				)
    			.build();
    		WorkManager.getInstance(this.context.getApplicationContext())
    		.enqueueUniqueWork(fileName, ExistingWorkPolicy.KEEP, tileRefreshWorkRequest);
    	}
    }

    byte[] fetchTile(int x, int y, int zoom) {
    	URL url = getTileUrl(x, y, zoom);
    	ByteArrayOutputStream buffer = null;
    	InputStream in = null;

    	try {
    		URLConnection conn = url.openConnection();
    		in = conn.getInputStream();
    		buffer = new ByteArrayOutputStream();

    		int nRead;
    		byte[] data = new byte[BUFFER_SIZE];

    		while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
    			buffer.write(data, 0, nRead);
    		}
    		buffer.flush();

    		return buffer.toByteArray();
    	} catch (IOException | OutOfMemoryError e) {
    		e.printStackTrace();
    		return null;
    	} finally {
    		if (in != null) try { in.close(); } catch (Exception ignored) {}
    		if (buffer != null) try { buffer.close(); } catch (Exception ignored) {}
    	}
    }

    byte[] readTileImage(int x, int y, int zoom) {
    	InputStream in = null;
    	ByteArrayOutputStream buffer = null;
    	String fileName = getTileFilename(x, y, zoom);
    	if (fileName == null) {
    		return null;
    	}

    	File file = new File(fileName);

    	try {
    		in = new FileInputStream(file);
    		buffer = new ByteArrayOutputStream();

    		int nRead;
    		byte[] data = new byte[BUFFER_SIZE];

    		while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
    			buffer.write(data, 0, nRead);
    		}
    		buffer.flush();

    		if (this.tileCacheMaxAge == 0) {
    			file.setLastModified(System.currentTimeMillis());
    		}

    		return buffer.toByteArray();
    	} catch (IOException | OutOfMemoryError e) {
    		e.printStackTrace();
    		return null;
    	} finally {
    		if (in != null) try { in.close(); } catch (Exception ignored) {}
    		if (buffer != null) try { buffer.close(); } catch (Exception ignored) {}
    	}
    }

    boolean writeTileImage(byte[] image, int x, int y, int zoom) {
    	OutputStream out = null;
    	String fileName = getTileFilename(x, y, zoom);
    	if (fileName == null) {
    		return false;
    	}

    	try {
    		File file = new File(fileName);
    		file.getParentFile().mkdirs();
    		out = new FileOutputStream(file);
    		out.write(image);

    		return true;
    	} catch (IOException | OutOfMemoryError e) {
    		e.printStackTrace();
    		return false;
    	} finally {
    		if (out != null) try { out.close(); } catch (Exception ignored) {}
    	}
    }

    String getTileFilename(int x, int y, int zoom) {
    	if (this.tileCachePath == null) {
    		return null;
    	}
    	return this.tileCachePath + '/' + zoom +
    		"/" + x + "/" + y;
    }

    protected URL getTileUrl(int x, int y, int zoom) {
    	return this.tileProvider.getTileUrl(x, y, zoom);
    }

    public void setUrlTemplate(String urlTemplate) {
    	if (this.urlTemplate != urlTemplate) {
    		this.tileProvider = new AIRMapUrlTileProvider(tileSize, tileSize, urlTemplate);
    	}

    	this.urlTemplate = urlTemplate;
    }

    public void setTileSize(int tileSize) {
    	if (this.tileSize != tileSize) {
    		this.tileProvider = new AIRMapUrlTileProvider(tileSize, tileSize, urlTemplate);
    	}
    	this.tileSize = tileSize;
    }

public void setDoubleTileSize(boolean doubleTileSize) {
this.doubleTileSize = doubleTileSize;
}

    public void setMaximumZ(int maximumZ) {
    	this.maximumZ = maximumZ;
    }

public void setMaximumNativeZ(int maximumNativeZ) {
this.maximumNativeZ = maximumNativeZ;
}

    public void setMinimumZ(int minimumZ) {
    	this.minimumZ = minimumZ;
    }

    public void setFlipY(boolean flipY) {
    	this.flipY = flipY;
    }

    public void setTileCachePath(String tileCachePath) {
    	this.tileCachePath = tileCachePath;
    }

    public void setTileCacheMaxAge(int tileCacheMaxAge) {
    	this.tileCacheMaxAge = tileCacheMaxAge;
    }

public void setOfflineMode(boolean offlineMode) {
this.offlineMode = offlineMode;
}

    public void setCustomMode() {
    }

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapTileWorker.java">
package com.rnmaps.maps;

import android.content.Context;

import android.util.Log;

import androidx.annotation.NonNull;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

import java.net.MalformedURLException;
import java.net.URL;

public class MapTileWorker extends Worker {
private static final int BUFFER_SIZE = 16 \* 1024;

    public MapTileWorker(
    		@NonNull Context context,
    		@NonNull WorkerParameters params) {
    		super(context, params);
    }

    @Override
    public Result doWork() {
    	byte[] image;
    	URL url;
    String fileName = getInputData().getString("filename");

    try {
      int tileCacheMaxAge = getInputData().getInt("maxAge", 0);
      if (tileCacheMaxAge >= 0) {
        File file = new File(fileName);
        	long lastModified = file.lastModified();
        long now = System.currentTimeMillis();
        if ((now - lastModified) / 1000 < tileCacheMaxAge) return Result.failure();
      }
    } catch (Error e) {
      return Result.failure();
    }

    	try {
      url = new URL(getInputData().getString("url"));
    } catch (MalformedURLException e) {
      throw new AssertionError(e);
    }

    	image = fetchTile(url);
    	if (image != null) {
    		boolean success = writeTileImage(image, fileName);
    		if (!success) {
    			return Result.failure();
    		}
    } else {
    		return Result.retry();
    	}

    	// Indicate whether the work finished successfully with the Result
    Log.d("urlTile", "Worker fetched " + fileName);
    	return Result.success();
    }

    private byte[] fetchTile(URL url) {
      ByteArrayOutputStream buffer = null;
      InputStream in = null;

      try {
        in = url.openStream();
        buffer = new ByteArrayOutputStream();

        int nRead;
        byte[] data = new byte[BUFFER_SIZE];

        while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
          buffer.write(data, 0, nRead);
        }
        buffer.flush();

        return buffer.toByteArray();
      } catch (IOException | OutOfMemoryError e) {
        e.printStackTrace();
        return null;
      } finally {
        if (in != null) try { in.close(); } catch (Exception ignored) {}
        if (buffer != null) try { buffer.close(); } catch (Exception ignored) {}
      }
    }

    private boolean writeTileImage(byte[] image, String fileName) {
      OutputStream out = null;
      if (fileName == null) {
        return false;
      }

      try {
        File file = new File(fileName);
        file.getParentFile().mkdirs();
        out = new FileOutputStream(file);
        out.write(image);

        return true;
      } catch (IOException | OutOfMemoryError e) {
        e.printStackTrace();
        return false;
      } finally {
        if (out != null) try { out.close(); } catch (Exception ignored) {}
      }

}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapUIBlock.java">
package com.rnmaps.maps;

import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.UIManager;
import com.facebook.react.fabric.FabricUIManager;
import com.facebook.react.fabric.interop.UIBlockViewResolver;
import com.facebook.react.uimanager.common.UIManagerType;
import com.facebook.react.uimanager.NativeViewHierarchyManager;
import com.facebook.react.uimanager.UIBlock;
import com.facebook.react.uimanager.UIManagerHelper;
import com.facebook.react.uimanager.UIManagerModule;

import java.util.function.Function;

public class MapUIBlock implements UIBlockInterface {
private int tag;
private Promise promise;
private ReactApplicationContext context;
private Function<MapView, Void> mapOperation;

    public MapUIBlock(int tag, Promise promise, ReactApplicationContext context, Function<MapView, Void> mapOperation) {
        this.tag = tag;
        this.promise = promise;
        this.context = context;
        this.mapOperation = mapOperation;
    }

    @Override
    public void execute(NativeViewHierarchyManager nvhm) {
        executeImpl(nvhm, null);
    }

    @Override
    public void execute(UIBlockViewResolver uiBlockViewResolver) {
        executeImpl(null, uiBlockViewResolver);
    }

    private void executeImpl(NativeViewHierarchyManager nvhm, UIBlockViewResolver uiBlockViewResolver) {
        MapView view = uiBlockViewResolver != null ? (MapView) uiBlockViewResolver.resolveView(tag) : (MapView) nvhm.resolveView(tag);
        if (view == null) {
            promise.reject("AirMapView not found");
            return;
        }
        if (view.map == null) {
            promise.reject("AirMapView.map is not valid");
            return;
        }

        mapOperation.apply(view);
    }

    public void addToUIManager() {
        if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
            UIManager uiManager = UIManagerHelper.getUIManager(context, UIManagerType.FABRIC);
            ((FabricUIManager) uiManager).addUIBlock(this);
        } else {
            UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
            uiManager.addUIBlock(this);
        }
    }

}

interface UIBlockInterface extends UIBlock, com.facebook.react.fabric.interop.UIBlock {}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapUrlTile.java">
package com.rnmaps.maps;

import android.util.Log;

import android.content.Context;

import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.model.TileOverlay;
import com.google.android.gms.maps.model.TileOverlayOptions;

import java.net.MalformedURLException;
import java.net.URL;

public class MapUrlTile extends MapFeature {
protected TileOverlayOptions tileOverlayOptions;
protected TileOverlay tileOverlay;
protected MapTileProvider tileProvider;

protected String urlTemplate;
protected float zIndex;
protected float maximumZ;
protected float maximumNativeZ = 100;
protected float minimumZ;
protected boolean flipY = false;
protected float tileSize = 256;
protected boolean doubleTileSize = false;
protected String tileCachePath;
protected float tileCacheMaxAge;
protected boolean offlineMode = false;
protected float opacity = 1;
protected Context context;
protected boolean customTileProviderNeeded = false;

public MapUrlTile(Context context) {
super(context);
this.context = context;
}

public void setUrlTemplate(String urlTemplate) {
this.urlTemplate = urlTemplate;
if (tileProvider != null) {
tileProvider.setUrlTemplate(urlTemplate);
}
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setZIndex(float zIndex) {
this.zIndex = zIndex;
if (tileOverlay != null) {
tileOverlay.setZIndex(zIndex);
}
}

public void setMaximumZ(float maximumZ) {
this.maximumZ = maximumZ;
if (tileProvider != null) {
tileProvider.setMaximumZ((int)maximumZ);
}
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setMaximumNativeZ(float maximumNativeZ) {
this.maximumNativeZ = maximumNativeZ;
if (tileProvider != null) {
tileProvider.setMaximumNativeZ((int)maximumNativeZ);
}
setCustomTileProviderMode();
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setMinimumZ(float minimumZ) {
this.minimumZ = minimumZ;
if (tileProvider != null) {
tileProvider.setMinimumZ((int)minimumZ);
}
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setFlipY(boolean flipY) {
this.flipY = flipY;
if (tileProvider != null) {
tileProvider.setFlipY(flipY);
}
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setDoubleTileSize(boolean doubleTileSize) {
this.doubleTileSize = doubleTileSize;
if (tileProvider != null) {
tileProvider.setDoubleTileSize(doubleTileSize);
}
setCustomTileProviderMode();
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setTileSize(float tileSize) {
this.tileSize = tileSize;
if (tileProvider != null) {
tileProvider.setTileSize((int)tileSize);
}
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setTileCachePath(String tileCachePath) {
if (tileCachePath == null || tileCachePath.isEmpty()) return;

    try {
      URL url = new URL(tileCachePath);
      this.tileCachePath = url.getPath();
    } catch (MalformedURLException e) {
      this.tileCachePath = tileCachePath;
    } catch (Exception e) {
      return;
    }

    if (tileProvider != null) {
      tileProvider.setTileCachePath(tileCachePath);
    }
    setCustomTileProviderMode();
    if (tileOverlay != null) {
      tileOverlay.clearTileCache();
    }

}

public void setTileCacheMaxAge(float tileCacheMaxAge) {
this.tileCacheMaxAge = tileCacheMaxAge;
if (tileProvider != null) {
tileProvider.setTileCacheMaxAge((int)tileCacheMaxAge);
}
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setOfflineMode(boolean offlineMode) {
this.offlineMode = offlineMode;
if (tileProvider != null) {
tileProvider.setOfflineMode(offlineMode);
}
if (tileOverlay != null) {
tileOverlay.clearTileCache();
}
}

public void setOpacity(float opacity) {
this.opacity = opacity;
if (tileOverlay != null) {
tileOverlay.setTransparency(1 - opacity);
}
}

public TileOverlayOptions getTileOverlayOptions() {
if (tileOverlayOptions == null) {
tileOverlayOptions = createTileOverlayOptions();
}
return tileOverlayOptions;
}

protected void setCustomTileProviderMode() {
Log.d("urlTile ", "creating new mode TileProvider");
this.customTileProviderNeeded = true;
if (tileProvider != null) {
tileProvider.setCustomMode();
}
}

protected TileOverlayOptions createTileOverlayOptions() {
Log.d("urlTile ", "creating TileProvider");
TileOverlayOptions options = new TileOverlayOptions();
options.zIndex(zIndex);
options.transparency(1 - this.opacity);
this.tileProvider = new MapTileProvider((int)this.tileSize, this.doubleTileSize, this.urlTemplate,
(int)this.maximumZ, (int)this.maximumNativeZ, (int)this.minimumZ, this.flipY, this.tileCachePath,
(int)this.tileCacheMaxAge, this.offlineMode, this.context, this.customTileProviderNeeded);
options.tileProvider(this.tileProvider);
return options;
}

@Override
public Object getFeature() {
return tileOverlay;
}

@Override
public void addToMap(Object map) {
this.tileOverlay = ((GoogleMap) map).addTileOverlay(getTileOverlayOptions());
}

@Override
public void removeFromMap(Object map) {
tileOverlay.remove();
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapUrlTileManager.java">
package com.rnmaps.maps;

import android.content.Context;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;

public class MapUrlTileManager extends ViewGroupManager<MapUrlTile> {

public MapUrlTileManager(ReactApplicationContext reactContext) {
super();
DisplayMetrics metrics = new DisplayMetrics();
((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
.getDefaultDisplay()
.getRealMetrics(metrics);
}

@Override
public String getName() {
return "AIRMapUrlTile";
}

@Override
public MapUrlTile createViewInstance(ThemedReactContext context) {
return new MapUrlTile(context);
}

@ReactProp(name = "urlTemplate")
public void setUrlTemplate(MapUrlTile view, String urlTemplate) {
view.setUrlTemplate(urlTemplate);
}

@ReactProp(name = "zIndex", defaultFloat = -1.0f)
public void setZIndex(MapUrlTile view, float zIndex) {
view.setZIndex(zIndex);
}

@ReactProp(name = "minimumZ", defaultFloat = 0.0f)
public void setMinimumZ(MapUrlTile view, float minimumZ) {
view.setMinimumZ(minimumZ);
}

@ReactProp(name = "maximumZ", defaultFloat = 100.0f)
public void setMaximumZ(MapUrlTile view, float maximumZ) {
view.setMaximumZ(maximumZ);
}

@ReactProp(name = "maximumNativeZ", defaultFloat = 100.0f)
public void setMaximumNativeZ(MapUrlTile view, float maximumNativeZ) {
view.setMaximumNativeZ(maximumNativeZ);
}

@ReactProp(name = "flipY", defaultBoolean = false)
public void setFlipY(MapUrlTile view, boolean flipY) {
view.setFlipY(flipY);
}

@ReactProp(name = "tileSize", defaultFloat = 256.0f)
public void setTileSize(MapUrlTile view, float tileSize) {
view.setTileSize(tileSize);
}

@ReactProp(name = "doubleTileSize", defaultBoolean = false)
public void setDoubleTileSize(MapUrlTile view, boolean doubleTileSize) {
view.setDoubleTileSize(doubleTileSize);
}

@ReactProp(name = "tileCachePath")
public void setTileCachePath(MapUrlTile view, String tileCachePath) {
view.setTileCachePath(tileCachePath);
}

@ReactProp(name = "tileCacheMaxAge", defaultFloat = 0.0f)
public void setTileCacheMaxAge(MapUrlTile view, float tileCacheMaxAge) {
view.setTileCacheMaxAge(tileCacheMaxAge);
}

@ReactProp(name = "offlineMode", defaultBoolean = false)
public void setOfflineMode(MapUrlTile view, boolean offlineMode) {
view.setOfflineMode(offlineMode);
}

@ReactProp(name = "opacity", defaultFloat = 1.0f)
public void setOpacity(MapUrlTile view, float opacity) {
view.setOpacity(opacity);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapView.java">
package com.rnmaps.maps;

import static androidx.core.content.PermissionChecker.checkSelfPermission;

import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.Point;
import android.location.Location;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.RelativeLayout;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.PermissionChecker;
import androidx.core.view.GestureDetectorCompat;
import androidx.core.view.MotionEventCompat;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.LifecycleEventListener;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeArray;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.UIManagerHelper;
import com.facebook.react.uimanager.common.UIManagerType;
import com.facebook.react.uimanager.events.EventDispatcher;
import com.google.android.gms.maps.CameraUpdate;
import com.google.android.gms.maps.CameraUpdateFactory;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.GoogleMapOptions;
import com.google.android.gms.maps.MapsInitializer;
import com.google.android.gms.maps.OnMapReadyCallback;
import com.google.android.gms.maps.Projection;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.CameraPosition;
import com.google.android.gms.maps.model.GroundOverlay;
import com.google.android.gms.maps.model.IndoorBuilding;
import com.google.android.gms.maps.model.IndoorLevel;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.LatLngBounds;
import com.google.android.gms.maps.model.MapStyleOptions;
import com.google.android.gms.maps.model.Marker;
import com.google.android.gms.maps.model.MarkerOptions;
import com.google.android.gms.maps.model.PointOfInterest;
import com.google.android.gms.maps.model.Polygon;
import com.google.android.gms.maps.model.Polyline;
import com.google.android.gms.maps.model.TileOverlay;
import com.google.maps.android.collections.CircleManager;
import com.google.maps.android.collections.GroundOverlayManager;
import com.google.maps.android.collections.MarkerManager;
import com.google.maps.android.collections.PolygonManager;
import com.google.maps.android.collections.PolylineManager;
import com.google.maps.android.data.kml.KmlContainer;
import com.google.maps.android.data.kml.KmlLayer;
import com.google.maps.android.data.kml.KmlPlacemark;
import com.google.maps.android.data.kml.KmlStyle;

import org.xmlpull.v1.XmlPullParserException;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;

public class MapView extends com.google.android.gms.maps.MapView implements GoogleMap.InfoWindowAdapter,
GoogleMap.OnMarkerDragListener, OnMapReadyCallback, GoogleMap.OnPoiClickListener, GoogleMap.OnIndoorStateChangeListener {
public GoogleMap map;
private MarkerManager markerManager;
private MarkerManager.Collection markerCollection;
private PolylineManager polylineManager;
private PolylineManager.Collection polylineCollection;
private PolygonManager polygonManager;
private PolygonManager.Collection polygonCollection;
private CircleManager.Collection circleCollection;
private GroundOverlayManager groundOverlayManager;
private GroundOverlayManager.Collection groundOverlayCollection;
private ProgressBar mapLoadingProgressBar;
private RelativeLayout mapLoadingLayout;
private ImageView cacheImageView;
private Boolean isMapLoaded = false;
private Integer loadingBackgroundColor = null;
private Integer loadingIndicatorColor = null;

private LatLngBounds boundsToMove;
private CameraUpdate cameraToSet;
private boolean setPaddingDeferred = false;
private boolean showUserLocation = false;
private boolean handlePanDrag = false;
private boolean moveOnMarkerPress = true;
private boolean cacheEnabled = false;
private boolean poiClickEnabled = true;

private ReadableMap initialRegion;
private ReadableMap region;
private ReadableMap initialCamera;
private ReadableMap camera;
private String customMapStyleString;
private boolean initialRegionSet = false;
private boolean initialCameraSet = false;
private LatLngBounds cameraLastIdleBounds;
private int cameraMoveReason = 0;
private MapMarker selectedMarker;

private static final String[] PERMISSIONS = new String[]{
"android.permission.ACCESS_FINE_LOCATION", "android.permission.ACCESS_COARSE_LOCATION"};

private final List<MapFeature> features = new ArrayList<>();
private final Map<Marker, MapMarker> markerMap = new HashMap<>();
private final Map<Polyline, MapPolyline> polylineMap = new HashMap<>();
private final Map<Polygon, MapPolygon> polygonMap = new HashMap<>();
private final Map<GroundOverlay, MapOverlay> overlayMap = new HashMap<>();
private final Map<TileOverlay, MapHeatmap> heatmapMap = new HashMap<>();
private final Map<TileOverlay, MapGradientPolyline> gradientPolylineMap = new HashMap<>();
private final GestureDetectorCompat gestureDetector;
private final MapManager manager;
private LifecycleEventListener lifecycleListener;
private boolean paused = false;
private boolean destroyed = false;
private final ThemedReactContext context;
private final EventDispatcher eventDispatcher;
private final FusedLocationSource fusedLocationSource;

private final ViewAttacherGroup attacherGroup;
private LatLng tapLocation;

private static boolean contextHasBug(Context context) {
return context == null ||
context.getResources() == null ||
context.getResources().getConfiguration() == null;
}

// We do this to fix this bug:
// https://github.com/react-native-maps/react-native-maps/issues/271
//
// which conflicts with another bug regarding the passed in context:
// https://github.com/react-native-maps/react-native-maps/issues/1147
//
// Doing this allows us to avoid both bugs.
private static Context getNonBuggyContext(ThemedReactContext reactContext,
ReactApplicationContext appContext) {
Context superContext = reactContext;
if (!contextHasBug(appContext.getCurrentActivity())) {
superContext = appContext.getCurrentActivity();
} else if (contextHasBug(superContext)) {
// we have the bug! let's try to find a better context to use
if (!contextHasBug(reactContext.getCurrentActivity())) {
superContext = reactContext.getCurrentActivity();
} else if (!contextHasBug(reactContext.getApplicationContext())) {
superContext = reactContext.getApplicationContext();
}

    }
    return superContext;

}

public MapView(ThemedReactContext reactContext, ReactApplicationContext appContext,
MapManager manager,
GoogleMapOptions googleMapOptions) {
super(getNonBuggyContext(reactContext, appContext), googleMapOptions);

    this.manager = manager;
    this.context = reactContext;
    MapsInitializer.initialize(context, this.manager.renderer, renderer -> Log.d("AirMapRenderer", renderer.toString()));
    super.onCreate(null);
    super.onResume();
    super.getMapAsync(this);

    final MapView view = this;

    fusedLocationSource = new FusedLocationSource(context);

    gestureDetector =
        new GestureDetectorCompat(reactContext, new GestureDetector.SimpleOnGestureListener() {

          @Override
          public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,
              float distanceY) {
            if (handlePanDrag) {
              onPanDrag(e2);
            }
            return false;
          }

          @Override
          public boolean onDoubleTap(MotionEvent ev) {
            onDoublePress(ev);
            return false;
          }
        });

    this.addOnLayoutChangeListener(new OnLayoutChangeListener() {
      @Override public void onLayoutChange(View v, int left, int top, int right, int bottom,
          int oldLeft, int oldTop, int oldRight, int oldBottom) {
        if (!paused) {
          MapView.this.cacheView();
        }
      }
    });

    int uiManagerType = UIManagerType.DEFAULT;
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      uiManagerType = UIManagerType.FABRIC;
    }

    eventDispatcher = UIManagerHelper
      .getUIManager(reactContext, uiManagerType)
      .getEventDispatcher();

    // Set up a parent view for triggering visibility in subviews that depend on it.
    // Mainly ReactImageView depends on Fresco which depends on onVisibilityChanged() event
    attacherGroup = new ViewAttacherGroup(context);
    LayoutParams attacherLayoutParams = new LayoutParams(0, 0);
    attacherLayoutParams.width = 0;
    attacherLayoutParams.height = 0;
    attacherLayoutParams.leftMargin = 99999999;
    attacherLayoutParams.topMargin = 99999999;
    attacherGroup.setLayoutParams(attacherLayoutParams);
    addView(attacherGroup);

}

@Override
public void onMapReady(@NonNull final GoogleMap map) {
if (destroyed) {
return;
}
this.map = map;

    markerManager = new MarkerManager(map);
    markerCollection = markerManager.newCollection();
    polylineManager = new PolylineManager(map);
    polylineCollection = polylineManager.newCollection();
    polygonManager = new PolygonManager(map);
    polygonCollection = polygonManager.newCollection();
    CircleManager circleManager = new CircleManager(map);
    circleCollection = circleManager.newCollection();
    groundOverlayManager = new GroundOverlayManager(map);
    groundOverlayCollection = groundOverlayManager.newCollection();

    markerCollection.setInfoWindowAdapter(this);
    markerCollection.setOnMarkerDragListener(this);
    this.map.setOnIndoorStateChangeListener(this);

    applyBridgedProps();

    manager.pushEvent(context, this, "onMapReady", new WritableNativeMap());

    final MapView view = this;

    map.setOnMyLocationChangeListener(new GoogleMap.OnMyLocationChangeListener() {
      @Override
      public void onMyLocationChange(Location location){
        WritableMap event = new WritableNativeMap();

        WritableMap coordinate = new WritableNativeMap();
        coordinate.putDouble("latitude", location.getLatitude());
        coordinate.putDouble("longitude", location.getLongitude());
        coordinate.putDouble("altitude", location.getAltitude());
        coordinate.putDouble("timestamp", location.getTime());
        coordinate.putDouble("accuracy", location.getAccuracy());
        coordinate.putDouble("speed", location.getSpeed());
        coordinate.putDouble("heading", location.getBearing());
        coordinate.putBoolean("isFromMockProvider", location.isFromMockProvider());

        event.putMap("coordinate", coordinate);

        manager.pushEvent(context, view, "onUserLocationChange", event);
      }
    });

    markerCollection.setOnMarkerClickListener(new GoogleMap.OnMarkerClickListener() {
      @Override
      public boolean onMarkerClick(@NonNull Marker marker) {
        MapMarker airMapMarker = getMarkerMap(marker);

        WritableMap event = makeClickEventData(marker.getPosition());
        event.putString("action", "marker-press");
        event.putString("id", airMapMarker.getIdentifier());
        manager.pushEvent(context, view, "onMarkerPress", event);

        event = makeClickEventData(marker.getPosition());
        event.putString("action", "marker-press");
        event.putString("id", airMapMarker.getIdentifier());
        manager.pushEvent(context, airMapMarker, "onPress", event);

        handleMarkerSelection(airMapMarker);

        // Return false to open the callout info window and center on the marker
        // https://developers.google.com/android/reference/com/google/android/gms/maps/GoogleMap
        // .OnMarkerClickListener
        if (view.moveOnMarkerPress) {
          return false;
        } else {
          marker.showInfoWindow();
          return true;
        }
      }
    });

    polygonCollection.setOnPolygonClickListener(new GoogleMap.OnPolygonClickListener() {
      @Override
      public void onPolygonClick(@NonNull Polygon polygon) {
        WritableMap event = makeClickEventData(tapLocation);
        event.putString("action", "polygon-press");
        manager.pushEvent(context, polygonMap.get(polygon), "onPress", event);
      }
    });

    polylineCollection.setOnPolylineClickListener(new GoogleMap.OnPolylineClickListener() {
      @Override
      public void onPolylineClick(@NonNull Polyline polyline) {
        WritableMap event = makeClickEventData(tapLocation);
        event.putString("action", "polyline-press");
        manager.pushEvent(context, polylineMap.get(polyline), "onPress", event);
      }
    });

    markerCollection.setOnInfoWindowClickListener(new GoogleMap.OnInfoWindowClickListener() {
      @Override
      public void onInfoWindowClick(@NonNull Marker marker) {
        WritableMap event = makeClickEventData(marker.getPosition());
        event.putString("action", "callout-press");
        manager.pushEvent(context, view, "onCalloutPress", event);

        event = makeClickEventData(marker.getPosition());
        event.putString("action", "callout-press");
        MapMarker markerView = getMarkerMap(marker);
        manager.pushEvent(context, markerView, "onCalloutPress", event);

        event = makeClickEventData(marker.getPosition());
        event.putString("action", "callout-press");
        MapCallout infoWindow = markerView.getCalloutView();
        if (infoWindow != null) manager.pushEvent(context, infoWindow, "onPress", event);
      }
    });

    map.setOnMapClickListener(new GoogleMap.OnMapClickListener() {
      @Override
      public void onMapClick(@NonNull LatLng point) {
        WritableMap event = makeClickEventData(point);
        event.putString("action", "press");
        manager.pushEvent(context, view, "onPress", event);

        handleMarkerSelection(null);
      }
    });

    map.setOnMapLongClickListener(new GoogleMap.OnMapLongClickListener() {
      @Override
      public void onMapLongClick(@NonNull LatLng point) {
        WritableMap event = makeClickEventData(point);
        event.putString("action", "long-press");
        manager.pushEvent(context, view, "onLongPress", makeClickEventData(point));
      }
    });

    groundOverlayCollection.setOnGroundOverlayClickListener(new GoogleMap.OnGroundOverlayClickListener() {
      @Override
      public void onGroundOverlayClick(@NonNull GroundOverlay groundOverlay) {
        WritableMap event = makeClickEventData(groundOverlay.getPosition());
        event.putString("action", "overlay-press");
        manager.pushEvent(context, overlayMap.get(groundOverlay), "onPress", event);
      }
    });

    map.setOnCameraMoveStartedListener(new GoogleMap.OnCameraMoveStartedListener() {
      @Override
      public void onCameraMoveStarted(int reason) {
        cameraMoveReason = reason;
        boolean isGesture = GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE == reason;
        WritableMap event = new WritableNativeMap();
        event.putBoolean("isGesture", isGesture);
        manager.pushEvent(context, view, "onRegionChangeStart", event);
      }
    });

    map.setOnCameraMoveListener(new GoogleMap.OnCameraMoveListener() {
      @Override
      public void onCameraMove() {
        LatLngBounds bounds = map.getProjection().getVisibleRegion().latLngBounds;

        cameraLastIdleBounds = null;
        boolean isGesture = GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE == cameraMoveReason;

        RegionChangeEvent event = new RegionChangeEvent(getId(), bounds, true, isGesture);
        eventDispatcher.dispatchEvent(event);
      }
    });

    map.setOnCameraIdleListener(new GoogleMap.OnCameraIdleListener() {
      @Override
      public void onCameraIdle() {
        LatLngBounds bounds = map.getProjection().getVisibleRegion().latLngBounds;
        if ((cameraMoveReason != 0) &&
          ((cameraLastIdleBounds == null) ||
            LatLngBoundsUtils.BoundsAreDifferent(bounds, cameraLastIdleBounds))) {

          cameraLastIdleBounds = bounds;
          boolean isGesture = GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE == cameraMoveReason;

          RegionChangeEvent event = new RegionChangeEvent(getId(), bounds, false, isGesture);
          eventDispatcher.dispatchEvent(event);
        }
      }
    });

    map.setOnMapLoadedCallback(new GoogleMap.OnMapLoadedCallback() {
      @Override public void onMapLoaded() {
        isMapLoaded = true;
        manager.pushEvent(context, view, "onMapLoaded", new WritableNativeMap());
        MapView.this.cacheView();
      }
    });

    // We need to be sure to disable location-tracking when app enters background, in-case some
    // other module
    // has acquired a wake-lock and is controlling location-updates, otherwise, location-manager
    // will be left
    // updating location constantly, killing the battery, even though some other location-mgmt
    // module may
    // desire to shut-down location-services.
    lifecycleListener = new LifecycleEventListener() {
      @Override
      public void onHostResume() {
        if (hasPermissions() && map != null) {
          //noinspection MissingPermission
          map.setMyLocationEnabled(showUserLocation);
          map.setLocationSource(fusedLocationSource);
        }
        synchronized (MapView.this) {
          if (!destroyed) {
            MapView.this.onResume();
          }
          paused = false;
        }
      }

      @Override
      public void onHostPause() {
        if (hasPermissions() && map != null) {
          //noinspection MissingPermission
          map.setMyLocationEnabled(false);
        }
        synchronized (MapView.this) {
          if (!destroyed) {
            MapView.this.onPause();
          }
          paused = true;
        }
      }

      @Override
      public void onHostDestroy() {
        MapView.this.doDestroy();
      }
    };

    context.addLifecycleEventListener(lifecycleListener);

}

private synchronized void handleMarkerSelection(MapMarker target) {
if (selectedMarker == target) {
return;
}

    WritableMap event;

    if (selectedMarker != null) {
      event = makeClickEventData(selectedMarker.getPosition());
      event.putString("action", "marker-deselect");
      event.putString("id", selectedMarker.getIdentifier());
      manager.pushEvent(context, selectedMarker, "onDeselect", event);

      event = makeClickEventData(selectedMarker.getPosition());
      event.putString("action", "marker-deselect");
      event.putString("id", selectedMarker.getIdentifier());
      manager.pushEvent(context, this, "onMarkerDeselect", event);
    }

    if (target != null) {
      event = makeClickEventData(target.getPosition());
      event.putString("action", "marker-select");
      event.putString("id", target.getIdentifier());
      manager.pushEvent(context, target, "onSelect", event);

      event = makeClickEventData(target.getPosition());
      event.putString("action", "marker-select");
      event.putString("id", target.getIdentifier());
      manager.pushEvent(context, this, "onMarkerSelect", event);
    }

     selectedMarker = target;

}

private boolean hasPermissions() {
return checkSelfPermission(getContext(), PERMISSIONS[0]) == PermissionChecker.PERMISSION_GRANTED ||
checkSelfPermission(getContext(), PERMISSIONS[1]) == PermissionChecker.PERMISSION_GRANTED;
}

/_
onDestroy is final method so I can't override it.
_/
public synchronized void doDestroy() {
if (destroyed) {
return;
}
destroyed = true;

    if (lifecycleListener != null && context != null) {
      context.removeLifecycleEventListener(lifecycleListener);
      lifecycleListener = null;
    }
    if (!paused) {
      onPause();
      paused = true;
    }
    onDestroy();

}

public void setInitialRegion(ReadableMap initialRegion) {
this.initialRegion = initialRegion;
// Theoretically onMapReady might be called before setInitialRegion
// In that case, trigger moveToRegion manually
if (!initialRegionSet && map != null) {
moveToRegion(initialRegion);
initialRegionSet = true;
}
}

public void setInitialCamera(ReadableMap initialCamera) {
this.initialCamera = initialCamera;
if (!initialCameraSet && map != null) {
moveToCamera(initialCamera);
initialCameraSet = true;
}
}

private void applyBridgedProps() {
if(initialRegion != null) {
moveToRegion(initialRegion);
initialRegionSet = true;
} else if(region != null) {
moveToRegion(region);
} else if (initialCamera != null) {
moveToCamera(initialCamera);
initialCameraSet = true;
} else if (camera != null) {
moveToCamera(camera);
}
if(customMapStyleString != null) {
map.setMapStyle(new MapStyleOptions(customMapStyleString));
}
this.setPoiClickEnabled(poiClickEnabled);
}

private void moveToRegion(ReadableMap region) {
if (region == null) return;

    double lng = region.getDouble("longitude");
    double lat = region.getDouble("latitude");
    double lngDelta = region.getDouble("longitudeDelta");
    double latDelta = region.getDouble("latitudeDelta");
    LatLngBounds bounds = new LatLngBounds(
            new LatLng(lat - latDelta / 2, lng - lngDelta / 2), // southwest
            new LatLng(lat + latDelta / 2, lng + lngDelta / 2)  // northeast
    );
    if (super.getHeight() <= 0 || super.getWidth() <= 0) {
      // in this case, our map has not been laid out yet, so we save the bounds in a local
      // variable, and make a guess of zoomLevel 10. Not to worry, though: as soon as layout
      // occurs, we will move the camera to the saved bounds. Note that if we tried to move
      // to the bounds now, it would trigger an exception.
      map.moveCamera(CameraUpdateFactory.newLatLngZoom(new LatLng(lat, lng), 10));
      boundsToMove = bounds;
    } else {
      map.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 0));
      boundsToMove = null;
    }

}

public void setRegion(ReadableMap region) {
this.region = region;
if(region != null && map != null) {
moveToRegion(region);
}
}

public void setCamera(ReadableMap camera) {
this.camera = camera;
if(camera != null && map != null) {
moveToCamera(camera);
}
}
public static CameraPosition cameraPositionFromMap(ReadableMap camera){
if (camera == null) return null;

CameraPosition.Builder builder = new CameraPosition.Builder();

ReadableMap center = camera.getMap("center");
if (center != null) {
double lng = center.getDouble("longitude");
double lat = center.getDouble("latitude");
builder.target(new LatLng(lat, lng));
}

builder.tilt((float)camera.getDouble("pitch"));
builder.bearing((float)camera.getDouble("heading"));
builder.zoom((float)camera.getDouble("zoom"));

return builder.build();
}
public void moveToCamera(ReadableMap cameraMap) {
CameraPosition camera = cameraPositionFromMap(cameraMap);
if (camera == null) return;
CameraUpdate update = CameraUpdateFactory.newCameraPosition(camera);

    if (super.getHeight() <= 0 || super.getWidth() <= 0) {
      // in this case, our map has not been laid out yet, so we save the camera update in a
      // local variable. As soon as layout occurs, we will move the camera to the saved update.
      // Note that if we tried to move to the camera now, it would trigger an exception.
      cameraToSet = update;
    } else {
      map.moveCamera(update);
      cameraToSet = null;
    }

}

public void setMapStyle(@Nullable String customMapStyleString) {
this.customMapStyleString = customMapStyleString;
if(map != null && customMapStyleString != null) {
map.setMapStyle(new MapStyleOptions(customMapStyleString));
}
}

public void setShowsUserLocation(boolean showUserLocation) {
this.showUserLocation = showUserLocation; // hold onto this for lifecycle handling
if (hasPermissions()) {
map.setLocationSource(fusedLocationSource);
//noinspection MissingPermission
map.setMyLocationEnabled(showUserLocation);
}
}

public void setUserLocationPriority(int priority){
fusedLocationSource.setPriority(priority);
}

public void setUserLocationUpdateInterval(int interval){
fusedLocationSource.setInterval(interval);
}

public void setUserLocationFastestInterval(int interval){
fusedLocationSource.setFastestInterval(interval);
}

public void setShowsMyLocationButton(boolean showMyLocationButton) {
if (hasPermissions() || !showMyLocationButton) {
map.getUiSettings().setMyLocationButtonEnabled(showMyLocationButton);
}
}

public void setToolbarEnabled(boolean toolbarEnabled) {
if (hasPermissions() || !toolbarEnabled) {
map.getUiSettings().setMapToolbarEnabled(toolbarEnabled);
}
}

public void setCacheEnabled(boolean cacheEnabled) {
this.cacheEnabled = cacheEnabled;
this.cacheView();
}

public void setPoiClickEnabled(boolean poiClickEnabled) {
this.poiClickEnabled = poiClickEnabled;
map.setOnPoiClickListener(poiClickEnabled ? this : null);
}

public void enableMapLoading(boolean loadingEnabled) {
if (loadingEnabled && !this.isMapLoaded) {
this.getMapLoadingLayoutView().setVisibility(View.VISIBLE);
}
}

public void setMoveOnMarkerPress(boolean moveOnPress) {
this.moveOnMarkerPress = moveOnPress;
}

public void setLoadingBackgroundColor(Integer loadingBackgroundColor) {
this.loadingBackgroundColor = loadingBackgroundColor;

    if (this.mapLoadingLayout != null) {
      if (loadingBackgroundColor == null) {
        this.mapLoadingLayout.setBackgroundColor(Color.WHITE);
      } else {
        this.mapLoadingLayout.setBackgroundColor(this.loadingBackgroundColor);
      }
    }

}

public void setLoadingIndicatorColor(Integer loadingIndicatorColor) {
this.loadingIndicatorColor = loadingIndicatorColor;
if (this.mapLoadingProgressBar != null) {
Integer color = loadingIndicatorColor;
if (color == null) {
color = Color.parseColor("#606060");
}

      ColorStateList progressTintList = ColorStateList.valueOf(loadingIndicatorColor);
      ColorStateList secondaryProgressTintList = ColorStateList.valueOf(loadingIndicatorColor);
      ColorStateList indeterminateTintList = ColorStateList.valueOf(loadingIndicatorColor);

      this.mapLoadingProgressBar.setProgressTintList(progressTintList);
      this.mapLoadingProgressBar.setSecondaryProgressTintList(secondaryProgressTintList);
      this.mapLoadingProgressBar.setIndeterminateTintList(indeterminateTintList);
    }

}

public void setHandlePanDrag(boolean handlePanDrag) {
this.handlePanDrag = handlePanDrag;
}

public void addFeature(View child, int index) {
// Our desired API is to pass up annotations/overlays as children to the mapview component.
// This is where we intercept them and do the appropriate underlying mapview action.
if (child instanceof MapMarker) {
MapMarker annotation = (MapMarker) child;
annotation.addToMap(markerCollection);
features.add(index, annotation);

      // Allow visibility event to be triggered later
      int visibility = annotation.getVisibility();
      annotation.setVisibility(INVISIBLE);

      // Remove from a view group if already present, prevent "specified child
      // already had a parent" error.
      ViewGroup annotationParent = (ViewGroup)annotation.getParent();
      if (annotationParent != null) {
        annotationParent.removeView(annotation);
      }

      // Add to the parent group
      attacherGroup.addView(annotation);

      // Trigger visibility event if necessary.
      // With some testing, seems like it is not always
      //   triggered just by being added to a parent view.
      annotation.setVisibility(visibility);

      Marker marker = (Marker) annotation.getFeature();
      markerMap.put(marker, annotation);
    } else if (child instanceof MapPolyline) {
      MapPolyline polylineView = (MapPolyline) child;
      polylineView.addToMap(polylineCollection);
      features.add(index, polylineView);
      Polyline polyline = (Polyline) polylineView.getFeature();
      polylineMap.put(polyline, polylineView);
    } else if (child instanceof MapGradientPolyline) {
      MapGradientPolyline polylineView = (MapGradientPolyline) child;
      polylineView.addToMap(map);
      features.add(index, polylineView);
      TileOverlay tileOverlay = (TileOverlay) polylineView.getFeature();
      gradientPolylineMap.put(tileOverlay, polylineView);
    } else if (child instanceof MapPolygon) {
      MapPolygon polygonView = (MapPolygon) child;
      polygonView.addToMap(polygonCollection);
      features.add(index, polygonView);
      Polygon polygon = (Polygon) polygonView.getFeature();
      polygonMap.put(polygon, polygonView);
    } else if (child instanceof MapCircle) {
      MapCircle circleView = (MapCircle) child;
      circleView.addToMap(circleCollection);
      features.add(index, circleView);
    } else if (child instanceof MapUrlTile) {
      MapUrlTile urlTileView = (MapUrlTile) child;
      urlTileView.addToMap(map);
      features.add(index, urlTileView);
    } else if (child instanceof MapWMSTile) {
      MapWMSTile urlTileView = (MapWMSTile) child;
      urlTileView.addToMap(map);
      features.add(index, urlTileView);
    } else if (child instanceof MapLocalTile) {
      MapLocalTile localTileView = (MapLocalTile) child;
      localTileView.addToMap(map);
      features.add(index, localTileView);
    } else if (child instanceof MapOverlay) {
      MapOverlay overlayView = (MapOverlay) child;
      overlayView.addToMap(groundOverlayCollection);
      features.add(index, overlayView);
      GroundOverlay overlay = (GroundOverlay) overlayView.getFeature();
      overlayMap.put(overlay, overlayView);
    } else if (child instanceof MapHeatmap) {
      MapHeatmap heatmapView = (MapHeatmap) child;
      heatmapView.addToMap(map);
      features.add(index, heatmapView);
      TileOverlay heatmap = (TileOverlay)heatmapView.getFeature();
      heatmapMap.put(heatmap, heatmapView);
    } else if (child instanceof ViewGroup) {
      ViewGroup children = (ViewGroup) child;
      for (int i = 0; i < children.getChildCount(); i++) {
        addFeature(children.getChildAt(i), index);
      }
    } else {
      addView(child, index);
    }

}

public int getFeatureCount() {
return features.size();
}

public View getFeatureAt(int index) {
return features.get(index);
}

public void removeFeatureAt(int index) {
MapFeature feature = features.remove(index);
if (feature instanceof MapMarker) {
markerMap.remove(feature.getFeature());
feature.removeFromMap(markerCollection);
attacherGroup.removeView(feature);
} else if (feature instanceof MapHeatmap) {
heatmapMap.remove(feature.getFeature());
feature.removeFromMap(map);
} else if(feature instanceof MapCircle) {
feature.removeFromMap(circleCollection);
} else if(feature instanceof MapOverlay) {
feature.removeFromMap(groundOverlayCollection);
} else if(feature instanceof MapPolygon) {
feature.removeFromMap(polygonCollection);
} else if(feature instanceof MapPolyline) {
feature.removeFromMap(polylineCollection);
} else {
feature.removeFromMap(map);
}
}

public WritableMap makeClickEventData(LatLng point) {
WritableMap event = new WritableNativeMap();

    WritableMap coordinate = new WritableNativeMap();
    coordinate.putDouble("latitude", point.latitude);
    coordinate.putDouble("longitude", point.longitude);
    event.putMap("coordinate", coordinate);

    Projection projection = map.getProjection();
    Point screenPoint = projection.toScreenLocation(point);

    WritableMap position = new WritableNativeMap();
    position.putDouble("x", screenPoint.x);
    position.putDouble("y", screenPoint.y);
    event.putMap("position", position);

    return event;

}

public void updateExtraData(Object extraData) {
if (setPaddingDeferred && super.getHeight() > 0 && super.getWidth() > 0) {
CameraUpdate cu = CameraUpdateFactory.newCameraPosition(map.getCameraPosition());

      map.setPadding(edgeLeftPadding + baseLeftMapPadding,
          edgeTopPadding + baseTopMapPadding,
          edgeRightPadding + baseRightMapPadding,
          edgeBottomPadding + baseBottomMapPadding);
      map.moveCamera(cu);

      // Move the google logo to the default base padding value.
      map.setPadding(baseLeftMapPadding, baseTopMapPadding, baseRightMapPadding, baseBottomMapPadding);

      setPaddingDeferred = false;
    }

    // if boundsToMove is not null, we now have the MapView's width/height, so we can apply
    // a proper camera move
    if (boundsToMove != null) {
      HashMap<String, Float> data = (HashMap<String, Float>) extraData;
      int width = data.get("width") == null ? 0 : data.get("width").intValue();
      int height = data.get("height") == null ? 0 : data.get("height").intValue();

      //fix for https://github.com/react-native-maps/react-native-maps/issues/245,
      //it's not guaranteed the passed-in height and width would be greater than 0.
      if (width <= 0 || height <= 0) {
        map.moveCamera(CameraUpdateFactory.newLatLngBounds(boundsToMove, 0));
      } else {
        map.moveCamera(CameraUpdateFactory.newLatLngBounds(boundsToMove, width, height, 0));
      }

      boundsToMove = null;
      cameraToSet = null;
    }
    else if (cameraToSet != null) {
      map.moveCamera(cameraToSet);
      cameraToSet = null;
    }

}

public void animateToCamera(ReadableMap camera, int duration) {
if (map == null) return;
CameraPosition.Builder builder = new CameraPosition.Builder(map.getCameraPosition());
if (camera.hasKey("zoom")) {
builder.zoom((float)camera.getDouble("zoom"));
}
if (camera.hasKey("heading")) {
builder.bearing((float)camera.getDouble("heading"));
}
if (camera.hasKey("pitch")) {
builder.tilt((float)camera.getDouble("pitch"));
}
if (camera.hasKey("center")) {
ReadableMap center = camera.getMap("center");
builder.target(new LatLng(center.getDouble("latitude"), center.getDouble("longitude")));
}

    CameraUpdate update = CameraUpdateFactory.newCameraPosition(builder.build());

    if (duration <= 0) {
      map.moveCamera(update);
    }
    else {
      map.animateCamera(update, duration, null);
    }

}

public void animateToRegion(LatLngBounds bounds, int duration) {
if (map == null) return;
if(duration <= 0) {
map.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 0));
} else {
map.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, 0), duration, null);
}
}

public void fitToElements(ReadableMap edgePadding, boolean animated) {
if (map == null) return;

    LatLngBounds.Builder builder = new LatLngBounds.Builder();

    boolean addedPosition = false;

    for (MapFeature feature : features) {
      if (feature instanceof MapMarker) {
        Marker marker = (Marker) feature.getFeature();
        builder.include(marker.getPosition());
        addedPosition = true;
      }
      // TODO(lmr): may want to include shapes / etc.
    }
    if (addedPosition) {
      LatLngBounds bounds = builder.build();
      CameraUpdate cu = CameraUpdateFactory.newLatLngBounds(bounds, 0);

      if (edgePadding != null) {
        appendMapPadding(edgePadding.getInt("left"), edgePadding.getInt("top"),
          edgePadding.getInt("right"), edgePadding.getInt("bottom"));
      }

      if (animated) {
        map.animateCamera(cu);
      } else {
        map.moveCamera(cu);
      }
      // Move the google logo to the default base padding value.
      map.setPadding(baseLeftMapPadding, baseTopMapPadding, baseRightMapPadding, baseBottomMapPadding);
    }

}

public void fitToSuppliedMarkers(ReadableArray markerIDsArray, ReadableMap edgePadding, boolean animated) {
if (map == null) return;

    LatLngBounds.Builder builder = new LatLngBounds.Builder();

    String[] markerIDs = new String[markerIDsArray.size()];
    for (int i = 0; i < markerIDsArray.size(); i++) {
      markerIDs[i] = markerIDsArray.getString(i);
    }

    boolean addedPosition = false;

    List<String> markerIDList = Arrays.asList(markerIDs);

    for (MapFeature feature : features) {
      if (feature instanceof MapMarker) {
        String identifier = ((MapMarker) feature).getIdentifier();
        Marker marker = (Marker) feature.getFeature();
        if (markerIDList.contains(identifier)) {
          builder.include(marker.getPosition());
          addedPosition = true;
        }
      }
    }

    if (addedPosition) {
      LatLngBounds bounds = builder.build();
      CameraUpdate cu = CameraUpdateFactory.newLatLngBounds(bounds, 0);

      if (edgePadding != null) {
        appendMapPadding(edgePadding.getInt("left"), edgePadding.getInt("top"),
          edgePadding.getInt("right"), edgePadding.getInt("bottom"));
      }

      if (animated) {
        map.animateCamera(cu);
      } else {
        map.moveCamera(cu);
      }
      // Move the google logo to the default base padding value.
      map.setPadding(baseLeftMapPadding, baseTopMapPadding, baseRightMapPadding, baseBottomMapPadding);
    }

}

// padding configured by 'mapPadding' property
int baseLeftMapPadding;
int baseRightMapPadding;
int baseTopMapPadding;
int baseBottomMapPadding;
// extra padding specified by 'edgePadding' option of fitToElements/fitToSuppliedMarkers/fitToCoordinates
int edgeLeftPadding;
int edgeRightPadding;
int edgeTopPadding;
int edgeBottomPadding;

public void applyBaseMapPadding(int left, int top, int right, int bottom){
if (super.getHeight() <= 0 || super.getWidth() <= 0) {
// the map is not laid out yet and calling setPadding() now has no effect
baseLeftMapPadding = left;
baseRightMapPadding = right;
baseTopMapPadding = top;
baseBottomMapPadding = bottom;
setPaddingDeferred = true;
return;
}

    // retrieve current camera with current edge paddings configured
    map.setPadding(edgeLeftPadding + baseLeftMapPadding,
        edgeTopPadding + baseTopMapPadding,
        edgeRightPadding + baseRightMapPadding,
        edgeBottomPadding + baseBottomMapPadding);
    CameraUpdate cu = CameraUpdateFactory.newCameraPosition(map.getCameraPosition());

    baseLeftMapPadding = left;
    baseRightMapPadding = right;
    baseTopMapPadding = top;
    baseBottomMapPadding = bottom;

    // apply base paddings and restore center position of the map
    map.setPadding(edgeLeftPadding + left,
        edgeTopPadding + top,
        edgeRightPadding + right,
        edgeBottomPadding + bottom);
    map.moveCamera(cu);

    // Move the google logo to the default base padding value.
    map.setPadding(left, top, right, bottom);

}

public void fitToCoordinates(ReadableArray coordinatesArray, ReadableMap edgePadding,
boolean animated) {
if (map == null) return;

    LatLngBounds.Builder builder = new LatLngBounds.Builder();

    for (int i = 0; i < coordinatesArray.size(); i++) {
      ReadableMap latLng = coordinatesArray.getMap(i);
      double lat = latLng.getDouble("latitude");
      double lng = latLng.getDouble("longitude");
      builder.include(new LatLng(lat, lng));
    }

    LatLngBounds bounds = builder.build();
    CameraUpdate cu = CameraUpdateFactory.newLatLngBounds(bounds, 0);

    if (edgePadding != null) {
      appendMapPadding(edgePadding.getInt("left"), edgePadding.getInt("top"), edgePadding.getInt("right"), edgePadding.getInt("bottom"));
    }

    if (animated) {
      map.animateCamera(cu);
    } else {
      map.moveCamera(cu);
    }
    // Move the google logo to the default base padding value.
    map.setPadding(baseLeftMapPadding, baseTopMapPadding, baseRightMapPadding, baseBottomMapPadding);

}

private void appendMapPadding(int iLeft,int iTop, int iRight, int iBottom) {
double density = getResources().getDisplayMetrics().density;

    edgeLeftPadding = (int) (iLeft * density);
    edgeTopPadding = (int) (iTop * density);
    edgeRightPadding = (int) (iRight * density);
    edgeBottomPadding = (int) (iBottom * density);

    map.setPadding(edgeLeftPadding + baseLeftMapPadding,
            edgeTopPadding + baseTopMapPadding,
            edgeRightPadding + baseRightMapPadding,
            edgeBottomPadding + baseBottomMapPadding);

}

public double[][] getMapBoundaries() {
LatLngBounds bounds = map.getProjection().getVisibleRegion().latLngBounds;
LatLng northEast = bounds.northeast;
LatLng southWest = bounds.southwest;

    return new double[][] {
      {northEast.longitude, northEast.latitude},
      {southWest.longitude, southWest.latitude}
    };

}

public void setMapBoundaries(ReadableMap northEast, ReadableMap southWest) {
if (map == null) return;

    LatLngBounds.Builder builder = new LatLngBounds.Builder();

    double latNE = northEast.getDouble("latitude");
    double lngNE = northEast.getDouble("longitude");
    builder.include(new LatLng(latNE, lngNE));

    double latSW = southWest.getDouble("latitude");
    double lngSW = southWest.getDouble("longitude");
    builder.include(new LatLng(latSW, lngSW));

    LatLngBounds bounds = builder.build();

    map.setLatLngBoundsForCameraTarget(bounds);

}

// InfoWindowAdapter interface

@Override
public View getInfoWindow(Marker marker) {
MapMarker markerView = getMarkerMap(marker);
return markerView.getCallout();
}

@Override
public View getInfoContents(Marker marker) {
MapMarker markerView = getMarkerMap(marker);
return markerView.getInfoContents();
}

@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
gestureDetector.onTouchEvent(ev);

    int X = (int)ev.getX();
    int Y = (int)ev.getY();
    if(map != null) {
      tapLocation = map.getProjection().fromScreenLocation(new Point(X,Y));
    }

    int action = MotionEventCompat.getActionMasked(ev);

    switch (action) {
      case (MotionEvent.ACTION_DOWN):
        this.getParent().requestDisallowInterceptTouchEvent(
            map != null && map.getUiSettings().isScrollGesturesEnabled());
        break;
      case (MotionEvent.ACTION_UP):
        // Clear this regardless, since isScrollGesturesEnabled() may have been updated
        this.getParent().requestDisallowInterceptTouchEvent(false);
        break;
    }
    super.dispatchTouchEvent(ev);
    return true;

}

@Override
public void onMarkerDragStart(Marker marker) {
WritableMap event = makeClickEventData(marker.getPosition());
manager.pushEvent(context, this, "onMarkerDragStart", event);

    MapMarker markerView = getMarkerMap(marker);
    event = makeClickEventData(marker.getPosition());
    manager.pushEvent(context, markerView, "onDragStart", event);

}

@Override
public void onMarkerDrag(Marker marker) {
WritableMap event = makeClickEventData(marker.getPosition());
manager.pushEvent(context, this, "onMarkerDrag", event);

    MapMarker markerView = getMarkerMap(marker);
    event = makeClickEventData(marker.getPosition());
    manager.pushEvent(context, markerView, "onDrag", event);

}

@Override
public void onMarkerDragEnd(Marker marker) {
WritableMap event = makeClickEventData(marker.getPosition());
manager.pushEvent(context, this, "onMarkerDragEnd", event);

    MapMarker markerView = getMarkerMap(marker);
    event = makeClickEventData(marker.getPosition());
    manager.pushEvent(context, markerView, "onDragEnd", event);

}

@Override
public void onPoiClick(PointOfInterest poi) {
WritableMap event = makeClickEventData(poi.latLng);

    event.putString("placeId", poi.placeId);
    event.putString("name", poi.name);

    manager.pushEvent(context, this, "onPoiClick", event);

}

private ProgressBar getMapLoadingProgressBar() {
if (this.mapLoadingProgressBar == null) {
this.mapLoadingProgressBar = new ProgressBar(getContext());
this.mapLoadingProgressBar.setIndeterminate(true);
}
if (this.loadingIndicatorColor != null) {
this.setLoadingIndicatorColor(this.loadingIndicatorColor);
}
return this.mapLoadingProgressBar;
}

private RelativeLayout getMapLoadingLayoutView() {
if (this.mapLoadingLayout == null) {
this.mapLoadingLayout = new RelativeLayout(getContext());
this.mapLoadingLayout.setBackgroundColor(Color.LTGRAY);
this.addView(this.mapLoadingLayout,
new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
ViewGroup.LayoutParams.MATCH_PARENT));

      RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(
          RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
      params.addRule(RelativeLayout.CENTER_IN_PARENT);
      this.mapLoadingLayout.addView(this.getMapLoadingProgressBar(), params);

      this.mapLoadingLayout.setVisibility(View.INVISIBLE);
    }
    this.setLoadingBackgroundColor(this.loadingBackgroundColor);
    return this.mapLoadingLayout;

}

private ImageView getCacheImageView() {
if (this.cacheImageView == null) {
this.cacheImageView = new ImageView(getContext());
this.addView(this.cacheImageView,
new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
ViewGroup.LayoutParams.MATCH_PARENT));
this.cacheImageView.setVisibility(View.INVISIBLE);
}
return this.cacheImageView;
}

private void removeCacheImageView() {
if (this.cacheImageView != null) {
((ViewGroup) this.cacheImageView.getParent()).removeView(this.cacheImageView);
this.cacheImageView = null;
}
}

private void removeMapLoadingProgressBar() {
if (this.mapLoadingProgressBar != null) {
((ViewGroup) this.mapLoadingProgressBar.getParent()).removeView(this.mapLoadingProgressBar);
this.mapLoadingProgressBar = null;
}
}

private void removeMapLoadingLayoutView() {
this.removeMapLoadingProgressBar();
if (this.mapLoadingLayout != null) {
((ViewGroup) this.mapLoadingLayout.getParent()).removeView(this.mapLoadingLayout);
this.mapLoadingLayout = null;
}
}

private void cacheView() {
if (this.cacheEnabled) {
final ImageView cacheImageView = this.getCacheImageView();
final RelativeLayout mapLoadingLayout = this.getMapLoadingLayoutView();
cacheImageView.setVisibility(View.INVISIBLE);
mapLoadingLayout.setVisibility(View.VISIBLE);
if (this.isMapLoaded) {
this.map.snapshot(new GoogleMap.SnapshotReadyCallback() {
@Override public void onSnapshotReady(Bitmap bitmap) {
cacheImageView.setImageBitmap(bitmap);
cacheImageView.setVisibility(View.VISIBLE);
mapLoadingLayout.setVisibility(View.INVISIBLE);
}
});
}
} else {
this.removeCacheImageView();
if (this.isMapLoaded) {
this.removeMapLoadingLayoutView();
}
}
}

public void onPanDrag(MotionEvent ev) {
Point point = new Point((int) ev.getX(), (int) ev.getY());
LatLng coords = this.map.getProjection().fromScreenLocation(point);
WritableMap event = makeClickEventData(coords);
manager.pushEvent(context, this, "onPanDrag", event);
}

public void onDoublePress(MotionEvent ev) {
if (this.map == null) return;
Point point = new Point((int) ev.getX(), (int) ev.getY());
LatLng coords = this.map.getProjection().fromScreenLocation(point);
WritableMap event = makeClickEventData(coords);
manager.pushEvent(context, this, "onDoublePress", event);
}

public void setKmlSrc(String kmlSrc) {
try {
InputStream kmlStream = new FileUtil(context).execute(kmlSrc).get();

      if (kmlStream == null) {
        return;
      }

      KmlLayer kmlLayer = new KmlLayer(map, kmlStream, context, markerManager, polygonManager, polylineManager, groundOverlayManager, null);
      kmlLayer.addLayerToMap();

      WritableMap pointers = new WritableNativeMap();
      WritableArray markers = new WritableNativeArray();

      if (kmlLayer.getContainers() == null) {
        manager.pushEvent(context, this, "onKmlReady", pointers);
        return;
      }

      //Retrieve a nested container within the first container
      KmlContainer container = kmlLayer.getContainers().iterator().next();
      if (container == null || container.getContainers() == null) {
        manager.pushEvent(context, this, "onKmlReady", pointers);
        return;
      }


      if (container.getContainers().iterator().hasNext()) {
        container = container.getContainers().iterator().next();
      }

      int index = 0;
      for (KmlPlacemark placemark : container.getPlacemarks()) {
        MarkerOptions options = new MarkerOptions();

        if (placemark.getInlineStyle() != null) {
          options = placemark.getMarkerOptions();
        } else {
          options.icon(BitmapDescriptorFactory.defaultMarker());
        }

        LatLng latLng = ((LatLng) placemark.getGeometry().getGeometryObject());
        String title = "";
        String snippet = "";

        if (placemark.hasProperty("name")) {
          title = placemark.getProperty("name");
        }

        if (placemark.hasProperty("description")) {
          snippet = placemark.getProperty("description");
        }

        options.position(latLng);
        options.title(title);
        options.snippet(snippet);

        MapMarker marker = new MapMarker(context, options, this.manager.getMarkerManager());

        if (placemark.getInlineStyle() != null
            && placemark.getInlineStyle().getIconUrl() != null) {
          marker.setImage(placemark.getInlineStyle().getIconUrl());
        } else if (container.getStyle(placemark.getStyleId()) != null) {
          KmlStyle style = container.getStyle(placemark.getStyleId());
          marker.setImage(style.getIconUrl());
        }

        String identifier = title + " - " + index;

        marker.setIdentifier(identifier);

        addFeature(marker, index++);

        WritableMap loadedMarker = makeClickEventData(latLng);
        loadedMarker.putString("id", identifier);
        loadedMarker.putString("title", title);
        loadedMarker.putString("description", snippet);

        markers.pushMap(loadedMarker);
      }

      pointers.putArray("markers", markers);

      manager.pushEvent(context, this, "onKmlReady", pointers);

    } catch (XmlPullParserException | IOException | InterruptedException | ExecutionException e) {
      e.printStackTrace();
    }

}

@Override
public void onIndoorBuildingFocused() {
IndoorBuilding building = this.map.getFocusedBuilding();
if (building != null) {
List<IndoorLevel> levels = building.getLevels();
int index = 0;
WritableArray levelsArray = Arguments.createArray();
for (IndoorLevel level : levels) {
WritableMap levelMap = Arguments.createMap();
levelMap.putInt("index", index);
levelMap.putString("name", level.getName());
levelMap.putString("shortName", level.getShortName());
levelsArray.pushMap(levelMap);
index++;
}
WritableMap event = Arguments.createMap();
WritableMap indoorBuilding = Arguments.createMap();
indoorBuilding.putArray("levels", levelsArray);
indoorBuilding.putInt("activeLevelIndex", building.getActiveLevelIndex());
indoorBuilding.putBoolean("underground", building.isUnderground());

      event.putMap("IndoorBuilding", indoorBuilding);

      manager.pushEvent(context, this, "onIndoorBuildingFocused", event);
    } else {
      WritableMap event = Arguments.createMap();
      WritableArray levelsArray = Arguments.createArray();
      WritableMap indoorBuilding = Arguments.createMap();
      indoorBuilding.putArray("levels", levelsArray);
      indoorBuilding.putInt("activeLevelIndex", 0);
      indoorBuilding.putBoolean("underground", false);

      event.putMap("IndoorBuilding", indoorBuilding);

      manager.pushEvent(context, this, "onIndoorBuildingFocused", event);
    }

}

@Override
public void onIndoorLevelActivated(IndoorBuilding building) {
if (building == null) {
return;
}
int activeLevelIndex = building.getActiveLevelIndex();
if (activeLevelIndex < 0 || activeLevelIndex >= building.getLevels().size()) {
return;
}
IndoorLevel level = building.getLevels().get(activeLevelIndex);

    WritableMap event = Arguments.createMap();
    WritableMap indoorlevel = Arguments.createMap();

    indoorlevel.putInt("activeLevelIndex", activeLevelIndex);
    indoorlevel.putString("name", level.getName());
    indoorlevel.putString("shortName", level.getShortName());

    event.putMap("IndoorLevel", indoorlevel);

    manager.pushEvent(context, this, "onIndoorLevelActivated", event);

}

public void setIndoorActiveLevelIndex(int activeLevelIndex) {
IndoorBuilding building = this.map.getFocusedBuilding();
if (building != null) {
if (activeLevelIndex >= 0 && activeLevelIndex < building.getLevels().size()) {
IndoorLevel level = building.getLevels().get(activeLevelIndex);
if (level != null) {
level.activate();
}
}
}
}

private MapMarker getMarkerMap(Marker marker) {
MapMarker airMarker = markerMap.get(marker);

    if (airMarker != null) {
      return airMarker;
    }

    for (Map.Entry<Marker, MapMarker> entryMarker : markerMap.entrySet()) {
      if (entryMarker.getKey().getPosition().equals(marker.getPosition())
          && entryMarker.getKey().getTitle().equals(marker.getTitle())) {
        airMarker = entryMarker.getValue();
        break;
      }
    }

    return airMarker;

}

@Override
public void requestLayout() {
super.requestLayout();
post(measureAndLayout);
}

private final Runnable measureAndLayout = new Runnable() {
@Override
public void run() {
measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.EXACTLY),
MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.EXACTLY));
layout(getLeft(), getTop(), getRight(), getBottom());
}
};

}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapWMSTile.java">
package com.rnmaps.maps;

import android.content.Context;

import com.google.android.gms.maps.model.TileOverlayOptions;
import com.google.android.gms.maps.model.UrlTileProvider;

import java.net.MalformedURLException;
import java.net.URL;

public class MapWMSTile extends MapUrlTile {
private static final double[] mapBound = {-20037508.34789244, 20037508.34789244};
private static final double FULL = 20037508.34789244 \* 2;

class AIRMapGSUrlTileProvider extends MapTileProvider {

    class AIRMapWMSTileProvider extends UrlTileProvider {
    private String urlTemplate;
    private final int tileSize;

    public AIRMapWMSTileProvider(int width, int height, String urlTemplate) {
      super(width, height);
      this.urlTemplate = urlTemplate;
      this.tileSize = width;
    }

    @Override
    public URL getTileUrl(int x, int y, int zoom) {
      if(MapWMSTile.this.maximumZ > 0 && zoom > maximumZ) {
          return null;
      }

      if(MapWMSTile.this.minimumZ > 0 && zoom < minimumZ) {
          return null;
      }

      double[] bb = getBoundingBox(x, y, zoom);
      String s = this.urlTemplate
          .replace("{minX}", Double.toString(bb[0]))
          .replace("{minY}", Double.toString(bb[1]))
          .replace("{maxX}", Double.toString(bb[2]))
          .replace("{maxY}", Double.toString(bb[3]))
          .replace("{width}", Integer.toString(this.tileSize))
          .replace("{height}", Integer.toString(this.tileSize));
      URL url = null;

      try {
        url = new URL(s);
      } catch (MalformedURLException e) {
        throw new AssertionError(e);
      }
      return url;
    }

    private double[] getBoundingBox(int x, int y, int zoom) {
      double tile = FULL / Math.pow(2, zoom);
      return new double[]{
              mapBound[0] + x * tile,
              mapBound[1] - (y + 1) * tile,
              mapBound[0] + (x + 1) * tile,
              mapBound[1] - y * tile
      };
    }

    public void setUrlTemplate(String urlTemplate) {
      this.urlTemplate = urlTemplate;
    }

}

public AIRMapGSUrlTileProvider(int tileSizet, String urlTemplate,
int maximumZ, int maximumNativeZ, int minimumZ, String tileCachePath,
int tileCacheMaxAge, boolean offlineMode, Context context, boolean customMode) {
super(tileSizet, false, urlTemplate, maximumZ, maximumNativeZ, minimumZ, false,
tileCachePath, tileCacheMaxAge, offlineMode, context, customMode);
this.tileProvider = new AIRMapWMSTileProvider(tileSizet, tileSizet, urlTemplate);
}
}

public MapWMSTile(Context context) {
super(context);
}

@Override
protected TileOverlayOptions createTileOverlayOptions() {
TileOverlayOptions options = new TileOverlayOptions();
options.zIndex(zIndex);
options.transparency(1 - this.opacity);
AIRMapGSUrlTileProvider tileProvider = new AIRMapGSUrlTileProvider((int) this.tileSize, this.urlTemplate,
(int) this.maximumZ, (int) this.maximumNativeZ, (int) this.minimumZ, this.tileCachePath,
(int) this.tileCacheMaxAge, this.offlineMode, this.context, this.customTileProviderNeeded);
options.tileProvider(tileProvider);
return options;
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/MapWMSTileManager.java">
package com.rnmaps.maps;

import android.content.Context;
import android.util.DisplayMetrics;
import android.view.WindowManager;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;

public class MapWMSTileManager extends ViewGroupManager<MapWMSTile> {

public MapWMSTileManager(ReactApplicationContext reactContext) {
super();
DisplayMetrics metrics = new DisplayMetrics();
((WindowManager) reactContext.getSystemService(Context.WINDOW_SERVICE))
.getDefaultDisplay()
.getRealMetrics(metrics);
}

@Override
public String getName() {
return "AIRMapWMSTile";
}

@Override
public MapWMSTile createViewInstance(ThemedReactContext context) {
return new MapWMSTile(context);
}

@ReactProp(name = "urlTemplate")
public void setUrlTemplate(MapWMSTile view, String urlTemplate) {
view.setUrlTemplate(urlTemplate);
}

@ReactProp(name = "zIndex", defaultFloat = -1.0f)
public void setZIndex(MapWMSTile view, float zIndex) {
view.setZIndex(zIndex);
}

@ReactProp(name = "minimumZ", defaultFloat = 0.0f)
public void setMinimumZ(MapWMSTile view, float minimumZ) {
view.setMinimumZ(minimumZ);
}

@ReactProp(name = "maximumZ", defaultFloat = 100.0f)
public void setMaximumZ(MapWMSTile view, float maximumZ) {
view.setMaximumZ(maximumZ);
}

@ReactProp(name = "maximumNativeZ", defaultFloat = 100.0f)
public void setMaximumNativeZ(MapWMSTile view, float maximumNativeZ) {
view.setMaximumNativeZ(maximumNativeZ);
}

@ReactProp(name = "tileSize", defaultFloat = 256.0f)
public void setTileSize(MapWMSTile view, float tileSize) {
view.setTileSize(tileSize);
}

@ReactProp(name = "tileCachePath")
public void setTileCachePath(MapWMSTile view, String tileCachePath) {
view.setTileCachePath(tileCachePath);
}

@ReactProp(name = "tileCacheMaxAge", defaultFloat = 0.0f)
public void setTileCacheMaxAge(MapWMSTile view, float tileCacheMaxAge) {
view.setTileCacheMaxAge(tileCacheMaxAge);
}

@ReactProp(name = "offlineMode", defaultBoolean = false)
public void setOfflineMode(MapWMSTile view, boolean offlineMode) {
view.setOfflineMode(offlineMode);
}

@ReactProp(name = "opacity", defaultFloat = 1.0f)
public void setOpacity(MapWMSTile view, float opacity) {
view.setOpacity(opacity);
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/RegionChangeEvent.java">
package com.rnmaps.maps;

import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.uimanager.events.Event;
import com.facebook.react.uimanager.events.RCTEventEmitter;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.LatLngBounds;

public class RegionChangeEvent extends Event<RegionChangeEvent> {
private final LatLngBounds bounds;
private final boolean continuous;
private final boolean isGesture;

public RegionChangeEvent(int id, LatLngBounds bounds, boolean continuous, boolean isGesture) {
super(id);
this.bounds = bounds;
this.continuous = continuous;
this.isGesture = isGesture;
}

@Override
public String getEventName() {
return "topChange";
}

@Override
public boolean canCoalesce() {
return false;
}

@Override
public void dispatch(RCTEventEmitter rctEventEmitter) {
WritableMap event = new WritableNativeMap();
event.putBoolean("continuous", continuous);

    WritableMap region = new WritableNativeMap();
    LatLng center = bounds.getCenter();
    region.putDouble("latitude", center.latitude);
    region.putDouble("longitude", center.longitude);
    region.putDouble("latitudeDelta", bounds.northeast.latitude - bounds.southwest.latitude);
    region.putDouble("longitudeDelta", bounds.northeast.longitude - bounds.southwest.longitude);
    event.putMap("region", region);
    event.putBoolean("isGesture", isGesture);

    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), event);

}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/SizeReportingShadowNode.java">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

package com.rnmaps.maps;

import com.facebook.react.uimanager.LayoutShadowNode;
import com.facebook.react.uimanager.UIViewOperationQueue;

import java.util.HashMap;
import java.util.Map;

// Custom LayoutShadowNode implementation used in conjunction with the AirMapManager
// which sends the width/height of the view after layout occurs.
public class SizeReportingShadowNode extends LayoutShadowNode {

@Override
public void onCollectExtraUpdates(UIViewOperationQueue uiViewOperationQueue) {
super.onCollectExtraUpdates(uiViewOperationQueue);

    Map<String, Float> data = new HashMap<>();
    data.put("width", getLayoutWidth());
    data.put("height", getLayoutHeight());

    uiViewOperationQueue.enqueueUpdateExtraData(getReactTag(), data);

}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/ViewAttacherGroup.java">
package com.rnmaps.maps;

import android.content.Context;
import android.graphics.Rect;

import com.facebook.react.views.view.ReactViewGroup;

public class ViewAttacherGroup extends ReactViewGroup {

public ViewAttacherGroup(Context context) {
super(context);

    this.setWillNotDraw(true);
    this.setVisibility(VISIBLE);
    this.setAlpha(0.0f);
    this.setRemoveClippedSubviews(false);
    this.setClipBounds(new Rect(0, 0, 0, 0));
    this.setOverflow("hidden"); // Change to ViewProps.HIDDEN until RN 0.57 is base

}

// This should make it more performant, avoid trying to hard to overlap layers with opacity.
@Override
public boolean hasOverlappingRendering() {
return false;
}
}
</file>

<file path="android/src/main/java/com/rnmaps/maps/ViewChangesTracker.java">
package com.rnmaps.maps;

import android.os.Handler;
import android.os.Looper;

import java.util.LinkedList;

public class ViewChangesTracker {

private static ViewChangesTracker instance;
private final Handler handler;
private final LinkedList<MapMarker> markers = new LinkedList<>();
private boolean hasScheduledFrame = false;
private final Runnable updateRunnable;
private final long fps = 40;

private ViewChangesTracker() {
handler = new Handler(Looper.myLooper());
updateRunnable = new Runnable() {
@Override
public void run() {  
 update();

        if (markers.size() > 0) {
          handler.postDelayed(updateRunnable, fps);
        } else {
          hasScheduledFrame = false;
        }
      }
    };

}

static ViewChangesTracker getInstance() {
if (instance == null) {
synchronized (ViewChangesTracker.class) {
instance = new ViewChangesTracker();
}
}

    return instance;

}

public void addMarker(MapMarker marker) {
markers.add(marker);

    if (!hasScheduledFrame) {
      hasScheduledFrame = true;
      handler.postDelayed(updateRunnable, fps);
    }

}

public void removeMarker(MapMarker marker) {
markers.remove(marker);
}

public boolean containsMarker(MapMarker marker) {
return markers.contains(marker);
}

private final LinkedList<MapMarker> markersToRemove = new LinkedList<>();

public void update() {
for (MapMarker marker : markers) {
if (!marker.updateCustomForTracking()) {
markersToRemove.add(marker);
}
}

    // Remove markers that are not active anymore
    if (markersToRemove.size() > 0) {
      markers.removeAll(markersToRemove);
      markersToRemove.clear();
    }

}

}
</file>

<file path="android/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
</manifest>
</file>

<file path="android/build.gradle">
def safeExtGet(prop, fallback) {
  rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback
}

buildscript {
// The Android Gradle plugin is only required when opening the android folder stand-alone.
// This avoids unnecessary downloads and potential conflicts when the library is included as a
// module dependency in an application project.
if (project == rootProject) {
repositories {
google()
mavenCentral()
}
dependencies {
classpath("com.android.tools.build:gradle:7.6.3")
}
}
}

apply plugin: 'com.android.library'

def isNewArchitectureEnabled() {
return project.hasProperty("newArchEnabled") && project.newArchEnabled == "true"
}

android {
namespace "com.rnmaps.maps"
def agpVersion = com.android.Version.ANDROID_GRADLE_PLUGIN_VERSION
if (agpVersion.tokenize('.')[0].toInteger() >= 7) {
namespace "com.rnmaps.maps"
}

compileSdk safeExtGet('compileSdkVersion', 34)

defaultConfig {
minSdkVersion safeExtGet('minSdkVersion', 21)
targetSdkVersion safeExtGet('targetSdkVersion', 34)

    buildConfigField "boolean", "IS_NEW_ARCHITECTURE_ENABLED", isNewArchitectureEnabled().toString()

}
packagingOptions {
excludes = [
"META-INF",
"META-INF/**",
]
}
}

repositories {
mavenLocal()
mavenCentral()
maven {
// All of React Native (JS, Obj-C sources, Android binaries) is installed from npm
url "$rootDir/../node_modules/react-native/android"
  }
  maven {
    // Android JSC is installed from npm
    url "$rootDir/../node_modules/jsc-android/dist"
}
google()
}

dependencies {
implementation 'com.facebook.react:react-native:+'
implementation "com.google.android.gms:play-services-base:${safeExtGet('playServicesVersion', '18.2.0')}"
  implementation "com.google.android.gms:play-services-maps:${safeExtGet('playServicesVersion', '18.2.0')}"
implementation "com.google.android.gms:play-services-location:21.0.1"
implementation 'com.google.maps.android:android-maps-utils:3.8.2'
implementation "androidx.work:work-runtime:2.7.1"
}
</file>

<file path="android/gradlew">
#!/bin/sh

#

# Copyright  2015-2021 the original authors.

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

# https://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.

#

# SPDX-License-Identifier: Apache-2.0

#

##############################################################################

#

# Gradle start up script for POSIX generated by Gradle.

#

# Important for running:

#

# (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is

# noncompliant, but you have some other compliant shell such as ksh or

# bash, then to run this script, type that shell name before the whole

# command line, like:

#

# ksh Gradle

#

# Busybox and similar reduced shells will NOT work, because this script

# requires all of these POSIX shell features:

# \* functions;

# \* expansions $var, ${var}, ${var:-default}, ${var+SET},

# ${var#prefix}, ${var%suffix}, and $( cmd );

# \* compound commands having a testable exit status, especially case;

# \* various built-in commands including command, set, and ulimit.

#

# Important for patching:

#

# (2) This script targets any POSIX shell, so it avoids extensions provided

# by Bash, Ksh, etc; in particular arrays are avoided.

#

# The "traditional" practice of packing multiple parameters into a

# space-separated string is a well documented source of bugs and security

# problems, so this is (mostly) avoided, by progressively accumulating

# options in "$@", and eventually passing that to Java.

#

# Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,

# and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;

# see the in-line comments for details.

#

# There are tweaks for specific operating systems such as AIX, CygWin,

# Darwin, MinGW, and NonStop.

#

# (3) This script is generated from the Groovy template

# https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt

# within the Gradle project.

#

# You can find Gradle at https://github.com/gradle/gradle/.

#

##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link

app_path=$0

# Need this for daisy-chained symlinks.

while
APP_HOME=${app_path%"${app_path##_/}"} # leaves a trailing /; empty if no leading path
[ -h "$app_path" ]
do
ls=$( ls -ld "$app_path" )
link=${ls#_' -> '}
case $link in             #(
      /*)   app_path=$link ;; #(
\*) app_path=$APP_HOME$link ;;
esac
done

# This is normally unused

# shellcheck disable=SC2034

APP_BASE_NAME=${0##\*/}

# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)

APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.

MAX_FD=maximum

warn () {
echo "$\*"
} >&2

die () {
echo
echo "$\*"
echo
exit 1
} >&2

# OS specific support (must be 'true' or 'false').

cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in #(
CYGWIN* ) cygwin=true ;; #(
Darwin* ) darwin=true ;; #(
MSYS* | MINGW* ) msys=true ;; #(
NONSTOP\* ) nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.

if [ -n "$JAVA_HOME" ] ; then
if [ -x "$JAVA_HOME/jre/sh/java" ] ; then # IBM's JDK on AIX uses strange locations for the executables
JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
fi
if [ ! -x "$JAVACMD" ] ; then
die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi
else
JAVACMD=java
if ! command -v java >/dev/null 2>&1
then
die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi
fi

# Increase the maximum file descriptors if we can.

if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
warn "Could not query maximum file descriptor limit"
esac
case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
warn "Could not set maximum file descriptor limit to $MAX_FD"
esac
fi

# Collect all arguments for the java command, stacking in reverse order:

# \* args from the command line

# \* the main class name

# \* -classpath

# \* -D...appname settings

# \* --module-path (only if needed)

# \* DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java

if "$cygwin" || "$msys" ; then
APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done

fi

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.

DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:

# \* DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,

# and any embedded shellness will be escaped.

# \* For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be

# treated as '${Hostname}' itself on the command line.

set -- \
 "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
 org.gradle.wrapper.GradleWrapperMain \
 "$@"

# Stop when "xargs" is not available.

if ! command -v xargs >/dev/null 2>&1
then
die "xargs is not available"
fi

# Use "xargs" to parse quoted args.

#

# With -n1 it outputs one arg per line, with the quotes and backslashes removed.

#

# In Bash we could simply go:

#

# readarray ARGS < <( xargs -n1 <<<"$var" ) &&

# set -- "${ARGS[@]}" "$@"

#

# but POSIX shell has neither arrays nor command substitution, so instead we

# post-process each arg (as a line of input to sed) to backslash-escape any

# character that might be a shell metacharacter, then use eval to reverse

# that process (while maintaining the separation between arguments), and wrap

# the whole thing up as a single "set" statement.

#

# This will of course break if any of these variables contains a newline or

# an unmatched quote.

#

eval "set -- $(
        printf '%s\n' "$DEFAULT*JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
xargs -n1 |
sed ' s~[^-[:alnum:]+,./:=@*]~\\&~g; ' |
tr '\n' ' '
)" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="android/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %\*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE*EXIT_CONSOLE if you need the \_script* return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="docs/callout.md">
# `<Callout />` Component API

## Props

| Prop           | Type      | Default | Note                                                                                                                                                                                            |
| -------------- | --------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `tooltip`      | `Boolean` | `false` | If `false`, a default "tooltip" bubble window will be drawn around this callouts children. If `true`, the child views can fully customize their appearance, including any "bubble" like styles. |
| `alphaHitTest` | `Boolean` | `false` | If `true`, clicks on transparent areas in callout will be passed to map. **Note**: iOS only.                                                                                                    |

## Events

| Event Name | Returns | Notes                                                        |
| ---------- | ------- | ------------------------------------------------------------ |
| `onPress`  |         | Callback that is called when the user presses on the callout |

---

# `<CalloutSubview />` Component API

**Note**: Supported on iOS only.
Use to handle press on specific subview of callout.
Put this component inside `<Callout />`.

## Events

| Event Name | Returns | Notes                                                                        |
| ---------- | ------- | ---------------------------------------------------------------------------- |
| `onPress`  |         | Callback that is called when the user presses on this subview inside callout |

## Notes

Native press event has property `action`, which is:

- `callout-press` (or `marker-overlay-press` for GoogleMaps on iOS) for press on `<Callout />`
- `callout-inside-press` (or `marker-inside-overlay-press` for GoogleMaps on iOS) for press on `<CalloutSubview />`
  </file>

<file path="docs/circle.md">
# `<Circle />` Component API

## Props

| Prop              | Type            | Default                   | Note                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ----------------- | --------------- | ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `center`          | `LatLng`        | (Required)                | The coordinate of the center of the circle                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `radius`          | `Number`        | (Required)                | The radius of the circle to be drawn (in meters)                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `strokeWidth`     | `Number`        | `1`                       | The stroke width to use for the path.                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `strokeColor`     | `String`        | `#000`, `rgba(r,g,b,0.5)` | The stroke color to use for the path.                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `fillColor`       | `String`        | `#000`, `rgba(r,g,b,0.5)` | The fill color to use for the path.                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `zIndex`          | `Number`        | 0                         | The order in which this tile overlay is drawn with respect to other overlays. An overlay with a larger z-index is drawn over overlays with smaller z-indices. The order of overlays with the same z-index is arbitrary. The default zIndex is 0. (Android Only)                                                                                                                                                                                                                   |
| `lineCap`         | `String`        | `round`                   | The line cap style to apply to the open ends of the path. Other values : `butt`, `square`                                                                                                                                                                                                                                                                                                                                                                                         |
| `lineJoin`        | `String`        |                           | The line join style to apply to corners of the path. possible value: `miter`, `round`, `bevel`                                                                                                                                                                                                                                                                                                                                                                                    |
| `miterLimit`      | `Number`        |                           | The limiting value that helps avoid spikes at junctions between connected line segments. The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If the ratio of the miter lengththat is, the diagonal length of the miter jointo the line thickness exceeds the miter limit, the joint is converted to a bevel join. The default miter limit is 10, which results in the conversion of miters whose angle at the joint is less than 11 degrees. |
| `lineDashPhase`   | `Number`        | `0`                       | (iOS only) The offset (in points) at which to start drawing the dash pattern. Use this property to start drawing a dashed line partway through a segment or gap. For example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the middle of the first gap.                                                                                                                                                                                              |
| `lineDashPattern` | `Array<Number>` | `null`                    | (iOS only) An array of numbers specifying the dash pattern to use for the path. The array contains one or more numbers that indicate the lengths (measured in points) of the line segments and gaps in the pattern. The values in the array alternate, starting with the first line segment length, followed by the first gap length, followed by the second line segment length, and so on.                                                                                      |

## Types

```
type LatLng {
  latitude: Number,
  longitude: Number,
}
```

</file>

<file path="docs/examples-setup.md">
# Examples Setup

- Clone or download the repository.
- From the root of the project run `yarn bootstrap`
- Add your API key(s)
  - Android
    - Open `example/android/local.properties` (or create the file if it doesn't already exist)
    - Add the following line: `MAPS_API_KEY=your_api_key_here`
  - iOS
    - Open `example/ios/Config.xcconfig` (or create the file if it doesn't already exist)
    - Add the following line: `MAPS_API_KEY=your_api_key_here`
- Run `yarn android` or `yarn ios` within the example folder
  </file>

<file path="docs/geojson.md">
# `<Geojson />` Component API

## Props

| Prop                | Type                            | Default                                                | Note                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ------------------- | ------------------------------- | ------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `geojson`           | `GeoJSON`                       |                                                        | [Geojson](https://geojson.org/) description of object.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `strokeColor`       | `String`                        | `stroke` property in GeoJson if present else `#000`    | The stroke color to use for polygons and polylines.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `fillColor`         | `String`                        | `fill` property in GeoJson                             | The fill color to use for polygons.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `strokeWidth`       | `Number`                        | `stroke-width` property in Geojson if present else `1` | The stroke width to use for polygons and polylines.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `color`             | `String`                        | `marker-color` property in GeoJson                     | The color to use for points.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `lineDashPhase`     | `Number`                        |                                                        | (iOS only) The offset (in points) at which to start drawing the dash pattern. Use this property to start drawing a dashed line partway through a segment or gap. For example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the middle of the first gap.                                                                                                                                                                                                                                                                                                                                                                        |
| `lineDashPattern`   | `Array<Number>`                 |                                                        | An array of numbers specifying the dash pattern to use for the path. The array contains one or more numbers that indicate the lengths (measured in points) of the line segments and gaps in the pattern. The values in the array alternate, starting with the first line segment length, followed by the first gap length, followed by the second line segment length, and so on.                                                                                                                                                                                                                                                                           |
| `lineCap`           | `'butt' \| 'round' \| 'square'` |                                                        | The line cap style to apply to the open ends of the path. Possible values are `butt`, `round` or `square`. Note: lineCap is not yet supported for GoogleMaps provider on iOS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `lineJoin`          | `'miter' \| 'round' \| 'bevel'` |                                                        | The line join style to apply to corners of the path. Possible values are `miter`, `round` or `bevel`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `miterLimit`        | `Number`                        |                                                        | The limiting value that helps avoid spikes at junctions between connected line segments. The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If the ratio of the miter lengththat is, the diagonal length of the miter jointo the line thickness exceeds the miter limit, the joint is converted to a bevel join. The default miter limit is 10, which results in the conversion of miters whose angle at the joint is less than 11 degrees.                                                                                                                                                                           |
| `zIndex`            | `Number`                        |                                                        | Layer level of the z-index value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `onPress`           | `Function`                      |                                                        | returns the selected overlay value with the onPress functionality                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `markerComponent`   | `React Node`                    |                                                        | Component to render in place of the default marker when the overlay type is a `point`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `title`             | `string`                        |                                                        | The title of the marker. This is only used if the <Marker /> component has no children that are a `<Callout />`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `tracksViewChanges` | `Boolean`                       | true                                                   | Sets whether this marker should track view changes. It's recommended to turn it off whenever it's possible to improve custom marker performance. This is the default value for all point markers in your geojson data. It can be overriden on a per point basis by adding a `trackViewChanges` property to the `properties` object on the point.                                                                                                                                                                                                                                                                                                            |
| `anchor`            | `Point`                         | (0.5, 1)                                               | Sets the anchor point for the marker.<br/><br/> The anchor specifies the point in the icon image that is anchored to the marker's position on the Earth's surface.<br/><br/> The anchor point is specified in the continuous space [0.0, 1.0] x [0.0, 1.0], where (0, 0) is the top-left corner of the image, and (1, 1) is the bottom-right corner. The anchoring point in a W x H image is the nearest discrete grid point in a (W + 1) x (H + 1) grid, obtained by scaling the then rounding. For example, in a 4 x 2 image, the anchor point (0.7, 0.6) resolves to the grid point at (3, 1).<br/><br/> For MapKit on iOS, see the `centerOffset` prop. |
| `centerOffset`      | `Point`                         | (0, 0)                                                 | The offset (in points) at which to display the view.<br/><br/> By default, the center point of an annotation view is placed at the coordinate point of the associated annotation. You can use this property to reposition the annotation view as needed. This x and y offset values are measured in points. Positive offset values move the annotation view down and to the right, while negative values move it up and to the left.<br/><br/> For Google Maps, see the `anchor` prop.                                                                                                                                                                      |

## Example

```
import React from 'react';
import MapView, {Geojson} from 'react-native-maps';

const myPlace = {
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Point',
        coordinates: [64.165329, 48.844287],
      }
    }
  ]
};

const Map = props => (
  <MapView>
    <Geojson
      geojson={myPlace}
      strokeColor="red"
      fillColor="green"
      strokeWidth={2}
    />
  </MapView>
);
```

</file>

<file path="docs/heatmap.md">
# `<Heatmap />` Component API

**Note**: Supported on Google Maps only.

## Props

| Prop       | Type                    | Default | Note                                                              |
| ---------- | ----------------------- | ------- | ----------------------------------------------------------------- |
| `points`   | `Array<WeightedLatLng>` |         | Array of heatmap entries to apply towards density.                |
| `radius`   | `Number`                | `20`    | The radius of the heatmap points in pixels, between 10 and 50.    |
| `opacity`  | `Number`                | `0.7`   | The opacity of the heatmap.                                       |
| `gradient` | `Object`                |         | Heatmap gradient configuration (See below for _Gradient Config_). |

## Gradient Config

[Android Doc](https://developers.google.com/maps/documentation/android-sdk/utility/heatmap#custom) | [iOS Doc](https://developers.google.com/maps/documentation/ios-sdk/utility/heatmap#customize)

| Prop           | Type            | Default | Note                                                                                                                                  |
| -------------- | --------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `colors`       | `Array<String>` |         | Colors (one or more) to use for gradient.                                                                                             |
| `startPoints`  | `Array<Number>` |         | Array of floating point values from 0 to 1 representing where each color starts. Array length must be equal to `colors` array length. |
| `colorMapSize` | `Number`        | `256`   | Resolution of color map -- number corresponding to the number of steps colors are interpolated into.                                  |

## Types

```
type WeightedLatLng = {
  latitude: Number;
  longitude: Number;
  weight?: Number;
}
```

</file>

<file path="docs/installation.md">
# Installation

Install the library from npm:

```sh
$ npm install react-native-maps
# --- or ---
$ yarn add react-native-maps
```

The actual map implementation depends on the platform. On Android, one has to use [Google Maps](https://developers.google.com/maps/documentation/), which in turn requires you to obtain an [API key for the Android SDK](https://developers.google.com/maps/documentation/android-sdk/signup).

On iOS, one can choose between Google Maps or the native [Apple Maps](https://developer.apple.com/documentation/mapkit/) implementation.

When using Google Maps on iOS, you need also to obtain an [API key for the iOS SDK](https://developers.google.com/maps/documentation/ios-sdk/get-api-key) and include the Google Maps library in your build. The native Apple Maps based implementation works out-of-the-box and is therefore simpler to use at the price of missing some of the features supported by the Google Maps backend.

> **WARNING**: Before you can start using the Google Maps Platform APIs and SDKs, you must sign up and create a [billing account](https://developers.google.com/maps/gmp-get-started#create-billing-account)!

---

## iOS

After installing the npm package, we need to install the pod.

```sh
$ (cd ios && pod install)
# --- or ---
$ npx pod-install
```

### Enabling Google Maps

If you want to enable Google Maps on iOS, obtain the Google API key and edit your `AppDelegate.m(m)` as follows:

```diff
+ #import <GoogleMaps/GoogleMaps.h>

@implementation AppDelegate
...

(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
+  [GMSServices provideAPIKey:@"_YOUR_API_KEY_"]; // add this line using the api key obtained from Google Console
...
```

The `[GMSServices provideAPIKey]` should be the **first call** of the method.

Google Maps SDK for iOS requires iOS 14, so make sure that your deployment target is >= 4 in your iOS project settings.

Also make sure that your Podfile deployment target is set to >= 14 at the top of your Podfile, eg:

```ruby
platform :ios, '14'
```

Add the following to your Podfile above the `use_native_modules!` function and run `pod install` in the ios folder:

```ruby
# React Native Maps dependencies

rn_maps_path = '../node_modules/react-native-maps'
pod 'react-native-google-maps', :path => rn_maps_path
```

The app's Info.plist file must contain a NSLocationWhenInUseUsageDescription with a user-facing purpose string explaining clearly and completely why your app needs the location, otherwise Apple will reject your app submission. This is required whether or not you are accessing the users location, as Google Maps iOS SDK contains the code required to access the users location.

That's it, you made it! 

---

## Android

### Specify your Google Maps API key

Add your API key to your manifest file (`android/app/src/main/AndroidManifest.xml`):

```xml
<application>
   <!-- You will only need to add this meta-data tag, but make sure it's a child of application -->
   <meta-data
     android:name="com.google.android.geo.API_KEY"
     android:value="Your Google maps API Key Here"/>
</application>
```

### Upgrading to >= v0.31.0

The installation documentation previously specified adding `supportLibVersion`, `playServicesVersion` and `androidMapsUtilsVersion` to `build.gradle`.

None of these keys are required anymore and can be removed, if not used by other modules in your project.

> **ATTENTION**: If you leave `playServicesVersion` in `build.gradle`, the version must be at least `18.0.0`

### Ensure that you have Google Play Services installed

- For the Genymotion emulator, you can follow [these instructions](https://www.genymotion.com/help/desktop/faq/#google-play-services).
- For a physical device you need to search on Google for 'Google Play
  Services'. There will be a link that takes you to the Play Store and
  from there you will see a button to update it (do not search within the
  Play Store).

## Troubleshooting

### The map background is blank (Google Maps)

If google logo/markers/polylines etc are displayed but the map
background is otherwise blank, this is likely an API key issue. Verify
your API keys and their restrictions. Ensure the native `provideAPIKey`
call is the first line of `didFinishLaunchingWithOptions`.

Ensure also that the relevant Google APIs have been enabled for your
project from the URLs below:

- [Google Maps SDK Android](https://console.developers.google.com/apis/library/maps-android-backend.googleapis.com/)
- [Google Maps SDK iOS (if required)](https://console.developers.google.com/apis/library/maps-ios-backend.googleapis.com)

For reference, you may read the relevant issue reports: ([#118](https://github.com/react-native-maps/react-native-maps/issues/118), [#176](https://github.com/react-native-maps/react-native-maps/issues/176), [#684](https://github.com/react-native-maps/react-native-maps/issues/684)).

### The map background is gray (Google Maps)

If you get grey screen on android device create google_maps_api.xml in android/app/src/main/res/values.

```xml
<resources>
  <string name="google_maps_key" templateMergeStrategy="preserve" translatable="false">(api key here)</string>
</resources>
```

### No map whatsoever

Ensure the map component and its container have viewport dimensions. An
example is below:

```jsx
import MapView, { PROVIDER_GOOGLE } from 'react-native-maps'; // remove PROVIDER_GOOGLE import if not using Google Maps
...
const styles = StyleSheet.create({
 container: {
   ...StyleSheet.absoluteFillObject,
   height: 400,
   width: 400,
   justifyContent: 'flex-end',
   alignItems: 'center',
 },
 map: {
   ...StyleSheet.absoluteFillObject,
 },
});

export default () => (
   <View style={styles.container}>
     <MapView
       provider={PROVIDER_GOOGLE} // remove if not using Google Maps
       style={styles.map}
       region={{
         latitude: 37.78825,
         longitude: -122.4324,
         latitudeDelta: 0.015,
         longitudeDelta: 0.0121,
       }}
     >
     </MapView>
   </View>
);
```

### Build issues with Google Maps iOS Utils (iOS)

If your XCode project uses dynamic frameworks (e.g. you also have Swift
code in your project), you cannot install `Google-Maps-iOS-Utils` with
CocoaPods. The issue and a workaround for it has been documented
[here](https://github.com/googlemaps/google-maps-ios-utils/blob/b721e95a500d0c9a4fd93738e83fc86c2a57ac89/Swift.md).

### Runtime errors on iOS (Apple Maps)

If you are trying to mount the map with the `GOOGLE_PROVIDER` during
runtime, but your build has been configured for the Apple Maps backend,
a runtime exception will be raised.

In addition, when using Apple Maps, some Google-only functionalities
have been disabled via runtime errors.

An exception will be raised if you try to use advanced features that
depend on the [Google Maps SDK for
iOS](https://github.com/googlemaps/google-maps-ios-utils). These include

- Making markers from KML files
- Heatmap rendering
- Marker clustering
- etc.

### Clearing caches

Run these commands to clean caches

```sh
watchman watch-del-all
npm cache clean

# Android, if you encounter `com.android.dex.DexException: Multiple dex files define Landroid/support/v7/appcompat/R$anim`, then clear build folder.
cd android
./gradlew clean
cd ..
```

### When using Android studio

Make sure your Android studio is up to date and set up following the [React Native docs](https://reactnative.dev/docs/environment-setup).

In particular, the following packages have to be installed:

- Extras / Google Play services
- Extras / Google Repository
- Android 6.0 (API 23) / Google APIs Intel x86 Atom System Image Rev. 19
- Android SDK Build-tools 23.0.3

### Android emulator issues

- When starting Android emulator, make sure you have enabled `Wipe user data`.
- If you are using Android Virtual Devices (AVD), ensure that `Use Host GPU` is checked in the settings for your virtual device.
- If using an emulator and the only thing that shows up on the screen is
  the message: `[APPNAME] won't run without Google Play services which are not supported by your device.`, you need to change the emulator
  CPU/ABI setting to a system image that includes Google APIs. These may
  need to be downloaded from the Android SDK Manager first.

### Google Play Services conflicting issues with other modules

In case you have multiple modules using the same Google Play Services dependencies (such as `react-native-onesignal`), you can exclude the conflicting dependencies from the modules and import the Google Play Services dependencies in the project-wide `build.gradle` file like the following example:

```groovy
  implementation(project(':react-native-onesignal')){
      exclude group: 'com.google.android.gms'
  }

  implementation(project(':react-native-maps')){
      exclude group: 'com.google.android.gms'
  }
  implementation 'com.google.android.gms:play-services-base:18.0.1'
  implementation 'com.google.android.gms:play-services-location:19.0.1'
  implementation 'com.google.android.gms:play-services-maps:18.0.2'
```

A list of the current dependencies can be found [here](https://developers.google.com/android/guides/setup#list-dependencies).

> **ATTENTION**: `react-native-maps` requires `play-services-maps >= 18.0.0`

### Trouble with Google Play services

- Make sure that your emulator has Google Play (Go to Android studio -> Virtual Devices -> Check that you have icon in "Play Store" column)
- Click to bottom dots icon in the emulator
- Go to Google Play Tab and click Update
  </file>

<file path="docs/mapview.md">
# `<MapView />` Component API

## Props

| Prop                              | Type                                 | Default      | Note                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| --------------------------------- | ------------------------------------ | ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `provider`                        | `string`                             |              | The map framework to use. <br/><br/>Either `"google"` for GoogleMaps, otherwise `null` or `undefined` to use the native map framework (`MapKit` in iOS and `GoogleMaps` in android).                                                                                                                                                                                                                                                                                                                                             |
| `region`                          | `Region`                             |              | The region to be displayed by the map. <br/><br/>The region is defined by the center coordinates and the span of coordinates to display.                                                                                                                                                                                                                                                                                                                                                                                         |
| `initialRegion`                   | `Region`                             |              | The initial region to be displayed by the map. Use this prop instead of `region` only if you don't want to control the viewport of the map besides the initial region.<br/><br/> Changing this prop after the component has mounted will not result in a region change.<br/><br/> This is similar to the `initialValue` prop of a text input.                                                                                                                                                                                    |
| `camera`                          | `Camera`                             |              | The camera view the map should display. If you use this, the `region` property is ignored.                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `initialCamera`                   | `Camera`                             |              | Like `initialRegion`, use this prop instead of `camera` only if you don't want to control the viewport of the map besides the initial camera setting.<br/><br/> Changing this prop after the component has mounted will not result in a region change.<br/><br/> This is similar to the `initialValue` prop of a text input.                                                                                                                                                                                                     |
| `mapPadding`                      | `EdgePadding`                        |              | Adds custom padding to each side of the map. Useful when map elements/markers are obscured.                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `paddingAdjustmentBehavior`       | 'always' \| 'automatic' \| 'never'   | 'never'      | Indicates how/when to affect padding with safe area insets (`GoogleMaps` in iOS only)                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `liteMode`                        | `Boolean`                            | `false`      | Enable [lite mode](https://developers.google.com/maps/documentation/android-sdk/lite#overview_of_lite_mode). **Note**: Android only.                                                                                                                                                                                                                                                                                                                                                                                             |
| `googleMapId`                     | `String`                             |              | Google Map ID (only for Provider "google") [google map id](https://developers.google.com/maps/documentation/get-map-id)                                                                                                                                                                                                                                                                                                                                                                                                          |
| `mapType`                         | `String`                             | `"standard"` | The map type to be displayed. <br/><br/> - standard: standard road map (default)<br/> - none: no map **Note** Not available on MapKit<br/> - satellite: satellite view<br/> - hybrid: satellite view with roads and points of interest overlayed<br/> - terrain: topographic view<br/> - mutedStandard: more subtle, makes markers/lines pop more (iOS 11.0+ only)<br/> - satelliteFlyover: 3D globe with sattelite view (iOS 13.0+ Apple Maps only)<br/> - hybridFlyover: 3D globe with hybrid view (iOS 13.0+ Apple Maps only) |
| `customMapStyle`                  | `Array`                              |              | Adds custom styling to the map component. See [README](https://github.com/react-native-maps/react-native-maps#customizing-the-map-style) for more information.                                                                                                                                                                                                                                                                                                                                                                   |
| `userInterfaceStyle`              | 'light' \| 'dark'                    |              | Sets the map to the style selected. Default is whatever the system settings is. **Note:** iOS Maps only (aka MapKit).                                                                                                                                                                                                                                                                                                                                                                                                            |
| `showsUserLocation`               | `Boolean`                            | `false`      | If `true` the users location will be shown on the map. **NOTE**: You need runtime location permissions prior to setting this to true, otherwise it is going to _fail silently_! Checkout the excellent [react-native-permissions](https://github.com/zoontek/react-native-permissions) for this.                                                                                                                                                                                                                                 |
| `userLocationPriority`            | 'balanced'\|'high'\|'low'\|'passive' | 'high'       | Set power priority of user location tracking. See [Google APIs documentation](https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest.html). **Note:** Android only.                                                                                                                                                                                                                                                                                                                     |
| `userLocationUpdateInterval`      | `Number`                             | 5000         | Interval of user location updates in milliseconds. See [Google APIs documentation](https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest.html). **Note:** Android only.                                                                                                                                                                                                                                                                                                                |
| `userLocationFastestInterval`     | `Number`                             | 5000         | Fastest interval the application will actively acquire locations. See [Google APIs documentation](https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest.html). **Note:** Android only.                                                                                                                                                                                                                                                                                                 |
| `userLocationAnnotationTitle`     | `String`                             |              | The title of the annotation for current user location. This only works if `showsUserLocation` is true. There is a default value `My Location` set by MapView. **Note**: iOS only.                                                                                                                                                                                                                                                                                                                                                |
| `followsUserLocation`             | `Boolean`                            | `false`      | If `true` the map will focus on the user's location. This only works if `showsUserLocation` is true and the user has shared their location. **Note**: Apple Maps only.                                                                                                                                                                                                                                                                                                                                                           |
| `userLocationCalloutEnabled`      | `Boolean`                            | `false`      | If `true` clicking user location will show the default callout for userLocation annotation. **Note**: Apple Maps only.                                                                                                                                                                                                                                                                                                                                                                                                           |
| `showsMyLocationButton`           | `Boolean`                            | `true`       | If `false` hide the button to move map to the current user's location.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `showsPointsOfInterest`           | `Boolean`                            | `true`       | If `false` points of interest won't be displayed on the map. **Note**: Apple Maps only.                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `showsCompass`                    | `Boolean`                            | `true`       | If `false` compass won't be displayed on the map.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `showsScale`                      | `Boolean`                            | `true`       | A Boolean indicating whether the map shows scale information. **Note**: Apple Maps only.                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `showsBuildings`                  | `Boolean`                            | `true`       | A Boolean indicating whether the map displays extruded building information.                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `showsTraffic`                    | `Boolean`                            | `false`      | A Boolean value indicating whether the map displays traffic information.                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `showsIndoors`                    | `Boolean`                            | `true`       | A Boolean indicating whether indoor maps should be enabled.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `showsIndoorLevelPicker`          | `Boolean`                            | `false`      | A Boolean indicating whether indoor level picker should be enabled. **Note:** Google Maps only (either Android or iOS with `PROVIDER_GOOGLE`).                                                                                                                                                                                                                                                                                                                                                                                   |
| `zoomEnabled`                     | `Boolean`                            | `true`       | If `false` the user won't be able to pinch/zoom the map.                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `zoomTapEnabled`                  | `Boolean`                            | `true`       | If `false` the user won't be able to double tap to zoom the map. **Note:** But it will greatly decrease delay of tap gesture recognition. **Note:** Google Maps on iOS only                                                                                                                                                                                                                                                                                                                                                      |
| `zoomControlEnabled`              | `Boolean`                            | `true`       | If `false` the zoom control at the bottom right of the map won't be visible **Note:** Android only.                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `minZoomLevel`                    | `Number`                             | `0`          | Minimum zoom value for the map, must be between 0 and 20. **Note:** Deprecated on Apple Maps. Use cameraZoomRange instead.                                                                                                                                                                                                                                                                                                                                                                                                       |
| `maxZoomLevel`                    | `Number`                             | `20`         | Maximum zoom value for the map, must be between 0 and 20. **Note:** Deprecated on Apple Maps. Use cameraZoomRange instead.                                                                                                                                                                                                                                                                                                                                                                                                       |
| `rotateEnabled`                   | `Boolean`                            | `true`       | If `false` the user won't be able to pinch/rotate the map.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `scrollEnabled`                   | `Boolean`                            | `true`       | If `false` the user won't be able to change the map region being displayed.                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `scrollDuringRotateOrZoomEnabled` | `Boolean`                            | `true`       | If `false` the map will stay centered while rotating or zooming. **Note:** Google Maps only                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `pitchEnabled`                    | `Boolean`                            | `true`       | If `false` the user won't be able to adjust the cameras pitch angle.                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `toolbarEnabled`                  | `Boolean`                            | `true`       | `Android only` If `false` will hide 'Navigate' and 'Open in Maps' buttons on marker press. If you enable the toolbar, make sure to [edit your AndroidManifest.xml](https://github.com/react-native-maps/react-native-maps/issues/4403#issuecomment-1219856534)                                                                                                                                                                                                                                                                   |
| `cacheEnabled`                    | `Boolean`                            | `false`      | If `true` map will be cached and displayed as an image instead of being interactable, for performance usage. **Note:** Apple Maps only                                                                                                                                                                                                                                                                                                                                                                                           |
| `loadingEnabled`                  | `Boolean`                            | `false`      | If `true` a loading indicator will show while the map is loading.                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `loadingIndicatorColor`           | `Color`                              | `#606060`    | Sets loading indicator color, default to `#606060`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `loadingBackgroundColor`          | `Color`                              | `#FFFFFF`    | Sets loading background color, default to `#FFFFFF`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `tintColor`                       | `color`                             | `null`       | Sets the tint color of the map. (Changes the color of the position indicator) Defaults to system blue. **Note:** iOS (Apple maps) only.                                                                                                                                                                                                                                                                                                                                                                                          |
| `moveOnMarkerPress`               | `Boolean`                            | `true`       | `Android only` If `false` the map won't move when a marker is pressed.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `legalLabelInsets`                | `EdgeInsets`                         |              | If set, changes the position of the "Legal" label link from the OS default. **Note:** iOS only.                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `kmlSrc`                          | `string`                             |              | The URL from KML file. **Note:** Google Maps and Markers only (either Android or iOS with `PROVIDER_GOOGLE`).                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `compassOffset`                   | `Point`                              |              | If set, changes the position of the compass. **Note:** iOS Maps only.                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `isAccessibilityElement`          | `Boolean`                            | `false`      | Determines whether the MapView captures VoiceOver touches or forwards them to children. When `true`, map markers are not visible to VoiceOver. **Note:** iOS Maps only.                                                                                                                                                                                                                                                                                                                                                          |
| `cameraZoomRange`                 | `CameraZoomRange`                    |              | Map camera distance limits. `minCenterCoordinateDistance` for minimum distance, `maxCenterCoordinateDistance` for maximum, `animated` for animated zoom range changes. Takes precedence if conflicting with `minZoomLevel`, `maxZoomLevel`. **Note**: iOS 13.0+ only.                                                                                                                                                                                                                                                            |

## Events

To access event data, you will need to use `e.nativeEvent`. For example, `onPress={e => console.log(e.nativeEvent)}` will log the entire event object to your console.

| Event Name                | Returns                                                                  | Notes                                                                                                                                                                                                                                                                                                                                 |
| ------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `onMapReady`              |                                                                          | Callback that is called once the map is fully loaded.                                                                                                                                                                                                                                                                                 |
| `onKmlReady`              | `KmlContainer`                                                           | Callback that is called once the kml is fully loaded.                                                                                                                                                                                                                                                                                 |
| `onRegionChangeStart`     | `{ isGesture: boolean }`                                                 | Callback that is called once before the region changes, such as when the user starts moving the map. The second parameter is an object containing more details about the move. `isGesture` property indicates if the move was from the user (true) or an animation (false). **Note**: `isGesture` is supported by Google Maps only.   |
| `onRegionChange`          | (`Region`, `{isGesture: boolean}`)                                       | Callback that is called continuously when the region changes, such as when a user is dragging the map. The second parameter is an object containing more details about the move. `isGesture` property indicates if the move was from the user (true) or an animation (false). **Note**: `isGesture` is supported by Google Maps only. |
| `onRegionChangeComplete`  | (`Region`, `{isGesture: boolean}`)                                       | Callback that is called once when the region changes, such as when the user is done moving the map. The second parameter is an object containing more details about the move. `isGesture` property indicates if the move was from the user (true) or an animation (false). **Note**: `isGesture` is supported by Google Maps only.    |
| `onUserLocationChange`    | `{ coordinate: Location }`                                               | Callback that is called when the underlying map figures our users current location (coordinate also includes isFromMockProvider value for Android API 18 and above). Make sure **showsUserLocation** is set to _true_.                                                                                                                |
| `onPress`                 | `{ coordinate: LatLng, position: Point }`                                | Callback that is called when user taps on the map.                                                                                                                                                                                                                                                                                    |
| `onDoublePress`           | `{ coordinate: LatLng, position: Point }`                                | Callback that is called when user double taps on the map. **NOTE**: Not supported on Google Maps iOS                                                                                                                                                                                                                                  |
| `onPanDrag`               | `{ coordinate: LatLng, position: Point, numberOfTouches: number, }`      | Callback that is called when user presses and drags the map. **NOTE** numberOfTouches is iOS only                                                                                                                                                                                                                                     |
| `onPoiClick`              | `{ coordinate: LatLng, position: Point, placeId: string, name: string }` | Callback that is called when user click on a POI.                                                                                                                                                                                                                                                                                     |
| `onLongPress`             | `{ coordinate: LatLng, position: Point }`                                | Callback that is called when user makes a "long press" somewhere on the map.                                                                                                                                                                                                                                                          |
| `onMarkerPress`           |                                                                          | Callback that is called when a marker on the map is tapped by the user.                                                                                                                                                                                                                                                               |
| `onMarkerSelect`          |                                                                          | Callback that is called when a marker on the map becomes selected. This will be called when the callout for that marker is about to be shown.                                                                                                                                                                                         |
| `onMarkerDeselect`        |                                                                          | Callback that is called when a marker on the map becomes deselected. This will be called when the callout for that marker is about to be hidden.                                                                                                                                                                                      |
| `onCalloutPress`          |                                                                          | Callback that is called when a callout is tapped by the user.                                                                                                                                                                                                                                                                         |
| `onMarkerDragStart`       | `{ coordinate: LatLng, position: Point }`                                | Callback that is called when the user initiates a drag on a marker (if it is draggable)                                                                                                                                                                                                                                               |
| `onMarkerDrag`            | `{ coordinate: LatLng, position: Point }`                                | Callback called continuously as a marker is dragged                                                                                                                                                                                                                                                                                   |
| `onMarkerDragEnd`         | `{ coordinate: LatLng, position: Point }`                                | Callback that is called when a drag on a marker finishes. This is usually the point you will want to setState on the marker's coordinate again                                                                                                                                                                                        |
| `onIndoorLevelActivated`  | `IndoorLevel`                                                            | Callback that is called when a level on indoor building is activated                                                                                                                                                                                                                                                                  |
| `onIndoorBuildingFocused` | `IndoorBuilding`                                                         | Callback that is called when a indoor building is focused/unfocused                                                                                                                                                                                                                                                                   |

## Methods

| Method Name                 | Arguments                                                                              | Notes                                                                                                                                                             |
| --------------------------- | -------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `getCamera`                 |                                                                                        | Returns a `Promise<Camera>` structure indicating the current camera configuration.                                                                                |
| `animateCamera`             | `camera: Camera`, `{ duration: Number }`                                               | Animate the camera to a new view. You can pass a partial camera object here; any property not given will remain unmodified.                                       |
| `setCamera`                 | `camera: Camera`, `{ duration: Number }`                                               | Like `animateCamera`, but sets the new view instantly, without an animation.                                                                                      |
| `animateToRegion`           | `region: Region`, `duration: Number`                                                   |
| `getMapBoundaries`          |                                                                                        | `Promise<{northEast: LatLng, southWest: LatLng}>`                                                                                                                 |
| `setMapBoundaries`          | `northEast: LatLng`, `southWest: LatLng`                                               | The boundary is defined by the map's center coordinates, not the device's viewport itself. **Note:** Google Maps only.                                            |
| `setIndoorActiveLevelIndex` | `levelIndex: Number`                                                                   |
| `fitToElements`             | `options: { edgePadding: EdgePadding, animated: Boolean }`                             | **Note** edgePadding is Google Maps only                                                                                                                          |
| `fitToSuppliedMarkers`      | `markerIDs: String[], options: { edgePadding: EdgePadding, animated: Boolean }`        | If you need to use this in `ComponentDidMount`, make sure you put it in a timeout or it will cause performance problems. **Note** edgePadding is Google Maps only |
| `fitToCoordinates`          | `coordinates: Array<LatLng>, options: { edgePadding: EdgePadding, animated: Boolean }` | If called in `ComponentDidMount` in android, it will cause an exception. It is recommended to call it from the MapView `onLayout` event.                          |
| `addressForCoordinate`      | `coordinate: LatLng`                                                                   | Converts a map coordinate to a address (`Address`). Returns a `Promise<Address>` **Note** Not supported on Google Maps for iOS.                                   |
| `pointForCoordinate`        | `coordinate: LatLng`                                                                   | Converts a map coordinate to a view coordinate (`Point`). Returns a `Promise<Point>`.                                                                             |
| `coordinateForPoint`        | `point: Point`                                                                         | Converts a view coordinate (`Point`) to a map coordinate. Returns a `Promise<Coordinate>`.                                                                        |
| `getMarkersFrames`          | `onlyVisible: Boolean`                                                                 | Get markers' centers and frames in view coordinates. Returns a `Promise<{ "markerID" : { point: Point, frame: Frame } }>`. **Note**: iOS only.                    |

## Types

```
type Region {
  latitude: Number,
  longitude: Number,
  latitudeDelta: Number,
  longitudeDelta: Number,
}
```

```
type Camera = {
    center: {
       latitude: number,
       longitude: number,
   },
   pitch: number,
   heading: number,

   // Only on iOS MapKit, in meters. The property is ignored by Google Maps.
   altitude: number,

   // Only when using Google Maps.
   zoom: number
}
```

Latitude and longitude are self explanatory while latitudeDelta and longitudeDelta may not.
On the [developer.apple.com](https://developer.apple.com/reference/mapkit/mkcoordinatespan/1452417-latitudedelta) website this is how the "latitudeDelta" property is explained:

> The amount of north-to-south distance (measured in degrees) to display on the map. Unlike longitudinal distances, which vary based on the latitude, one degree of latitude is always approximately 111 kilometers (69 miles).

If this is not enough, you can find a [visual explanation on stackoverflow](https://stackoverflow.com/questions/36685372/how-to-zoom-in-out-in-react-native-map/36688156#36688156).

Note that when using the `Camera`, MapKit on iOS and Google Maps differ in how the height is specified. For a cross-platform app, it is necessary
to specify both the zoom level and the altitude separately.

```
type LatLng {
  latitude: Number,
  longitude: Number,
}
```

```
type Location {
  latitude: Number,
  longitude: Number,
  altitude: Number,
  timestamp: Number, //Milliseconds since Unix epoch
  accuracy: Number,
  altitudeAccuracy: Number,
  speed: Number,
}
```

```
type Point {
  x: Number,
  y: Number,
}
```

```
type Frame {
  x: Number,
  y: Number,
  width: Number,
  height: Number,
}
```

```
enum MapType : String {
  "standard",
  "satellite",
  "hybrid",
  "terrain" //Android only
}
```

```
type EdgePadding {
  top: Number,
  right: Number,
  bottom: Number,
  left: Number
}
```

```
type EdgeInsets {
  top: Number,
  left: Number,
  bottom: Number,
  right: Number
}
```

```
type Marker {
  id: String,
  coordinate: LatLng,
  title: String,
  description: String
}
```

```
type KmlContainer {
  markers: [Marker]
}
```

```
type IndoorBuilding {
  underground: boolean,
  activeLevelIndex: Number,
  levels: Array<IndoorLevel>,
}
```

```
type IndoorLevel {
  index: Number,
  name: String,
  shortName: String,
}
```

```
type Address {
  name: String,
  thoroughfare: String,
  subThoroughfare: String,
  locality: String,
  subLocality: String,
  administrativeArea: String,
  subAdministrativeArea: String,
  postalCode: String,
  countryCode: String,
  country: String,
}
```

```
type CameraZoomRange = {
  minCenterCoordinateDistance?: number;
  maxCenterCoordinateDistance?: number;
  animated?: boolean;
};
```

</file>

<file path="docs/marker.md">
# `<Marker />` Component API

## Props

| Prop                      | Type                            | Default  | Note                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ------------------------- | ------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `title`                   | `String`                        |          | The title of the marker. This is only used if the <Marker /> component has no children that are a `<Callout />`, in which case the default callout behavior will be used, which will show both the `title` and the `description`, if provided.                                                                                                                                                                                                                                                                                                                                                                                                              |
| `description`             | `String`                        |          | The description of the marker. This is only used if the <Marker /> component has no children that are a `<Callout />`, in which case the default callout behavior will be used, which will show both the `title` and the `description`, if provided.                                                                                                                                                                                                                                                                                                                                                                                                        |
| `image`                   | `ImageSource`\*                 |          | A custom image to be used as the marker's icon. Only local image resources are allowed to be used.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `icon`                    | `ImageSource`\*                 |          | Marker icon to render (equivalent to `icon` property of GMSMarker Class). Only local image resources are allowed to be used. **Note:** Google maps only!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `pinColor`                | `Color`                         |          | If no custom marker view or custom image is provided, the platform default pin will be used, which can be customized by this color. Ignored if a custom marker is being used.<br/><br/> For Android, the set of available colors is limited. Unsupported colors will fall back to red. See [#887](https://github.com/react-community/react-native-maps/issues/887) for more information.                                                                                                                                                                                                                                                                    |
| `coordinate`              | `LatLng`                        |          | The coordinate for the marker.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `centerOffset`            | `Point`                         | (0, 0)   | The offset (in points) at which to display the view.<br/><br/> By default, the center point of an annotation view is placed at the coordinate point of the associated annotation. You can use this property to reposition the annotation view as needed. This x and y offset values are measured in points. Positive offset values move the annotation view down and to the right, while negative values move it up and to the left.<br/><br/> For Google Maps, see the `anchor` prop.                                                                                                                                                                      |
| `calloutOffset`           | `Point`                         | (0, 0)   | The offset (in points) at which to place the callout bubble.<br/><br/> This property determines the additional distance by which to move the callout bubble. When this property is set to (0, 0), the anchor point of the callout bubble is placed on the top-center point of the marker views frame. Specifying positive offset values moves the callout bubble down and to the right, while specifying negative values moves it up and to the left.<br/><br/> For Google Maps, see the `calloutAnchor` prop.                                                                                                                                             |
| `anchor`                  | `Point`                         | (0.5, 1) | Sets the anchor point for the marker.<br/><br/> The anchor specifies the point in the icon image that is anchored to the marker's position on the Earth's surface.<br/><br/> The anchor point is specified in the continuous space [0.0, 1.0] x [0.0, 1.0], where (0, 0) is the top-left corner of the image, and (1, 1) is the bottom-right corner. The anchoring point in a W x H image is the nearest discrete grid point in a (W + 1) x (H + 1) grid, obtained by scaling the then rounding. For example, in a 4 x 2 image, the anchor point (0.7, 0.6) resolves to the grid point at (3, 1).<br/><br/> For MapKit on iOS, see the `centerOffset` prop. |
| `calloutAnchor`           | `Point`                         | (0.5, 0) | Specifies the point in the marker image at which to anchor the callout when it is displayed. This is specified in the same coordinate system as the anchor. See the `anchor` prop for more details.<br/><br/> The default is the top middle of the image.<br/><br/> For MapKit on iOS, see the `calloutOffset` prop.                                                                                                                                                                                                                                                                                                                                        |
| `flat`                    | `Boolean`                       | false    | Sets whether this marker should be flat against the map true or a billboard facing the camera.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `identifier`              | `String`                        |          | An identifier used to reference this marker at a later date.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `rotation`                | `Float`                         | 0        | A float number indicating marker's rotation angle, in degrees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `draggable`               | `<null>`                        |          | This is a non-value based prop. Adding this allows the marker to be draggable (re-positioned).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `tappable`                | `Boolean`                       | true     | Sets whether marker should be tappable. If set to false, the marker will not have onPress events. **Note**: iOS Google Maps only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `tracksViewChanges`       | `Boolean`                       | true     | Sets whether this marker should track changes to child views. When using a child view to create a custom marker this option determines if changes to the content will be tracked after the first render pass. This option has a performance impact so when possible it's recommended to disable it and explictly call the `redraw` method if the marker content changes.                                                                                                                                                                                                                                                                                    |
| `tracksInfoWindowChanges` | `Boolean`                       | false    | Sets whether this marker should track view changes in info window. Enabling it will let marker change content of info window after first render pass, but will lead to decreased performance, so it's recommended to disable it whenever you don't need it. **Note**: iOS Google Maps only.                                                                                                                                                                                                                                                                                                                                                                 |
| `stopPropagation`         | `Boolean`                       | false    | Sets whether this marker should propagate `onPress` events. Enabling it will stop the parent `MapView`'s `onPress` from being called. **Note**: iOS only. Android does not propagate `onPress` events. See [#1132](https://github.com/react-community/react-native-maps/issues/1132) for more information.                                                                                                                                                                                                                                                                                                                                                  |
| `opacity`                 | `Float`                         | 1.0      | The marker's opacity between 0.0 and 1.0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `isPreselected`           | `Boolean`                       | false    | When true, the marker will be pre-selected. Setting this to true allows the user to drag the marker without needing to tap on it once to focus on it. **Note**: iOS Apple Maps only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `key`                     | `String`                        |          | If no key or non-unique `key` is specified, the `<Marker />` will be reused, therefore there is an animation when the position is changed. If you want to disable the animation, add a `key` prop with a unique value like `key_${item.longitude}_${item.latitude}`. **Note**: iOS only.                                                                                                                                                                                                                                                                                                                                                                    |
| `titleVisibility`         | `visible \| hidden \| adaptive` | 'hidden' | Visibility of the title text rendered beneath Marker balloon. **Note**: iOS Apple Maps only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `subtitleVisibility`      | `visible \| hidden \| adaptive` | 'hidden' | Visibility of the subtitle text rendered beneath Marker balloon. **Note**: iOS Apple Maps only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `useLegacyPinView`        | `Boolean`                       | false    | Decide whether legacy MKPinAnnotationView or new MKMarkerAnnotationView should be used. **Note**: iOS Apple Maps only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

\* `ImageSource` [docs](https://reactnative.dev/docs/image#imagesource)

## Events

To access event data, you will need to use `e.nativeEvent`. For example, `onPress={e => console.log(e.nativeEvent)}` will log the entire event object to your console.

| Event Name       | Returns                                   | Notes                                                                                                                                             |
| ---------------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `onPress`        | `{ coordinate: LatLng, position: Point }` | Callback that is called when the user presses on the marker                                                                                       |
| `onSelect`       | `{ coordinate: LatLng, position: Point }` | Callback that is called when the user selects the marker, before the callout is shown.                                                            |
| `onDeselect`     | `{ coordinate: LatLng, position: Point }` | Callback that is called when the marker is deselected, before the callout is hidden.                                                              |
| `onCalloutPress` |                                           | Callback that is called when the user taps the callout view.                                                                                      |
| `onDragStart`    | `{ coordinate: LatLng, position: Point }` | Callback that is called when the user initiates a drag on this marker (if it is draggable)                                                        |
| `onDrag`         | `{ coordinate: LatLng, position: Point }` | Callback called continuously as the marker is dragged                                                                                             |
| `onDragEnd`      | `{ coordinate: LatLng, position: Point }` | Callback that is called when a drag on this marker finishes. This is usually the point you will want to setState on the marker's coordinate again |

## Methods

| Method Name                 | Arguments                              | Notes                                                                                                                                  |
| --------------------------- | -------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `showCallout`               |                                        | Shows the callout for this marker                                                                                                      |
| `hideCallout`               |                                        | Hides the callout for this marker                                                                                                      |
| `redrawCallout`             |                                        | Causes a redraw of the marker's callout. Useful for Google Maps on iOS. **Note**: iOS only.                                            |
| `animateMarkerToCoordinate` | `coordinate: LatLng, duration: number` | Animates marker movement. **Note**: Android only                                                                                       |
| `redraw`                    |                                        | Causes a redraw of the marker. Useful when there are updates to the marker and `tracksViewChanges` comes with a cost that is too high. |

## Types

```
type LatLng {
  latitude: Number,
  longitude: Number,
}
```

```
type Point {
  x: Number,
  y: Number,
}
```

## Children Components

Children components can be added within a Marker and rendered content will replace the marker symbol. This is a way of creating custom markers and allowing use of native SVGs.

Example:

```
<Marker ...>
 <View style={{backgroundColor: "red", padding: 10}}>
   <Text>SF</Text>
 </View>
</Marker>
```

Displaying a large number of custom markers can have a negative performance impact when tracking changes to the marker content. If displaying a large number of markers consider disabling the `tracksViewChanges` option and manually calling the `redraw` method as required.
</file>

<file path="docs/overlay.md">
# `<Overlay />` Component API

## Props

| Prop       | Type            | Default                                                                                                                                          | Note                                                                                                                      |
| ---------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| `image`    | `ImageSource`   | A custom image to be used as the overlay. Only required local image resources and uri (as for images located in the net) are allowed to be used. |
| `bounds`   | `Array<LatLng>` |                                                                                                                                                  | The coordinates for the image (bottom-left corner, top-right corner). ie.`[[lat, long], [lat, long]]`                     |
| `bearing`  | `Number `       | `0`                                                                                                                                              | `Google Maps API only` The bearing in degrees clockwise from north. Values outside the range [0, 360) will be normalized. |
| `tappable` | `Bool`          | `false`                                                                                                                                          | `Android only` Boolean to allow an overlay to be tappable and use the onPress function.                                   |
| `opacity`  | `Number`        | `1.0`                                                                                                                                            | `Google maps only` The opacity of the overlay.                                                                            |

## Events

| Event Name | Returns | Notes                                                                       |
| ---------- | ------- | --------------------------------------------------------------------------- |
| `onPress`  |         | `Android only` Callback that is called when the user presses on the overlay |

## Types

```
type LatLng = [
  latitude: Number,
  longitude: Number,
]
```

</file>

<file path="docs/polygon.md">
# `<Polygon />` Component API

## Props

| Prop              | Type                   | Default                   | Note                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ----------------- | ---------------------- | ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `coordinates`     | `Array<LatLng>`        | (Required)                | An array of coordinates to describe the polygon                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `holes`           | `Array<Array<LatLng>>` |                           | A 2d array of coordinates to describe holes of the polygon where each hole has at least 3 points.                                                                                                                                                                                                                                                                                                                                                                                 |
| `strokeWidth`     | `Number`               | `1`                       | The stroke width to use for the path.                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `strokeColor`     | `String`               | `#000`, `rgba(r,g,b,0.5)` | The stroke color to use for the path.                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `fillColor`       | `String`               | `#000`, `rgba(r,g,b,0.5)` | The fill color to use for the path.                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `lineCap`         | `String`               | `round`                   | The line cap style to apply to the open ends of the path.                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `lineJoin`        | `Array<LatLng>`        |                           | The line join style to apply to corners of the path.                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `miterLimit`      | `Number`               |                           | The limiting value that helps avoid spikes at junctions between connected line segments. The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If the ratio of the miter lengththat is, the diagonal length of the miter jointo the line thickness exceeds the miter limit, the joint is converted to a bevel join. The default miter limit is 10, which results in the conversion of miters whose angle at the joint is less than 11 degrees. |
| `geodesic`        | `Boolean`              |                           | Boolean to indicate whether to draw each segment of the line as a geodesic as opposed to straight lines on the Mercator projection. A geodesic is the shortest path between two points on the Earth's surface. The geodesic curve is constructed assuming the Earth is a sphere.                                                                                                                                                                                                  |
| `lineDashPhase`   | `Number`               | `0`                       | (iOS only) The offset (in points) at which to start drawing the dash pattern. Use this property to start drawing a dashed line partway through a segment or gap. For example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the middle of the first gap.                                                                                                                                                                                              |
| `lineDashPattern` | `Array<Number>`        | `null`                    | (iOS only) An array of numbers specifying the dash pattern to use for the path. The array contains one or more numbers that indicate the lengths (measured in points) of the line segments and gaps in the pattern. The values in the array alternate, starting with the first line segment length, followed by the first gap length, followed by the second line segment length, and so on.                                                                                      |
| `tappable`        | `Bool`                 | `false`                   | Boolean to allow a polygon to be tappable and use the onPress function.                                                                                                                                                                                                                                                                                                                                                                                                           |
| `zIndex`          | `Number`               | `0`                       | (Android Only) The order in which this polygon overlay is drawn with respect to other overlays. An overlay with a larger z-index is drawn over overlays with smaller z-indices. The order of overlays with the same z-index is arbitrary. The default zIndex is 0.                                                                                                                                                                                                                |

## Events

| Event Name | Returns | Notes                                                        |
| ---------- | ------- | ------------------------------------------------------------ |
| `onPress`  |         | Callback that is called when the user presses on the polygon |

## Types

```
type LatLng {
  latitude: Number,
  longitude: Number,
}
```

</file>

<file path="docs/polyline.md">
# `<Polyline />` Component API

## Props

| Prop              | Type            | Default                 | Note                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ----------------- | --------------- | ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `coordinates`     | `Array<LatLng>` | (Required)              | An array of coordinates to describe the polyline                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `strokeWidth`     | `Number`        | `1`                     | The stroke width to use for the path.                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `strokeColor`     | `String`        | `#000, rgba(r,g,b,0.5)` | The stroke color to use for the path.                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `strokeColors`    | `Array<String>` | `null`                  | The stroke colors to use for the path (iOS only). Must be the same length as `coordinates`.                                                                                                                                                                                                                                                                                                                                                                                       |
| `lineCap`         | `String`        | `round`                 | The line cap style to apply to the open ends of the path. Possible values are `butt`, `round` or `square`. Note: lineCap is not yet supported for GoogleMaps provider on iOS.                                                                                                                                                                                                                                                                                                     |
| `lineJoin`        | `String`        | `round`                 | The line join style to apply to corners of the path. Possible values are `miter`, `round` or `bevel`.                                                                                                                                                                                                                                                                                                                                                                             |
| `miterLimit`      | `Number`        |                         | The limiting value that helps avoid spikes at junctions between connected line segments. The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If the ratio of the miter lengththat is, the diagonal length of the miter jointo the line thickness exceeds the miter limit, the joint is converted to a bevel join. The default miter limit is 10, which results in the conversion of miters whose angle at the joint is less than 11 degrees. |
| `geodesic`        | `Boolean`       |                         | Boolean to indicate whether to draw each segment of the line as a geodesic as opposed to straight lines on the Mercator projection. A geodesic is the shortest path between two points on the Earth's surface. The geodesic curve is constructed assuming the Earth is a sphere.                                                                                                                                                                                                  |
| `lineDashPhase`   | `Number`        | `0`                     | (iOS only) The offset (in points) at which to start drawing the dash pattern. Use this property to start drawing a dashed line partway through a segment or gap. For example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the middle of the first gap.                                                                                                                                                                                              |
| `lineDashPattern` | `Array<Number>` | `null`                  | An array of numbers specifying the dash pattern to use for the path. The array contains one or more numbers that indicate the lengths (measured in points) of the line segments and gaps in the pattern. The values in the array alternate, starting with the first line segment length, followed by the first gap length, followed by the second line segment length, and so on.                                                                                                 |
| `tappable`        | `Bool`          | false                   | Boolean to allow a polyline to be tappable and use the onPress function.                                                                                                                                                                                                                                                                                                                                                                                                          |

## Events

| Event Name | Returns | Notes                                                         |
| ---------- | ------- | ------------------------------------------------------------- |
| `onPress`  |         | Callback that is called when the user presses on the polyline |

## Types

```
type LatLng {
  latitude: Number,
  longitude: Number,
}
```

## Gradient Polylines (iOS MapKit only)

Gradient polylines can be created by using the `strokeColors` prop. `strokeColors` must be an array with the same number of elements as `coordinates`.

Example:

```js
import MapView, { Polyline } from "react-native-maps";

<MapView>
  <Polyline
    coordinates={[
      { latitude: 37.8025259, longitude: -122.4351431 },
      { latitude: 37.7896386, longitude: -122.421646 },
      { latitude: 37.7665248, longitude: -122.4161628 },
      { latitude: 37.7734153, longitude: -122.4577787 },
      { latitude: 37.7948605, longitude: -122.4596065 },
      { latitude: 37.8025259, longitude: -122.4351431 },
    ]}
    strokeColor="#000" // fallback for when `strokeColors` is not supported by the map-provider
    strokeColors={[
      "#7F0000",
      "#00000000", // no color, creates a "long" gradient between the previous and next coordinate
      "#B24112",
      "#E5845C",
      "#238C23",
      "#7F0000",
    ]}
    strokeWidth={6}
  />
</MapView>;
```

</file>

<file path="docs/tiles.md">
# `<URLTile />` and `<WMSTile />`Component API

## Props

| Prop                      | Type      | Default | Note                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ------------------------- | --------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `urlTemplate`             | `String`  |         | The url template of the map tileserver. <br/><br/> (URLTile) The patterns {x} {y} {z} will be replaced at runtime. For example, http://c.tile.openstreetmap.org/{z}/{x}/{y}.png. It is also possible to refer to tiles in local filesystem with file:///top-level-directory/sub-directory/{z}/{x}/{y}.png URL-format. <br/><br/> (WMSTile) The patterns {minX} {maxX} {minY} {maxY} {width} {height} will be replaced at runtime according to EPSG:900913 specification bounding box. For example, https://demo.geo-solutions.it/geoserver/tiger/wms?service=WMS&version=1.1.0&request=GetMap&layers=tiger:poi&styles=&bbox={minX},{minY},{maxX},{maxY}&width={width}&height={height}&srs=EPSG:900913&format=image/png&transparent=true&format_options=dpi:213. |
| `minimumZ`                | `Number`  |         | The minimum zoom level for this tile overlay.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `maximumZ`                | `Number`  |         | The maximum zoom level for this tile overlay.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `maximumNativeZ`          | `Number`  |         | (Optional) The maximum native zoom level for this tile overlay i.e. the highest zoom level that the tile server provides. Tiles are auto-scaled for higher zoom levels.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `zIndex`                  | `Number`  | `-1`    | (Optional) The order in which this tile overlay is drawn with respect to other overlays. An overlay with a larger z-index is drawn over overlays with smaller z-indices. The order of overlays with the same z-index is arbitrary.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `tileSize`                | `Number`  | `256`   | (Optional) Tile size, default size is 256 (for tiles of 256 _ 256 pixels). High-res (aka 'retina') tiles are 512 (tiles of 512 _ 512 pixels).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `doubleTileSize`          | `Boolean` | `false` | (Optional) Doubles tile size from 256 to 512 utilising higher zoom levels i.e loading 4 higher zoom level tiles and combining them for one high-resolution tile. iOS does this automatically, even if it is not desirable always. NB! using this makes text labels smaller than in the original map style.                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `shouldReplaceMapContent` | `Boolean` | `false` | (iOS) Corresponds to MKTileOverlay canReplaceMapContent i.e. if true then underlying iOS basemap is not shown.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `flipY`                   | `Boolean` | `false` | (Optional)Allow tiles using the TMS coordinate system (origin bottom left) to be used, and displayed at their correct coordinates.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `tileCachePath`           | `String`  |         | (Optional) Enable caching of tiles in the specified directory. Directory can be specified either as a normal path or in URL format (`file://`). Tiles are stored in tileCachePath directory as `/{z}/{x}/{y}` i.e. in sub-directories 2-levels deep, filename is tile y-coordinate without any filetype-extension. <br/><br/>NB! All cache management needs to be implemented by client e.g. deleting tiles to manage use of storage space etc.                                                                                                                                                                                                                                                                                                                 |
| `tileCacheMaxAge`         | `Number`  |         | (Optional) Defines maximum age in seconds for a cached tile before it's refreshed. NB! Refresh logic is "serve-stale-while-refresh" i.e. to ensure map availability a stale (over max age) tile is served while a tile refresh process is started in the background.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `offlineMode`             | `Boolean` | `false` | (Optional) Sets offline-mode. In offline-mode tiles are not fetched from the tile servers, rather only tiles stored in the cache directory are used. Furthermore automated tile scaling is activated: if tile at a desired zoom level is not found from the cache directory, then lower zoom level tile is used (up to 4 levels lower) and scaled.                                                                                                                                                                                                                                                                                                                                                                                                              |
| `opacity`                 | `Number`  |         | (Optional) Map layer opacity. Value between 0 - 1, with 0 meaning fully transparent.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |

## Using tile components

Both `URLTile` and `WMSTile` components require access to a tileserver. Please note that due to overuse OpenStreetMap free tileservers do not work on Android with `URLTile` and are not recommended to be used for iOS either for other than small scale test use.

`URLTile` and `WMSTile` components both implement caching and non-caching usage modes. Non-caching is the default and uses Android and iOS default implementations for tile overlays. Non-caching means that there is no caching of map tiles in React Native Maps implementation, however both iOS and Android do some limited caching with their default implementation. Non-caching mode works well when network connectivity is good and is simple to use.

Caching mode is activated when `tileCachePath` property is defined as a valid directory where React Native app has read & write access. In caching mode any new tile fetched from the tileserver is also cached in the directory defined by `tileCachePath` property and cached version is used for any future access to the tile, which means tiles can be used also when there is no or limited network connectivity. Caching also allows pre-loading of tiles to the cache directory, enabling offline map loading functionality which is typical feature in many map applications.

NB! There is no cache size management in React Native Maps, rather developer needs to implement in JS side code some mechanism to watch the size of tile cache directory and either automatically remove old tiles or allow user to delete the tiles.

`tileCacheMaxAge` property enables automatic renewal of cached tiles. Refresh logic is "serve-stale-while-refresh" meaning that when expired (i.e. older than defined `tileCacheMaxAge`) tile is requested the old cached ("stale") tile is served while a background process is started to refresh ("update") the expired tile. Refresh logic is optimised for poor network connectivity situation / app offline-mode use: if tile is cached, user is always served a tile even if it is stale, before a tile refresh is attempted and a failure in tile refresh is not a problem as stale tile remains available. Refresh logic is "lazy" i.e. tile refresh check is only done when tile is accessed. Any other refresh logic needs to be implemented in JS side code e.g. at set time intervals checking through tiles in cache and refreshing tiles as needed.

`offlineMode` property enables mode in which only cached tiles are used, tile fetch from tileserver is not even attempted. This is useful for situations when network connectivity is poor and repeated & possibly failed attempts to fetch tiles (even with caching enabled) from tileserver would increase device power consumption. Another benefit of offline-mode is that if a requested tile is missing from the cache then lower zoom level tiles are used if available and served (after scaling). This is especially useful when user has pre-loaded an area of map for certain zoom levels, allowing user to zoom in the map to higher zoom levels than which were pre-loaded.

`maximumNativeZ` property works both in caching and non-caching mode, however it is very much recommended to be used in caching mode: it sets the highest zoom level for tiles to be fetched from the tileserver. Any higher zoom levels that `maximumNativeZ` will be created by scaling a lower zoom level tile. This will help to manage the cache size, since an increase in zoom level means 4 times as many tiles are needed as in a previous level. Depending on type of map tiles and their quality a `maximumNativeZ` set at 15 - 17 and `maximumZ` set at 18 - 20 will often give good results, allowing user to zoom in deep into the map with good enough map visual quality.
</file>

<file path="e2e/jest.config.js">
/** @type {import('@jest/types').Config.InitialOptions} */
module.exports = {
  preset: 'react-native',
  rootDir: '..',
  testMatch: ['<rootDir>/e2e/**/*.test.js'],
  testTimeout: 120000,
  maxWorkers: 1,
  globalSetup: 'detox/runners/jest/globalSetup',
  globalTeardown: 'detox/runners/jest/globalTeardown',
  reporters: ['detox/runners/jest/reporter'],
  testEnvironment: 'detox/runners/jest/testEnvironment',
  verbose: true,
};
</file>

<file path="e2e/starter.test.js">
import {by, device, element} from 'detox';

describe('Example', () => {
beforeAll(async () => {
await device.launchApp();
});

beforeEach(async () => {
await device.reloadReactNative();
});

it('should show static map', async () => {
await element(by.id('StaticMapButton')).tap();
});
});
</file>

<file path="example/android/app/src/debug/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>

    <application
        android:usesCleartextTraffic="true"
        tools:targetApi="28"
        tools:ignore="GoogleAppIndexingWarning">
        <activity android:name="com.facebook.react.devsupport.DevSettingsActivity" android:exported="false" />
    </application>

</manifest>
</file>

<file path="example/android/app/src/main/java/com/rnmshowcase/MainActivity.kt">
package com.rnmshowcase

import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate
class MainActivity : ReactActivity() {
/**
_ Returns the name of the main component registered from JavaScript. This is used to schedule
_ rendering of the component.
\*/
override fun getMainComponentName(): String = "rnmshowcase"
/**
_ Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]
_ which allows you to enable New Architecture with a single boolean flags [fabricEnabled]
\*/
override fun createReactActivityDelegate(): ReactActivityDelegate =
DefaultReactActivityDelegate(this, mainComponentName, fabricEnabled)
}
</file>

<file path="example/android/app/src/main/java/com/rnmshowcase/MainApplication.kt">
package com.rnmshowcase

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader

class MainApplication : Application(), ReactApplication {

    override val reactNativeHost: ReactNativeHost =
        object : DefaultReactNativeHost(this) {
            override fun getPackages(): List<ReactPackage> =
                PackageList(this).packages.apply {
                    // Packages that cannot be autolinked yet can be added manually here, for example:
                    // add(MyReactNativePackage())
                }

            override fun getJSMainModuleName(): String = "index"

            override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

            override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
            override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED
        }

    override val reactHost: ReactHost
        get() = getDefaultReactHost(applicationContext, reactNativeHost)

    override fun onCreate() {
        super.onCreate()
        SoLoader.init(this, OpenSourceMergedSoMapping)
        if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
            // If you opted-in for the New Architecture, we load the native entry point for this app.
            load()
        }
    }

}
</file>

<file path="example/android/app/src/main/res/drawable/rn_edit_text_material.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2014 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.

-->
<inset xmlns:android="http://schemas.android.com/apk/res/android"
       android:insetLeft="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetRight="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetTop="@dimen/abc_edit_text_inset_top_material"
       android:insetBottom="@dimen/abc_edit_text_inset_bottom_material">

    <selector>
        <!--
          This file is a copy of abc_edit_text_material (https://bit.ly/3k8fX7I).
          The item below with state_pressed="false" and state_focused="false" causes a NullPointerException.
          NullPointerException:tempt to invoke virtual method 'android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable(android.content.res.Resources)'

          <item android:state_pressed="false" android:state_focused="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>

          For more info, see https://bit.ly/3CdLStv (react-native/pull/29452) and https://bit.ly/3nxOMoR.
        -->
        <item android:state_enabled="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>
        <item android:drawable="@drawable/abc_textfield_activated_mtrl_alpha"/>
    </selector>

</inset>
</file>

<file path="example/android/app/src/main/res/values/strings.xml">
<resources>
    <string name="app_name">rnmshowcase</string>
</resources>
</file>

<file path="example/android/app/src/main/res/values/styles.xml">
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.DayNight.NoActionBar">
        <!-- Customize your theme here. -->
        <item name="android:editTextBackground">@drawable/rn_edit_text_material</item>
    </style>

</resources>
</file>

<file path="example/android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.rnmshowcase">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <application
      android:name=".MainApplication"
      android:label="@string/app_name"
      android:icon="@mipmap/ic_launcher"
      android:roundIcon="@mipmap/ic_launcher_round"
      android:allowBackup="false"
      android:theme="@style/AppTheme"
      android:supportsRtl="true">
      <activity
        android:name=".MainActivity"
        android:label="@string/app_name"
        android:configChanges="keyboard|keyboardHidden|orientation|screenLayout|screenSize|smallestScreenSize|uiMode"
        android:launchMode="singleTask"
        android:windowSoftInputMode="adjustResize"
        android:exported="true">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
      </activity>
      <meta-data
          android:name="com.google.android.geo.API_KEY"
          android:value="${MAPS_API_KEY}"/>
    </application>

</manifest>
</file>

<file path="example/android/app/_BUCK">
# To learn about Buck see [Docs](https://buckbuild.com/).
# To run your application with Buck:
# - install Buck
# - `npm start` - to start the packager
# - `cd android`
# - `keytool -genkey -v -keystore keystores/debug.keystore -storepass android -alias androiddebugkey -keypass android -dname "CN=Android Debug,O=Android,C=US"`
# - `./gradlew :app:copyDownloadableDepsToLibs` - make all Gradle compile dependencies available to Buck
# - `buck install -r android/app` - compile, install and run application
#

load(":build_defs.bzl", "create_aar_targets", "create_jar_targets")

lib_deps = []

create_aar_targets(glob(["libs/*.aar"]))

create_jar_targets(glob(["libs/*.jar"]))

android_library(
name = "all-libs",
exported_deps = lib_deps,
)

android_library(
name = "app-code",
srcs = glob([
"src/main/java/**/*.java",
]),
deps = [
":all-libs",
":build_config",
":res",
],
)

android_build_config(
name = "build_config",
package = "com.rnmshowcase",
)

android_resource(
name = "res",
package = "com.rnmshowcase",
res = "src/main/res",
)

android_binary(
name = "app",
keystore = "//android/keystores:debug",
manifest = "src/main/AndroidManifest.xml",
package_type = "debug",
deps = [
":app-code",
],
)
</file>

<file path="example/android/app/build_defs.bzl">
"""Helper definitions to glob .aar and .jar targets"""

def create_aar_targets(aarfiles):
for aarfile in aarfiles:
name = "aars\_\_" + aarfile[aarfile.rindex("/") + 1:aarfile.rindex(".aar")]
lib_deps.append(":" + name)
android_prebuilt_aar(
name = name,
aar = aarfile,
)

def create_jar_targets(jarfiles):
for jarfile in jarfiles:
name = "jars\_\_" + jarfile[jarfile.rindex("/") + 1:jarfile.rindex(".jar")]
lib_deps.append(":" + name)
prebuilt_jar(
name = name,
binary_jar = jarfile,
)
</file>

<file path="example/android/app/build.gradle">
apply plugin: "com.android.application"
apply plugin: "org.jetbrains.kotlin.android"
apply plugin: "com.facebook.react"

/\*\*

- This is the configuration block to customize your React Native Android app.
- By default you don't need to apply any configuration, just uncomment the lines you need.
  _/
  react {
  /_ Folders \*/
  // The root of your project, i.e. where "package.json" lives. Default is '../..'
  // root = file("../../")
  // The folder where the react-native NPM package is. Default is ../../node_modules/react-native
  // reactNativeDir = file("../../node_modules/react-native")
  // The folder where the react-native Codegen package is. Default is ../../node_modules/@react-native/codegen
  // codegenDir = file("../../node_modules/@react-native/codegen")
  // The cli.js file which is the React Native CLI entrypoint. Default is ../../node_modules/react-native/cli.js
  // cliFile = file("../../node_modules/react-native/cli.js")

      /* Variants */
      //   The list of variants to that are debuggable. For those we're going to
      //   skip the bundling of the JS bundle and the assets. By default is just 'debug'.
      //   If you add flavors like lite, prod, etc. you'll have to list your debuggableVariants.
      // debuggableVariants = ["liteDebug", "prodDebug"]

      /* Bundling */
      //   A list containing the node command and its flags. Default is just 'node'.
      // nodeExecutableAndArgs = ["node"]
      //
      //   The command to run when bundling. By default is 'bundle'
      // bundleCommand = "ram-bundle"
      //
      //   The path to the CLI configuration file. Default is empty.
      // bundleConfig = file(../rn-cli.config.js)
      //
      //   The name of the generated asset file containing your JS bundle
      // bundleAssetName = "MyApplication.android.bundle"
      //
      //   The entry file for bundle generation. Default is 'index.android.js' or 'index.js'
      // entryFile = file("../js/MyApplication.android.js")
      //
      //   A list of extra flags to pass to the 'bundle' commands.
      //   See https://github.com/react-native-community/cli/blob/main/docs/commands.md#bundle
      // extraPackagerArgs = []

      /* Hermes Commands */
      //   The hermes compiler command to run. By default it is 'hermesc'
      // hermesCommand = "$rootDir/my-custom-hermesc/bin/hermesc"
      //
      //   The list of flags to pass to the Hermes compiler. By default is "-O", "-output-source-map"
      // hermesFlags = ["-O", "-output-source-map"]

      /* Autolinking */
      autolinkLibrariesWithApp()

  }

/\*\*

- Set this to true to Run Proguard on Release builds to minify the Java bytecode.
  \*/
  def enableProguardInReleaseBuilds = false

/\*\*

- The preferred build flavor of JavaScriptCore (JSC)
-
- For example, to use the international variant, you can use:
- `def jscFlavor = 'org.webkit:android-jsc-intl:+'`
-
- The international variant includes ICU i18n library and necessary data
- allowing to use e.g. `Date.toLocaleString` and `String.localeCompare` that
- give correct results when using with locales other than en-US. Note that
- this variant is about 6MiB larger per architecture than default.
  \*/
  def jscFlavor = 'org.webkit:android-jsc:+'

android {
ndkVersion rootProject.ext.ndkVersion
buildToolsVersion rootProject.ext.buildToolsVersion
compileSdk rootProject.ext.compileSdkVersion

    namespace "com.rnmshowcase"
    defaultConfig {
        applicationId "com.rnmshowcase"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0"
    }
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
    }
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
        }
        release {
            // Caution! In production, you need to generate your own keystore file.
            // see https://reactnative.dev/docs/signed-apk-android.
            signingConfig signingConfigs.debug
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
        }
    }

}

dependencies {
// The version of react-native is set by the React Native Gradle Plugin
implementation("com.facebook.react:react-android")

    if (hermesEnabled.toBoolean()) {
        implementation("com.facebook.react:hermes-android")
    } else {
        implementation jscFlavor
    }

}

apply plugin: 'com.google.android.libraries.mapsplatform.secrets-gradle-plugin'
</file>

<file path="example/android/app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /usr/local/Cellar/android-sdk/24.3.3/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

</file>

<file path="example/android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="example/android/build.gradle">
buildscript {
    ext {
        buildToolsVersion = "35.0.0"
        minSdkVersion = 24
        compileSdkVersion = 35
        targetSdkVersion = 34
        ndkVersion = "26.1.10909125"
        kotlinVersion = "1.9.24"
    }
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath("com.android.tools.build:gradle")
        classpath("com.facebook.react:react-native-gradle-plugin")
        classpath("org.jetbrains.kotlin:kotlin-gradle-plugin")
        classpath("de.undercouch:gradle-download-task:5.5.0")
        classpath "com.google.android.libraries.mapsplatform.secrets-gradle-plugin:secrets-gradle-plugin:2.0.1"
    }
}

apply plugin: "com.facebook.react.rootproject"
</file>

<file path="example/android/gradle.properties">
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:

# Gradle settings configured through the IDE _will override_

# any settings specified in this file.

# For more details on how to configure your build environment visit

# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.

# The setting is particularly useful for tweaking memory settings.

# Default value: -Xmx512m -XX:MaxMetaspaceSize=256m

org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=512m

# When configured, Gradle will run in incubating parallel mode.

# This option should only be used with decoupled projects. More details, visit

# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects

# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the

# Android operating system, and which are packaged with your app's APK

# https://developer.android.com/topic/libraries/support-library/androidx-rn

android.useAndroidX=true

# Use this property to specify which architecture you want to build.

# You can also override it from the CLI using

# ./gradlew <task> -PreactNativeArchitectures=x86_64

reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64

# Use this property to enable support to the new architecture.

# This will allow you to use TurboModules and the Fabric render in

# your application. You should enable this flag either if you want

# to write custom TurboModules/Fabric components OR use libraries that

# are providing them.

newArchEnabled=true

# Use this property to enable or disable the Hermes JS engine.

# If set to false, you will be using JSC instead.

hermesEnabled=true
</file>

<file path="example/android/gradlew">
#!/bin/sh

#

# Copyright  2015-2021 the original authors.

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

# https://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.

#

# SPDX-License-Identifier: Apache-2.0

#

##############################################################################

#

# Gradle start up script for POSIX generated by Gradle.

#

# Important for running:

#

# (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is

# noncompliant, but you have some other compliant shell such as ksh or

# bash, then to run this script, type that shell name before the whole

# command line, like:

#

# ksh Gradle

#

# Busybox and similar reduced shells will NOT work, because this script

# requires all of these POSIX shell features:

# \* functions;

# \* expansions $var, ${var}, ${var:-default}, ${var+SET},

# ${var#prefix}, ${var%suffix}, and $( cmd );

# \* compound commands having a testable exit status, especially case;

# \* various built-in commands including command, set, and ulimit.

#

# Important for patching:

#

# (2) This script targets any POSIX shell, so it avoids extensions provided

# by Bash, Ksh, etc; in particular arrays are avoided.

#

# The "traditional" practice of packing multiple parameters into a

# space-separated string is a well documented source of bugs and security

# problems, so this is (mostly) avoided, by progressively accumulating

# options in "$@", and eventually passing that to Java.

#

# Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,

# and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;

# see the in-line comments for details.

#

# There are tweaks for specific operating systems such as AIX, CygWin,

# Darwin, MinGW, and NonStop.

#

# (3) This script is generated from the Groovy template

# https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt

# within the Gradle project.

#

# You can find Gradle at https://github.com/gradle/gradle/.

#

##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link

app_path=$0

# Need this for daisy-chained symlinks.

while
APP_HOME=${app_path%"${app_path##_/}"} # leaves a trailing /; empty if no leading path
[ -h "$app_path" ]
do
ls=$( ls -ld "$app_path" )
link=${ls#_' -> '}
case $link in             #(
      /*)   app_path=$link ;; #(
\*) app_path=$APP_HOME$link ;;
esac
done

# This is normally unused

# shellcheck disable=SC2034

APP_BASE_NAME=${0##\*/}

# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)

APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.

MAX_FD=maximum

warn () {
echo "$\*"
} >&2

die () {
echo
echo "$\*"
echo
exit 1
} >&2

# OS specific support (must be 'true' or 'false').

cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in #(
CYGWIN* ) cygwin=true ;; #(
Darwin* ) darwin=true ;; #(
MSYS* | MINGW* ) msys=true ;; #(
NONSTOP\* ) nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.

if [ -n "$JAVA_HOME" ] ; then
if [ -x "$JAVA_HOME/jre/sh/java" ] ; then # IBM's JDK on AIX uses strange locations for the executables
JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
fi
if [ ! -x "$JAVACMD" ] ; then
die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi
else
JAVACMD=java
if ! command -v java >/dev/null 2>&1
then
die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi
fi

# Increase the maximum file descriptors if we can.

if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
warn "Could not query maximum file descriptor limit"
esac
case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
warn "Could not set maximum file descriptor limit to $MAX_FD"
esac
fi

# Collect all arguments for the java command, stacking in reverse order:

# \* args from the command line

# \* the main class name

# \* -classpath

# \* -D...appname settings

# \* --module-path (only if needed)

# \* DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java

if "$cygwin" || "$msys" ; then
APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done

fi

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.

DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:

# \* DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,

# and any embedded shellness will be escaped.

# \* For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be

# treated as '${Hostname}' itself on the command line.

set -- \
 "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
 org.gradle.wrapper.GradleWrapperMain \
 "$@"

# Stop when "xargs" is not available.

if ! command -v xargs >/dev/null 2>&1
then
die "xargs is not available"
fi

# Use "xargs" to parse quoted args.

#

# With -n1 it outputs one arg per line, with the quotes and backslashes removed.

#

# In Bash we could simply go:

#

# readarray ARGS < <( xargs -n1 <<<"$var" ) &&

# set -- "${ARGS[@]}" "$@"

#

# but POSIX shell has neither arrays nor command substitution, so instead we

# post-process each arg (as a line of input to sed) to backslash-escape any

# character that might be a shell metacharacter, then use eval to reverse

# that process (while maintaining the separation between arguments), and wrap

# the whole thing up as a single "set" statement.

#

# This will of course break if any of these variables contains a newline or

# an unmatched quote.

#

eval "set -- $(
        printf '%s\n' "$DEFAULT*JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
xargs -n1 |
sed ' s~[^-[:alnum:]+,./:=@*]~\\&~g; ' |
tr '\n' ' '
)" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="example/android/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %\*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE*EXIT_CONSOLE if you need the \_script* return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="example/android/settings.gradle">
pluginManagement { includeBuild("../node_modules/@react-native/gradle-plugin") }
plugins { id("com.facebook.react.settings") }
extensions.configure(com.facebook.react.ReactSettingsExtension){ ex -> ex.autolinkLibrariesFromCommand() }
rootProject.name = 'rnmshowcase'
include ':app'
includeBuild('../node_modules/@react-native/gradle-plugin')
</file>

<file path="example/ios/rnmshowcase/Images.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="example/ios/rnmshowcase/Images.xcassets/Contents.json">
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="example/ios/rnmshowcase/AppDelegate.h">
#import <RCTAppDelegate.h>
#import <UIKit/UIKit.h>

@interface AppDelegate : RCTAppDelegate

@property (nonatomic, strong) UIWindow \*window;

@end
</file>

<file path="example/ios/rnmshowcase/AppDelegate.mm">
#import "AppDelegate.h"

#import <React/RCTBundleURLProvider.h>
#import <GoogleMaps/GoogleMaps.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication _)application didFinishLaunchingWithOptions:(NSDictionary _)launchOptions
  {
  [GMSServices provideAPIKey:[[NSBundle mainBundle] objectForInfoDictionaryKey:@"MAPS_API_KEY"]];
  self.moduleName = @"rnmshowcase";

  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
  }

- (NSURL _)sourceURLForBridge:(RCTBridge _)bridge
  {
  return [self bundleURL];
  }

- (NSURL \*)bundleURL
  {
  #if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
  #else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
  #endif
  }

@end
</file>

<file path="example/ios/rnmshowcase/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleDisplayName</key>
	<string>rnmshowcase</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>MAPS_API_KEY</key>
	<string>$(MAPS_API_KEY)</string>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSAllowsArbitraryLoads</key>
		<false/>
		<key>NSAllowsLocalNetworking</key>
		<true/>
	</dict>
	<key>NSLocationWhenInUseUsageDescription</key>
	<string></string>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>arm64</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UIUserInterfaceStyle</key>
	<string>Light</string>
	<key>UIViewControllerBasedStatusBarAppearance</key>
	<false/>
</dict>
</plist>
</file>

<file path="example/ios/rnmshowcase/LaunchScreen.storyboard">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="15702" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina4_7" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="15704"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <label opaque="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="rnmshowcase" textAlignment="center" lineBreakMode="middleTruncation" baselineAdjustment="alignBaselines" minimumFontSize="18" translatesAutoresizingMaskIntoConstraints="NO" id="GJd-Yh-RWb">
                                <rect key="frame" x="0.0" y="202" width="375" height="43"/>
                                <fontDescription key="fontDescription" type="boldSystem" pointSize="36"/>
                                <nil key="highlightedColor"/>
                            </label>
                            <label opaque="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="Powered by React Native" textAlignment="center" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" minimumFontSize="9" translatesAutoresizingMaskIntoConstraints="NO" id="MN2-I3-ftu">
                                <rect key="frame" x="0.0" y="626" width="375" height="21"/>
                                <fontDescription key="fontDescription" type="system" pointSize="17"/>
                                <nil key="highlightedColor"/>
                            </label>
                        </subviews>
                        <color key="backgroundColor" systemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                        <constraints>
                            <constraint firstItem="Bcu-3y-fUS" firstAttribute="bottom" secondItem="MN2-I3-ftu" secondAttribute="bottom" constant="20" id="OZV-Vh-mqD"/>
                            <constraint firstItem="Bcu-3y-fUS" firstAttribute="centerX" secondItem="GJd-Yh-RWb" secondAttribute="centerX" id="Q3B-4B-g5h"/>
                            <constraint firstItem="MN2-I3-ftu" firstAttribute="centerX" secondItem="Bcu-3y-fUS" secondAttribute="centerX" id="akx-eg-2ui"/>
                            <constraint firstItem="MN2-I3-ftu" firstAttribute="leading" secondItem="Bcu-3y-fUS" secondAttribute="leading" id="i1E-0Y-4RG"/>
                            <constraint firstItem="GJd-Yh-RWb" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="bottom" multiplier="1/3" constant="1" id="moa-c2-u7t"/>
                            <constraint firstItem="GJd-Yh-RWb" firstAttribute="leading" secondItem="Bcu-3y-fUS" secondAttribute="leading" symbolic="YES" id="x7j-FC-K8j"/>
                        </constraints>
                        <viewLayoutGuide key="safeArea" id="Bcu-3y-fUS"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="52.173913043478265" y="375"/>
        </scene>
    </scenes>
</document>
</file>

<file path="example/ios/rnmshowcase/main.m">
#import <UIKit/UIKit.h>

#import "AppDelegate.h"

int main(int argc, char \*argv[])
{
@autoreleasepool {
return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
}
}
</file>

<file path="example/ios/rnmshowcase/PrivacyInfo.xcprivacy">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSPrivacyAccessedAPITypes</key>
	<array>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategoryFileTimestamp</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>C617.1</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategoryUserDefaults</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>CA92.1</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategorySystemBootTime</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>35F9.1</string>
			</array>
		</dict>
	</array>
	<key>NSPrivacyCollectedDataTypes</key>
	<array/>
	<key>NSPrivacyTracking</key>
	<false/>
</dict>
</plist>
</file>

<file path="example/ios/rnmshowcase.xcodeproj/xcshareddata/xcschemes/rnmshowcase.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1210"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
               BuildableName = "rnmshowcase.app"
               BlueprintName = "rnmshowcase"
               ReferencedContainer = "container:rnmshowcase.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
         <TestableReference
            skipped = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "00E356ED1AD99517003FC87E"
               BuildableName = "rnmshowcaseTests.xctest"
               BlueprintName = "rnmshowcaseTests"
               ReferencedContainer = "container:rnmshowcase.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "rnmshowcase.app"
            BlueprintName = "rnmshowcase"
            ReferencedContainer = "container:rnmshowcase.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "rnmshowcase.app"
            BlueprintName = "rnmshowcase"
            ReferencedContainer = "container:rnmshowcase.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="example/ios/rnmshowcase.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/_ Begin PBXBuildFile section _/
00E356F31AD99517003FC87E /_ rnmshowcaseTests.m in Sources _/ = {isa = PBXBuildFile; fileRef = 00E356F21AD99517003FC87E /_ rnmshowcaseTests.m _/; };
13B07FBC1A68108700A75B9A /_ AppDelegate.mm in Sources _/ = {isa = PBXBuildFile; fileRef = 13B07FB01A68108700A75B9A /_ AppDelegate.mm _/; };
13B07FBF1A68108700A75B9A /_ Images.xcassets in Resources _/ = {isa = PBXBuildFile; fileRef = 13B07FB51A68108700A75B9A /_ Images.xcassets _/; };
13B07FC11A68108700A75B9A /_ main.m in Sources _/ = {isa = PBXBuildFile; fileRef = 13B07FB71A68108700A75B9A /_ main.m _/; };
231400E32E29A085D951F35D /_ PrivacyInfo.xcprivacy in Resources _/ = {isa = PBXBuildFile; fileRef = BC9118EBBCFB2F7F115A78AF /_ PrivacyInfo.xcprivacy _/; };
4C29620DC97E48BF112C778F /_ libPods-rnmshowcase-rnmshowcaseTests.a in Frameworks _/ = {isa = PBXBuildFile; fileRef = B3DB5BD1D8514761EF76DF81 /_ libPods-rnmshowcase-rnmshowcaseTests.a _/; };
81AB9BB82411601600AC10FF /_ LaunchScreen.storyboard in Resources _/ = {isa = PBXBuildFile; fileRef = 81AB9BB72411601600AC10FF /_ LaunchScreen.storyboard _/; };
E488AD8C7A4525666DB1123D /_ libPods-rnmshowcase.a in Frameworks _/ = {isa = PBXBuildFile; fileRef = 37D3C620F2B4F795C66DA8FC /_ libPods-rnmshowcase.a _/; };
/_ End PBXBuildFile section _/

/_ Begin PBXContainerItemProxy section _/
00E356F41AD99517003FC87E /_ PBXContainerItemProxy _/ = {
isa = PBXContainerItemProxy;
containerPortal = 83CBB9F71A601CBA00E9B192 /_ Project object _/;
proxyType = 1;
remoteGlobalIDString = 13B07F861A680F5B00A75B9A;
remoteInfo = rnmshowcase;
};
/_ End PBXContainerItemProxy section _/

/_ Begin PBXFileReference section _/
00E356EE1AD99517003FC87E /_ rnmshowcaseTests.xctest _/ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = rnmshowcaseTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
00E356F11AD99517003FC87E /_ Info.plist _/ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
00E356F21AD99517003FC87E /_ rnmshowcaseTests.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = rnmshowcaseTests.m; sourceTree = "<group>"; };
13B07F961A680F5B00A75B9A /_ rnmshowcase.app _/ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = rnmshowcase.app; sourceTree = BUILT_PRODUCTS_DIR; };
13B07FAF1A68108700A75B9A /_ AppDelegate.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AppDelegate.h; path = rnmshowcase/AppDelegate.h; sourceTree = "<group>"; };
13B07FB01A68108700A75B9A /_ AppDelegate.mm _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = AppDelegate.mm; path = rnmshowcase/AppDelegate.mm; sourceTree = "<group>"; };
13B07FB51A68108700A75B9A /_ Images.xcassets _/ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Images.xcassets; path = rnmshowcase/Images.xcassets; sourceTree = "<group>"; };
13B07FB61A68108700A75B9A /_ Info.plist _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = Info.plist; path = rnmshowcase/Info.plist; sourceTree = "<group>"; };
13B07FB71A68108700A75B9A /_ main.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = main.m; path = rnmshowcase/main.m; sourceTree = "<group>"; };
13B07FB81A68108700A75B9A /_ PrivacyInfo.xcprivacy _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = PrivacyInfo.xcprivacy; path = RnDiffApp/PrivacyInfo.xcprivacy; sourceTree = "<group>"; };
37D3C620F2B4F795C66DA8FC /_ libPods-rnmshowcase.a _/ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = "libPods-rnmshowcase.a"; sourceTree = BUILT_PRODUCTS_DIR; };
3DCD38C83286E8B07C078CFA /_ Pods-rnmshowcase.release.xcconfig _/ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-rnmshowcase.release.xcconfig"; path = "Target Support Files/Pods-rnmshowcase/Pods-rnmshowcase.release.xcconfig"; sourceTree = "<group>"; };
41E150966890F2E6247E9E4F /_ Pods-rnmshowcase-rnmshowcaseTests.debug.xcconfig _/ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-rnmshowcase-rnmshowcaseTests.debug.xcconfig"; path = "Target Support Files/Pods-rnmshowcase-rnmshowcaseTests/Pods-rnmshowcase-rnmshowcaseTests.debug.xcconfig"; sourceTree = "<group>"; };
81AB9BB72411601600AC10FF /_ LaunchScreen.storyboard _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; name = LaunchScreen.storyboard; path = rnmshowcase/LaunchScreen.storyboard; sourceTree = "<group>"; };
8A910C563A7AD321B2AB6712 /_ Pods-rnmshowcase-rnmshowcaseTests.release.xcconfig _/ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-rnmshowcase-rnmshowcaseTests.release.xcconfig"; path = "Target Support Files/Pods-rnmshowcase-rnmshowcaseTests/Pods-rnmshowcase-rnmshowcaseTests.release.xcconfig"; sourceTree = "<group>"; };
B3DB5BD1D8514761EF76DF81 /_ libPods-rnmshowcase-rnmshowcaseTests.a _/ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = "libPods-rnmshowcase-rnmshowcaseTests.a"; sourceTree = BUILT_PRODUCTS_DIR; };
BC9118EBBCFB2F7F115A78AF /_ PrivacyInfo.xcprivacy _/ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xml; name = PrivacyInfo.xcprivacy; path = rnmshowcase/PrivacyInfo.xcprivacy; sourceTree = "<group>"; };
C5B6C2B3A7189624E2CE5850 /_ Pods-rnmshowcase.debug.xcconfig _/ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-rnmshowcase.debug.xcconfig"; path = "Target Support Files/Pods-rnmshowcase/Pods-rnmshowcase.debug.xcconfig"; sourceTree = "<group>"; };
ED297162215061F000B7C4FE /_ JavaScriptCore.framework _/ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = JavaScriptCore.framework; path = System/Library/Frameworks/JavaScriptCore.framework; sourceTree = SDKROOT; };
/_ End PBXFileReference section _/

/_ Begin PBXFrameworksBuildPhase section _/
00E356EB1AD99517003FC87E /_ Frameworks _/ = {
isa = PBXFrameworksBuildPhase;
buildActionMask = 2147483647;
files = (
4C29620DC97E48BF112C778F /_ libPods-rnmshowcase-rnmshowcaseTests.a in Frameworks _/,
);
runOnlyForDeploymentPostprocessing = 0;
};
13B07F8C1A680F5B00A75B9A /_ Frameworks _/ = {
isa = PBXFrameworksBuildPhase;
buildActionMask = 2147483647;
files = (
E488AD8C7A4525666DB1123D /_ libPods-rnmshowcase.a in Frameworks _/,
);
runOnlyForDeploymentPostprocessing = 0;
};
/_ End PBXFrameworksBuildPhase section _/

/_ Begin PBXGroup section _/
00E356EF1AD99517003FC87E /_ rnmshowcaseTests _/ = {
isa = PBXGroup;
children = (
00E356F21AD99517003FC87E /_ rnmshowcaseTests.m _/,
00E356F01AD99517003FC87E /_ Supporting Files _/,
);
path = rnmshowcaseTests;
sourceTree = "<group>";
};
00E356F01AD99517003FC87E /_ Supporting Files _/ = {
isa = PBXGroup;
children = (
00E356F11AD99517003FC87E /_ Info.plist _/,
);
name = "Supporting Files";
sourceTree = "<group>";
};
13B07FAE1A68108700A75B9A /_ rnmshowcase _/ = {
isa = PBXGroup;
children = (
13B07FAF1A68108700A75B9A /_ AppDelegate.h _/,
13B07FB01A68108700A75B9A /_ AppDelegate.mm _/,
13B07FB51A68108700A75B9A /_ Images.xcassets _/,
13B07FB61A68108700A75B9A /_ Info.plist _/,
81AB9BB72411601600AC10FF /_ LaunchScreen.storyboard _/,
13B07FB71A68108700A75B9A /_ main.m _/,
13B07FB81A68108700A75B9A /_ PrivacyInfo.xcprivacy _/,
BC9118EBBCFB2F7F115A78AF /_ PrivacyInfo.xcprivacy _/,
);
name = rnmshowcase;
sourceTree = "<group>";
};
2D16E6871FA4F8E400B85C8A /_ Frameworks _/ = {
isa = PBXGroup;
children = (
ED297162215061F000B7C4FE /_ JavaScriptCore.framework _/,
37D3C620F2B4F795C66DA8FC /_ libPods-rnmshowcase.a _/,
B3DB5BD1D8514761EF76DF81 /_ libPods-rnmshowcase-rnmshowcaseTests.a _/,
);
name = Frameworks;
sourceTree = "<group>";
};
832341AE1AAA6A7D00B99B32 /_ Libraries _/ = {
isa = PBXGroup;
children = (
);
name = Libraries;
sourceTree = "<group>";
};
83CBB9F61A601CBA00E9B192 = {
isa = PBXGroup;
children = (
13B07FAE1A68108700A75B9A /_ rnmshowcase _/,
832341AE1AAA6A7D00B99B32 /_ Libraries _/,
00E356EF1AD99517003FC87E /_ rnmshowcaseTests _/,
83CBBA001A601CBA00E9B192 /_ Products _/,
2D16E6871FA4F8E400B85C8A /_ Frameworks _/,
BBD78D7AC51CEA395F1C20DB /_ Pods _/,
);
indentWidth = 2;
sourceTree = "<group>";
tabWidth = 2;
usesTabs = 0;
};
83CBBA001A601CBA00E9B192 /_ Products _/ = {
isa = PBXGroup;
children = (
13B07F961A680F5B00A75B9A /_ rnmshowcase.app _/,
00E356EE1AD99517003FC87E /_ rnmshowcaseTests.xctest _/,
);
name = Products;
sourceTree = "<group>";
};
BBD78D7AC51CEA395F1C20DB /_ Pods _/ = {
isa = PBXGroup;
children = (
C5B6C2B3A7189624E2CE5850 /_ Pods-rnmshowcase.debug.xcconfig _/,
3DCD38C83286E8B07C078CFA /_ Pods-rnmshowcase.release.xcconfig _/,
41E150966890F2E6247E9E4F /_ Pods-rnmshowcase-rnmshowcaseTests.debug.xcconfig _/,
8A910C563A7AD321B2AB6712 /_ Pods-rnmshowcase-rnmshowcaseTests.release.xcconfig _/,
);
path = Pods;
sourceTree = "<group>";
};
/_ End PBXGroup section _/

/_ Begin PBXNativeTarget section _/
00E356ED1AD99517003FC87E /_ rnmshowcaseTests _/ = {
isa = PBXNativeTarget;
buildConfigurationList = 00E357021AD99517003FC87E /_ Build configuration list for PBXNativeTarget "rnmshowcaseTests" _/;
buildPhases = (
6BB2B4F88862047370DBEC4E /_ [CP] Check Pods Manifest.lock _/,
00E356EA1AD99517003FC87E /_ Sources _/,
00E356EB1AD99517003FC87E /_ Frameworks _/,
00E356EC1AD99517003FC87E /_ Resources _/,
4BB5BDEB3BB3351A69AAFD04 /_ [CP] Embed Pods Frameworks _/,
7149723BEA52900493758BCB /_ [CP] Copy Pods Resources _/,
);
buildRules = (
);
dependencies = (
00E356F51AD99517003FC87E /_ PBXTargetDependency _/,
);
name = rnmshowcaseTests;
productName = rnmshowcaseTests;
productReference = 00E356EE1AD99517003FC87E /_ rnmshowcaseTests.xctest _/;
productType = "com.apple.product-type.bundle.unit-test";
};
13B07F861A680F5B00A75B9A /_ rnmshowcase _/ = {
isa = PBXNativeTarget;
buildConfigurationList = 13B07F931A680F5B00A75B9A /_ Build configuration list for PBXNativeTarget "rnmshowcase" _/;
buildPhases = (
EB2F1A58A44FE0FDC95046A9 /_ [CP] Check Pods Manifest.lock _/,
FD10A7F022414F080027D42C /_ Start Packager _/,
13B07F871A680F5B00A75B9A /_ Sources _/,
13B07F8C1A680F5B00A75B9A /_ Frameworks _/,
13B07F8E1A680F5B00A75B9A /_ Resources _/,
00DD1BFF1BD5951E006B06BC /_ Bundle React Native code and images _/,
7178DD5CCC1BA4C10BC1338D /_ [CP] Embed Pods Frameworks _/,
2FEBF6F3E6705F77B8AE9357 /_ [CP] Copy Pods Resources _/,
);
buildRules = (
);
dependencies = (
);
name = rnmshowcase;
productName = rnmshowcase;
productReference = 13B07F961A680F5B00A75B9A /_ rnmshowcase.app _/;
productType = "com.apple.product-type.application";
};
/_ End PBXNativeTarget section _/

/_ Begin PBXProject section _/
83CBB9F71A601CBA00E9B192 /_ Project object _/ = {
isa = PBXProject;
attributes = {
LastUpgradeCheck = 1210;
TargetAttributes = {
00E356ED1AD99517003FC87E = {
CreatedOnToolsVersion = 6.2;
TestTargetID = 13B07F861A680F5B00A75B9A;
};
13B07F861A680F5B00A75B9A = {
LastSwiftMigration = 1120;
};
};
};
buildConfigurationList = 83CBB9FA1A601CBA00E9B192 /_ Build configuration list for PBXProject "rnmshowcase" _/;
compatibilityVersion = "Xcode 12.0";
developmentRegion = en;
hasScannedForEncodings = 0;
knownRegions = (
en,
Base,
);
mainGroup = 83CBB9F61A601CBA00E9B192;
productRefGroup = 83CBBA001A601CBA00E9B192 /_ Products _/;
projectDirPath = "";
projectRoot = "";
targets = (
13B07F861A680F5B00A75B9A /_ rnmshowcase _/,
00E356ED1AD99517003FC87E /_ rnmshowcaseTests _/,
);
};
/_ End PBXProject section _/

/_ Begin PBXResourcesBuildPhase section _/
00E356EC1AD99517003FC87E /_ Resources _/ = {
isa = PBXResourcesBuildPhase;
buildActionMask = 2147483647;
files = (
);
runOnlyForDeploymentPostprocessing = 0;
};
13B07F8E1A680F5B00A75B9A /_ Resources _/ = {
isa = PBXResourcesBuildPhase;
buildActionMask = 2147483647;
files = (
81AB9BB82411601600AC10FF /_ LaunchScreen.storyboard in Resources _/,
13B07FBF1A68108700A75B9A /_ Images.xcassets in Resources _/,
231400E32E29A085D951F35D /_ PrivacyInfo.xcprivacy in Resources _/,
);
runOnlyForDeploymentPostprocessing = 0;
};
/_ End PBXResourcesBuildPhase section _/

/_ Begin PBXShellScriptBuildPhase section _/
00DD1BFF1BD5951E006B06BC /_ Bundle React Native code and images _/ = {
isa = PBXShellScriptBuildPhase;
buildActionMask = 2147483647;
files = (
);
inputPaths = (
"$(SRCROOT)/.xcode.env.local",
				"$(SRCROOT)/.xcode.env",
);
name = "Bundle React Native code and images";
outputPaths = (
);
runOnlyForDeploymentPostprocessing = 0;
shellPath = /bin/sh;
shellScript = "set -e\n\nWITH_ENVIRONMENT=\"$REACT_NATIVE_PATH/scripts/xcode/with-environment.sh\"\nREACT_NATIVE_XCODE=\"$REACT_NATIVE_PATH/scripts/react-native-xcode.sh\"\n\n/bin/sh -c \"$WITH_ENVIRONMENT $REACT_NATIVE_XCODE\"\n";
		};
		2FEBF6F3E6705F77B8AE9357 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase/Pods-rnmshowcase-resources-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Copy Pods Resources";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase/Pods-rnmshowcase-resources-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase/Pods-rnmshowcase-resources.sh\"\n";
showEnvVarsInLog = 0;
};
4BB5BDEB3BB3351A69AAFD04 /_ [CP] Embed Pods Frameworks _/ = {
isa = PBXShellScriptBuildPhase;
buildActionMask = 2147483647;
files = (
);
inputFileListPaths = (
"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase-rnmshowcaseTests/Pods-rnmshowcase-rnmshowcaseTests-frameworks-${CONFIGURATION}-input-files.xcfilelist",
);
name = "[CP] Embed Pods Frameworks";
outputFileListPaths = (
"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase-rnmshowcaseTests/Pods-rnmshowcase-rnmshowcaseTests-frameworks-${CONFIGURATION}-output-files.xcfilelist",
);
runOnlyForDeploymentPostprocessing = 0;
shellPath = /bin/sh;
shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase-rnmshowcaseTests/Pods-rnmshowcase-rnmshowcaseTests-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
		6BB2B4F88862047370DBEC4E /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-rnmshowcase-rnmshowcaseTests-checkManifestLockResult.txt",
);
runOnlyForDeploymentPostprocessing = 0;
shellPath = /bin/sh;
shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n # print error to STDERR\n echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		7149723BEA52900493758BCB /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase-rnmshowcaseTests/Pods-rnmshowcase-rnmshowcaseTests-resources-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Copy Pods Resources";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase-rnmshowcaseTests/Pods-rnmshowcase-rnmshowcaseTests-resources-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase-rnmshowcaseTests/Pods-rnmshowcase-rnmshowcaseTests-resources.sh\"\n";
showEnvVarsInLog = 0;
};
7178DD5CCC1BA4C10BC1338D /_ [CP] Embed Pods Frameworks _/ = {
isa = PBXShellScriptBuildPhase;
buildActionMask = 2147483647;
files = (
);
inputFileListPaths = (
"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase/Pods-rnmshowcase-frameworks-${CONFIGURATION}-input-files.xcfilelist",
);
name = "[CP] Embed Pods Frameworks";
outputFileListPaths = (
"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase/Pods-rnmshowcase-frameworks-${CONFIGURATION}-output-files.xcfilelist",
);
runOnlyForDeploymentPostprocessing = 0;
shellPath = /bin/sh;
shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-rnmshowcase/Pods-rnmshowcase-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
		EB2F1A58A44FE0FDC95046A9 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-rnmshowcase-checkManifestLockResult.txt",
);
runOnlyForDeploymentPostprocessing = 0;
shellPath = /bin/sh;
shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n # print error to STDERR\n echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		FD10A7F022414F080027D42C /* Start Packager */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			name = "Start Packager";
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "export RCT_METRO_PORT=\"${RCT_METRO_PORT:=8081}\"\necho \"export RCT_METRO_PORT=${RCT_METRO_PORT}\" > \"${SRCROOT}/../node_modules/react-native/scripts/.packager.env\"\nif [ -z \"${RCT_NO_LAUNCH_PACKAGER+xxx}\" ] ; then\n if nc -w 5 -z localhost ${RCT_METRO_PORT} ; then\n    if ! curl -s \"http://localhost:${RCT_METRO_PORT}/status\" | grep -q \"packager-status:running\" ; then\n echo \"Port ${RCT_METRO_PORT} already in use, packager is either not running or not running correctly\"\n      exit 2\n    fi\n  else\n    open \"$SRCROOT/../node_modules/react-native/scripts/launchPackager.command\" || echo \"Can't start packager automatically\"\n fi\nfi\n";
showEnvVarsInLog = 0;
};
/_ End PBXShellScriptBuildPhase section _/

/_ Begin PBXSourcesBuildPhase section _/
00E356EA1AD99517003FC87E /_ Sources _/ = {
isa = PBXSourcesBuildPhase;
buildActionMask = 2147483647;
files = (
00E356F31AD99517003FC87E /_ rnmshowcaseTests.m in Sources _/,
);
runOnlyForDeploymentPostprocessing = 0;
};
13B07F871A680F5B00A75B9A /_ Sources _/ = {
isa = PBXSourcesBuildPhase;
buildActionMask = 2147483647;
files = (
13B07FBC1A68108700A75B9A /_ AppDelegate.mm in Sources _/,
13B07FC11A68108700A75B9A /_ main.m in Sources _/,
);
runOnlyForDeploymentPostprocessing = 0;
};
/_ End PBXSourcesBuildPhase section _/

/_ Begin PBXTargetDependency section _/
00E356F51AD99517003FC87E /_ PBXTargetDependency _/ = {
isa = PBXTargetDependency;
target = 13B07F861A680F5B00A75B9A /_ rnmshowcase _/;
targetProxy = 00E356F41AD99517003FC87E /_ PBXContainerItemProxy _/;
};
/_ End PBXTargetDependency section _/

/_ Begin XCBuildConfiguration section _/
00E356F61AD99517003FC87E /_ Debug _/ = {
isa = XCBuildConfiguration;
baseConfigurationReference = 41E150966890F2E6247E9E4F /_ Pods-rnmshowcase-rnmshowcaseTests.debug.xcconfig _/;
buildSettings = {
BUNDLE_LOADER = "$(TEST_HOST)";
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
);
INFOPLIST_FILE = rnmshowcaseTests/Info.plist;
IPHONEOS_DEPLOYMENT_TARGET = 12.4;
LD_RUNPATH_SEARCH_PATHS = (
"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				OTHER_LDFLAGS = (
					"-ObjC",
					"-lc++",
					"$(inherited)",
);
PRODUCT_BUNDLE_IDENTIFIER = "org.reactjs.native.example.$(PRODUCT_NAME:rfc1034identifier)";
				PRODUCT_NAME = "$(TARGET_NAME)";
TEST_HOST = "$(BUILT_PRODUCTS_DIR)/rnmshowcase.app/rnmshowcase";
			};
			name = Debug;
		};
		00E356F71AD99517003FC87E /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 8A910C563A7AD321B2AB6712 /* Pods-rnmshowcase-rnmshowcaseTests.release.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
COPY_PHASE_STRIP = NO;
INFOPLIST_FILE = rnmshowcaseTests/Info.plist;
IPHONEOS_DEPLOYMENT_TARGET = 12.4;
LD_RUNPATH_SEARCH_PATHS = (
"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				OTHER_LDFLAGS = (
					"-ObjC",
					"-lc++",
					"$(inherited)",
);
PRODUCT_BUNDLE_IDENTIFIER = "org.reactjs.native.example.$(PRODUCT_NAME:rfc1034identifier)";
				PRODUCT_NAME = "$(TARGET_NAME)";
TEST_HOST = "$(BUILT_PRODUCTS_DIR)/rnmshowcase.app/rnmshowcase";
			};
			name = Release;
		};
		13B07F941A680F5B00A75B9A /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = C5B6C2B3A7189624E2CE5850 /* Pods-rnmshowcase.debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 9QXDAES5A8;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = rnmshowcase/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 13.4;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
"@executable_path/Frameworks",
);
OTHER_LDFLAGS = (
"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "salah-ghanim.reactjs.native.example.--PRODUCT-NAME-rfc1034identifier-";
				"PRODUCT_BUNDLE_IDENTIFIER[sdk=iphoneos*]" = "salah-ghanim.native.example.rnmshowcases";
				PRODUCT_NAME = rnmshowcase;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		13B07F951A680F5B00A75B9A /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 3DCD38C83286E8B07C078CFA /* Pods-rnmshowcase.release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 9QXDAES5A8;
				INFOPLIST_FILE = rnmshowcase/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 13.4;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
"@executable_path/Frameworks",
);
OTHER_LDFLAGS = (
"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "org.reactjs.native.example.$(PRODUCT_NAME:rfc1034identifier)";
"PRODUCT_BUNDLE_IDENTIFIER[sdk=iphoneos*]" = org.reactjs.native.example.rnmshowcases;
PRODUCT_NAME = rnmshowcase;
SWIFT_VERSION = 5.0;
VERSIONING_SYSTEM = "apple-generic";
};
name = Release;
};
83CBBA201A601CBA00E9B192 /_ Debug _/ = {
isa = XCBuildConfiguration;
buildSettings = {
ALWAYS_SEARCH_USER_PATHS = NO;
CC = "";
CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
CLANG_CXX_LANGUAGE_STANDARD = "c++20";
CLANG_CXX_LIBRARY = "libc++";
CLANG_ENABLE_MODULES = YES;
CLANG_ENABLE_OBJC_ARC = YES;
CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
CLANG_WARN_BOOL_CONVERSION = YES;
CLANG_WARN_COMMA = YES;
CLANG_WARN_CONSTANT_CONVERSION = YES;
CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
CLANG_WARN_EMPTY_BODY = YES;
CLANG_WARN_ENUM_CONVERSION = YES;
CLANG_WARN_INFINITE_RECURSION = YES;
CLANG_WARN_INT_CONVERSION = YES;
CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
CLANG_WARN_STRICT_PROTOTYPES = YES;
CLANG_WARN_SUSPICIOUS_MOVE = YES;
CLANG_WARN_UNREACHABLE_CODE = YES;
CLANG_WARN**DUPLICATE_METHOD_MATCH = YES;
"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
COPY_PHASE_STRIP = NO;
CXX = "";
ENABLE_STRICT_OBJC_MSGSEND = YES;
ENABLE_TESTABILITY = YES;
"EXCLUDED_ARCHS[sdk=iphonesimulator*]" = i386;
GCC_C_LANGUAGE_STANDARD = gnu99;
GCC_DYNAMIC_NO_PIC = NO;
GCC_NO_COMMON_BLOCKS = YES;
GCC_OPTIMIZATION_LEVEL = 0;
GCC_PREPROCESSOR_DEFINITIONS = (
"DEBUG=1",
"$(inherited)",
				);
				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				HEADER_SEARCH_PATHS = (
					"$(inherited)",
"${PODS_CONFIGURATION_BUILD_DIR}/ReactCommon/ReactCommon.framework/Headers",
					"${PODS_CONFIGURATION_BUILD_DIR}/ReactCommon/ReactCommon.framework/Headers/react/nativemodule/core",
"${PODS_CONFIGURATION_BUILD_DIR}/ReactCommon-Samples/ReactCommon_Samples.framework/Headers",
					"${PODS_CONFIGURATION_BUILD_DIR}/ReactCommon-Samples/ReactCommon_Samples.framework/Headers/platform/ios",
"${PODS_CONFIGURATION_BUILD_DIR}/React-Fabric/React_Fabric.framework/Headers/react/renderer/components/view/platform/cxx",
					"${PODS_CONFIGURATION_BUILD_DIR}/React-NativeModulesApple/React_NativeModulesApple.framework/Headers",
"${PODS_CONFIGURATION_BUILD_DIR}/React-graphics/React_graphics.framework/Headers",
					"${PODS_CONFIGURATION_BUILD_DIR}/React-graphics/React_graphics.framework/Headers/react/renderer/graphics/platform/ios",
);
IPHONEOS_DEPLOYMENT_TARGET = 12.4;
LD = "";
LDPLUSPLUS = "";
LD_RUNPATH_SEARCH_PATHS = (
/usr/lib/swift,
"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = (
					"\"$(SDKROOT)/usr/lib/swift\"",
"\"$(TOOLCHAIN_DIR)/usr/lib/swift/$(PLATFORM_NAME)\"",
"\"$(inherited)\"",
				);
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				OTHER_CFLAGS = (
					"$(inherited)",
"-DRN_FABRIC_ENABLED",
);
OTHER_CPLUSPLUSFLAGS = (
"$(OTHER_CFLAGS)",
					"-DFOLLY_NO_CONFIG",
					"-DFOLLY_MOBILE=1",
					"-DFOLLY_USE_LIBCPP=1",
					"-DFOLLY_CFG_NO_COROUTINES=1",
					"-DFOLLY_HAVE_CLOCK_GETTIME=1",
				);
				OTHER_LDFLAGS = "$(inherited)";
REACT_NATIVE_PATH = "${PODS_ROOT}/../../node_modules/react-native";
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "$(inherited) DEBUG";
USE_HERMES = true;
};
name = Debug;
};
83CBBA211A601CBA00E9B192 /_ Release _/ = {
isa = XCBuildConfiguration;
buildSettings = {
ALWAYS_SEARCH_USER_PATHS = NO;
CC = "";
CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
CLANG_CXX_LANGUAGE_STANDARD = "c++20";
CLANG_CXX_LIBRARY = "libc++";
CLANG_ENABLE_MODULES = YES;
CLANG_ENABLE_OBJC_ARC = YES;
CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
CLANG_WARN_BOOL_CONVERSION = YES;
CLANG_WARN_COMMA = YES;
CLANG_WARN_CONSTANT_CONVERSION = YES;
CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
CLANG_WARN_EMPTY_BODY = YES;
CLANG_WARN_ENUM_CONVERSION = YES;
CLANG_WARN_INFINITE_RECURSION = YES;
CLANG_WARN_INT_CONVERSION = YES;
CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
CLANG_WARN_STRICT_PROTOTYPES = YES;
CLANG_WARN_SUSPICIOUS_MOVE = YES;
CLANG_WARN_UNREACHABLE_CODE = YES;
CLANG_WARN**DUPLICATE_METHOD_MATCH = YES;
"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
COPY_PHASE_STRIP = YES;
CXX = "";
ENABLE_NS_ASSERTIONS = NO;
ENABLE_STRICT_OBJC_MSGSEND = YES;
"EXCLUDED_ARCHS[sdk=iphonesimulator*]" = i386;
GCC_C_LANGUAGE_STANDARD = gnu99;
GCC_NO_COMMON_BLOCKS = YES;
GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
GCC_WARN_UNDECLARED_SELECTOR = YES;
GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
GCC_WARN_UNUSED_FUNCTION = YES;
GCC_WARN_UNUSED_VARIABLE = YES;
HEADER_SEARCH_PATHS = (
"$(inherited)",
					"${PODS_CONFIGURATION_BUILD_DIR}/ReactCommon/ReactCommon.framework/Headers",
"${PODS_CONFIGURATION_BUILD_DIR}/ReactCommon/ReactCommon.framework/Headers/react/nativemodule/core",
					"${PODS_CONFIGURATION_BUILD_DIR}/ReactCommon-Samples/ReactCommon_Samples.framework/Headers",
"${PODS_CONFIGURATION_BUILD_DIR}/ReactCommon-Samples/ReactCommon_Samples.framework/Headers/platform/ios",
					"${PODS_CONFIGURATION_BUILD_DIR}/React-Fabric/React_Fabric.framework/Headers/react/renderer/components/view/platform/cxx",
"${PODS_CONFIGURATION_BUILD_DIR}/React-NativeModulesApple/React_NativeModulesApple.framework/Headers",
					"${PODS_CONFIGURATION_BUILD_DIR}/React-graphics/React_graphics.framework/Headers",
"${PODS_CONFIGURATION_BUILD_DIR}/React-graphics/React_graphics.framework/Headers/react/renderer/graphics/platform/ios",
				);
				IPHONEOS_DEPLOYMENT_TARGET = 12.4;
				LD = "";
				LDPLUSPLUS = "";
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
);
LIBRARY_SEARCH_PATHS = (
"\"$(SDKROOT)/usr/lib/swift\"",
					"\"$(TOOLCHAIN_DIR)/usr/lib/swift/$(PLATFORM_NAME)\"",
					"\"$(inherited)\"",
);
MTL_ENABLE_DEBUG_INFO = NO;
OTHER_CFLAGS = (
"$(inherited)",
					"-DRN_FABRIC_ENABLED",
				);
				OTHER_CPLUSPLUSFLAGS = (
					"$(OTHER_CFLAGS)",
"-DFOLLY_NO_CONFIG",
"-DFOLLY_MOBILE=1",
"-DFOLLY_USE_LIBCPP=1",
"-DFOLLY_CFG_NO_COROUTINES=1",
"-DFOLLY_HAVE_CLOCK_GETTIME=1",
);
OTHER_LDFLAGS = "$(inherited)";
				REACT_NATIVE_PATH = "${PODS_ROOT}/../../node_modules/react-native";
SDKROOT = iphoneos;
USE_HERMES = true;
VALIDATE_PRODUCT = YES;
};
name = Release;
};
/_ End XCBuildConfiguration section _/

/_ Begin XCConfigurationList section _/
00E357021AD99517003FC87E /_ Build configuration list for PBXNativeTarget "rnmshowcaseTests" _/ = {
isa = XCConfigurationList;
buildConfigurations = (
00E356F61AD99517003FC87E /_ Debug _/,
00E356F71AD99517003FC87E /_ Release _/,
);
defaultConfigurationIsVisible = 0;
defaultConfigurationName = Release;
};
13B07F931A680F5B00A75B9A /_ Build configuration list for PBXNativeTarget "rnmshowcase" _/ = {
isa = XCConfigurationList;
buildConfigurations = (
13B07F941A680F5B00A75B9A /_ Debug _/,
13B07F951A680F5B00A75B9A /_ Release _/,
);
defaultConfigurationIsVisible = 0;
defaultConfigurationName = Release;
};
83CBB9FA1A601CBA00E9B192 /_ Build configuration list for PBXProject "rnmshowcase" _/ = {
isa = XCConfigurationList;
buildConfigurations = (
83CBBA201A601CBA00E9B192 /_ Debug _/,
83CBBA211A601CBA00E9B192 /_ Release _/,
);
defaultConfigurationIsVisible = 0;
defaultConfigurationName = Release;
};
/_ End XCConfigurationList section _/
};
rootObject = 83CBB9F71A601CBA00E9B192 /_ Project object _/;
}
</file>

<file path="example/ios/rnmshowcase.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="example/ios/rnmshowcase.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:rnmshowcase.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>
</file>

<file path="example/ios/rnmshowcaseTests/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>BNDL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1</string>
</dict>
</plist>
</file>

<file path="example/ios/rnmshowcaseTests/rnmshowcaseTests.m">
#import <UIKit/UIKit.h>
#import <XCTest/XCTest.h>

#import <React/RCTLog.h>
#import <React/RCTRootView.h>

#define TIMEOUT_SECONDS 600
#define TEXT_TO_LOOK_FOR @"Welcome to React"

@interface rnmshowcaseTests : XCTestCase

@end

@implementation rnmshowcaseTests

- (BOOL)findSubviewInView:(UIView *)view matching:(BOOL (^)(UIView *view))test
  {
  if (test(view)) {
  return YES;
  }
  for (UIView \*subview in [view subviews]) {
  if ([self findSubviewInView:subview matching:test]) {
  return YES;
  }
  }
  return NO;
  }

- (void)testRendersWelcomeScreen
  {
  UIViewController *vc = [[[RCTSharedApplication() delegate] window] rootViewController];
  NSDate *date = [NSDate dateWithTimeIntervalSinceNow:TIMEOUT_SECONDS];
  BOOL foundElement = NO;

  \_\_block NSString *redboxError = nil;
  #ifdef DEBUG
  RCTSetLogFunction(
  ^(RCTLogLevel level, RCTLogSource source, NSString *fileName, NSNumber *lineNumber, NSString *message) {
  if (level >= RCTLogLevelError) {
  redboxError = message;
  }
  });
  #endif

  while ([date timeIntervalSinceNow] > 0 && !foundElement && !redboxError) {
  [[NSRunLoop mainRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
  [[NSRunLoop mainRunLoop] runMode:NSRunLoopCommonModes beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];

      foundElement = [self findSubviewInView:vc.view
                                    matching:^BOOL(UIView *view) {
                                      if ([view.accessibilityLabel isEqualToString:TEXT_TO_LOOK_FOR]) {
                                        return YES;
                                      }
                                      return NO;
                                    }];

  }

#ifdef DEBUG
RCTSetLogFunction(RCTDefaultLogFunction);
#endif

XCTAssertNil(redboxError, @"RedBox error: %@", redboxError);
XCTAssertTrue(foundElement, @"Couldn't find element with text '%@' in %d seconds", TEXT_TO_LOOK_FOR, TIMEOUT_SECONDS);
}

@end
</file>

<file path="example/ios/.xcode.env">
# This `.xcode.env` file is versioned and is used to source the environment
# used when running script phases inside Xcode.
# To customize your local environment, you can create an `.xcode.env.local`
# file that is not versioned.

# NODE_BINARY variable contains the PATH to the node executable.

#

# Customize the NODE_BINARY variable here.

# For example, to use nvm with brew, add the following line

# . "$(brew --prefix nvm)/nvm.sh" --no-use

export NODE_BINARY=$(command -v node)
</file>

<file path="example/ios/Podfile">
# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

platform :ios, 15.1
prepare_react_native_project!

linkage = ENV['USE_FRAMEWORKS']
if linkage != nil
Pod::UI.puts "Configuring Pod with #{linkage}ally linked Frameworks".green
use_frameworks! :linkage => linkage.to_sym
end

target 'rnmshowcase' do
config = use_native_modules!

use_react_native!(
:path => config[:reactNativePath], # An absolute path to your application root.
:app_path => "#{Pod::Config.instance.installation_root}/.."
)

rn_maps_path = '../..'
pod 'react-native-google-maps', :path => rn_maps_path
pod 'react-native-maps', :path => rn_maps_path

target 'rnmshowcaseTests' do
inherit! :complete # Pods for testing
end

post_install do |installer| # https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L197-L202
react_native_post_install(
installer,
config[:reactNativePath],
:mac_catalyst_enabled => false, # :ccache_enabled => true
)
end
end
</file>

<file path="example/ios/Podfile.lock">
PODS:
  - boost (1.84.0)
  - DoubleConversion (1.1.6)
  - FBLazyVector (0.76.1)
  - fmt (9.1.0)
  - glog (0.3.5)
  - Google-Maps-iOS-Utils (5.0.0):
    - GoogleMaps (~> 8.0)
  - GoogleMaps (8.4.0):
    - GoogleMaps/Maps (= 8.4.0)
  - GoogleMaps/Base (8.4.0)
  - GoogleMaps/Maps (8.4.0):
    - GoogleMaps/Base
  - hermes-engine (0.76.1):
    - hermes-engine/Pre-built (= 0.76.1)
  - hermes-engine/Pre-built (0.76.1)
  - RCT-Folly (2024.01.01.00):
    - boost
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - RCT-Folly/Default (= 2024.01.01.00)
  - RCT-Folly/Default (2024.01.01.00):
    - boost
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
  - RCT-Folly/Fabric (2024.01.01.00):
    - boost
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
  - RCTDeprecation (0.76.1)
  - RCTRequired (0.76.1)
  - RCTTypeSafety (0.76.1):
    - FBLazyVector (= 0.76.1)
    - RCTRequired (= 0.76.1)
    - React-Core (= 0.76.1)
  - React (0.76.1):
    - React-Core (= 0.76.1)
    - React-Core/DevSupport (= 0.76.1)
    - React-Core/RCTWebSocket (= 0.76.1)
    - React-RCTActionSheet (= 0.76.1)
    - React-RCTAnimation (= 0.76.1)
    - React-RCTBlob (= 0.76.1)
    - React-RCTImage (= 0.76.1)
    - React-RCTLinking (= 0.76.1)
    - React-RCTNetwork (= 0.76.1)
    - React-RCTSettings (= 0.76.1)
    - React-RCTText (= 0.76.1)
    - React-RCTVibration (= 0.76.1)
  - React-callinvoker (0.76.1)
  - React-Core (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default (= 0.76.1)
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/CoreModulesHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/Default (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/DevSupport (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default (= 0.76.1)
    - React-Core/RCTWebSocket (= 0.76.1)
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTActionSheetHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTAnimationHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTBlobHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTImageHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTLinkingHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTNetworkHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTSettingsHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTTextHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTVibrationHeaders (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-Core/RCTWebSocket (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTDeprecation
    - React-Core/Default (= 0.76.1)
    - React-cxxreact
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-perflogger
    - React-runtimescheduler
    - React-utils
    - SocketRocket (= 0.7.1)
    - Yoga
  - React-CoreModules (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - RCT-Folly (= 2024.01.01.00)
    - RCTTypeSafety (= 0.76.1)
    - React-Core/CoreModulesHeaders (= 0.76.1)
    - React-jsi (= 0.76.1)
    - React-jsinspector
    - React-NativeModulesApple
    - React-RCTBlob
    - React-RCTImage (= 0.76.1)
    - ReactCodegen
    - ReactCommon
    - SocketRocket (= 0.7.1)
  - React-cxxreact (0.76.1):
    - boost
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-callinvoker (= 0.76.1)
    - React-debug (= 0.76.1)
    - React-jsi (= 0.76.1)
    - React-jsinspector
    - React-logger (= 0.76.1)
    - React-perflogger (= 0.76.1)
    - React-runtimeexecutor (= 0.76.1)
    - React-timing (= 0.76.1)
  - React-debug (0.76.1)
  - React-defaultsnativemodule (0.76.1):
    - DoubleConversion
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-debug
    - React-domnativemodule
    - React-Fabric
    - React-featureflags
    - React-featureflagsnativemodule
    - React-graphics
    - React-idlecallbacksnativemodule
    - React-ImageManager
    - React-microtasksnativemodule
    - React-NativeModulesApple
    - React-RCTFabric
    - React-rendererdebug
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/bridging
    - ReactCommon/turbomodule/core
    - Yoga
  - React-domnativemodule (0.76.1):
    - DoubleConversion
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-debug
    - React-Fabric
    - React-FabricComponents
    - React-featureflags
    - React-graphics
    - React-ImageManager
    - React-NativeModulesApple
    - React-RCTFabric
    - React-rendererdebug
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/bridging
    - ReactCommon/turbomodule/core
    - Yoga
  - React-Fabric (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric/animations (= 0.76.1)
    - React-Fabric/attributedstring (= 0.76.1)
    - React-Fabric/componentregistry (= 0.76.1)
    - React-Fabric/componentregistrynative (= 0.76.1)
    - React-Fabric/components (= 0.76.1)
    - React-Fabric/core (= 0.76.1)
    - React-Fabric/dom (= 0.76.1)
    - React-Fabric/imagemanager (= 0.76.1)
    - React-Fabric/leakchecker (= 0.76.1)
    - React-Fabric/mounting (= 0.76.1)
    - React-Fabric/observers (= 0.76.1)
    - React-Fabric/scheduler (= 0.76.1)
    - React-Fabric/telemetry (= 0.76.1)
    - React-Fabric/templateprocessor (= 0.76.1)
    - React-Fabric/uimanager (= 0.76.1)
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/animations (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/attributedstring (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/componentregistry (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/componentregistrynative (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/components (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric/components/legacyviewmanagerinterop (= 0.76.1)
    - React-Fabric/components/root (= 0.76.1)
    - React-Fabric/components/view (= 0.76.1)
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/components/legacyviewmanagerinterop (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/components/root (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/components/view (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
    - Yoga
  - React-Fabric/core (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/dom (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/imagemanager (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/leakchecker (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/mounting (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/observers (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric/observers/events (= 0.76.1)
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/observers/events (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/scheduler (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric/observers/events
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-performancetimeline
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/telemetry (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/templateprocessor (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/uimanager (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric/uimanager/consistency (= 0.76.1)
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererconsistency
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-Fabric/uimanager/consistency (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererconsistency
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCommon/turbomodule/core
  - React-FabricComponents (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-FabricComponents/components (= 0.76.1)
    - React-FabricComponents/textlayoutmanager (= 0.76.1)
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-FabricComponents/components/inputaccessory (= 0.76.1)
    - React-FabricComponents/components/iostextinput (= 0.76.1)
    - React-FabricComponents/components/modal (= 0.76.1)
    - React-FabricComponents/components/rncore (= 0.76.1)
    - React-FabricComponents/components/safeareaview (= 0.76.1)
    - React-FabricComponents/components/scrollview (= 0.76.1)
    - React-FabricComponents/components/text (= 0.76.1)
    - React-FabricComponents/components/textinput (= 0.76.1)
    - React-FabricComponents/components/unimplementedview (= 0.76.1)
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/inputaccessory (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/iostextinput (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/modal (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/rncore (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/safeareaview (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/scrollview (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/text (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/textinput (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/components/unimplementedview (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricComponents/textlayoutmanager (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-cxxreact
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-logger
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/core
    - Yoga
  - React-FabricImage (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - RCTRequired (= 0.76.1)
    - RCTTypeSafety (= 0.76.1)
    - React-Fabric
    - React-graphics
    - React-ImageManager
    - React-jsi
    - React-jsiexecutor (= 0.76.1)
    - React-logger
    - React-rendererdebug
    - React-utils
    - ReactCommon
    - Yoga
  - React-featureflags (0.76.1)
  - React-featureflagsnativemodule (0.76.1):
    - DoubleConversion
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-ImageManager
    - React-NativeModulesApple
    - React-RCTFabric
    - React-rendererdebug
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/bridging
    - ReactCommon/turbomodule/core
    - Yoga
  - React-graphics (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - React-jsi
    - React-jsiexecutor
    - React-utils
  - React-hermes (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-cxxreact (= 0.76.1)
    - React-jsi
    - React-jsiexecutor (= 0.76.1)
    - React-jsinspector
    - React-perflogger (= 0.76.1)
    - React-runtimeexecutor
  - React-idlecallbacksnativemodule (0.76.1):
    - DoubleConversion
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-ImageManager
    - React-NativeModulesApple
    - React-RCTFabric
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/bridging
    - ReactCommon/turbomodule/core
    - Yoga
  - React-ImageManager (0.76.1):
    - glog
    - RCT-Folly/Fabric
    - React-Core/Default
    - React-debug
    - React-Fabric
    - React-graphics
    - React-rendererdebug
    - React-utils
  - React-jserrorhandler (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - React-cxxreact
    - React-debug
    - React-jsi
  - React-jsi (0.76.1):
    - boost
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
  - React-jsiexecutor (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-cxxreact (= 0.76.1)
    - React-jsi (= 0.76.1)
    - React-jsinspector
    - React-perflogger (= 0.76.1)
  - React-jsinspector (0.76.1):
    - DoubleConversion
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-featureflags
    - React-jsi
    - React-perflogger (= 0.76.1)
    - React-runtimeexecutor (= 0.76.1)
  - React-jsitracing (0.76.1):
    - React-jsi
  - React-logger (0.76.1):
    - glog
  - React-Mapbuffer (0.76.1):
    - glog
    - React-debug
  - React-microtasksnativemodule (0.76.1):
    - DoubleConversion
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-debug
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-ImageManager
    - React-NativeModulesApple
    - React-RCTFabric
    - React-rendererdebug
    - React-utils
    - ReactCodegen
    - ReactCommon/turbomodule/bridging
    - ReactCommon/turbomodule/core
    - Yoga
  - react-native-google-maps (0.0.0):
    - Google-Maps-iOS-Utils (= 5.0.0)
    - GoogleMaps (= 8.4.0)
    - React-Core
  - react-native-maps (0.0.0):
    - React-Core
  - React-nativeconfig (0.76.1)
  - React-NativeModulesApple (0.76.1):
    - glog
    - hermes-engine
    - React-callinvoker
    - React-Core
    - React-cxxreact
    - React-jsi
    - React-jsinspector
    - React-runtimeexecutor
    - ReactCommon/turbomodule/bridging
    - ReactCommon/turbomodule/core
  - React-perflogger (0.76.1):
    - DoubleConversion
    - RCT-Folly (= 2024.01.01.00)
  - React-performancetimeline (0.76.1):
    - RCT-Folly (= 2024.01.01.00)
    - React-cxxreact
    - React-timing
  - React-RCTActionSheet (0.76.1):
    - React-Core/RCTActionSheetHeaders (= 0.76.1)
  - React-RCTAnimation (0.76.1):
    - RCT-Folly (= 2024.01.01.00)
    - RCTTypeSafety
    - React-Core/RCTAnimationHeaders
    - React-jsi
    - React-NativeModulesApple
    - ReactCodegen
    - ReactCommon
  - React-RCTAppDelegate (0.76.1):
    - RCT-Folly (= 2024.01.01.00)
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-CoreModules
    - React-debug
    - React-defaultsnativemodule
    - React-Fabric
    - React-featureflags
    - React-graphics
    - React-hermes
    - React-nativeconfig
    - React-NativeModulesApple
    - React-RCTFabric
    - React-RCTImage
    - React-RCTNetwork
    - React-rendererdebug
    - React-RuntimeApple
    - React-RuntimeCore
    - React-RuntimeHermes
    - React-runtimescheduler
    - React-utils
    - ReactCodegen
    - ReactCommon
  - React-RCTBlob (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-Core/RCTBlobHeaders
    - React-Core/RCTWebSocket
    - React-jsi
    - React-jsinspector
    - React-NativeModulesApple
    - React-RCTNetwork
    - ReactCodegen
    - ReactCommon
  - React-RCTFabric (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - React-Core
    - React-debug
    - React-Fabric
    - React-FabricComponents
    - React-FabricImage
    - React-featureflags
    - React-graphics
    - React-ImageManager
    - React-jsi
    - React-jsinspector
    - React-nativeconfig
    - React-performancetimeline
    - React-RCTImage
    - React-RCTText
    - React-rendererconsistency
    - React-rendererdebug
    - React-runtimescheduler
    - React-utils
    - Yoga
  - React-RCTImage (0.76.1):
    - RCT-Folly (= 2024.01.01.00)
    - RCTTypeSafety
    - React-Core/RCTImageHeaders
    - React-jsi
    - React-NativeModulesApple
    - React-RCTNetwork
    - ReactCodegen
    - ReactCommon
  - React-RCTLinking (0.76.1):
    - React-Core/RCTLinkingHeaders (= 0.76.1)
    - React-jsi (= 0.76.1)
    - React-NativeModulesApple
    - ReactCodegen
    - ReactCommon
    - ReactCommon/turbomodule/core (= 0.76.1)
  - React-RCTNetwork (0.76.1):
    - RCT-Folly (= 2024.01.01.00)
    - RCTTypeSafety
    - React-Core/RCTNetworkHeaders
    - React-jsi
    - React-NativeModulesApple
    - ReactCodegen
    - ReactCommon
  - React-RCTSettings (0.76.1):
    - RCT-Folly (= 2024.01.01.00)
    - RCTTypeSafety
    - React-Core/RCTSettingsHeaders
    - React-jsi
    - React-NativeModulesApple
    - ReactCodegen
    - ReactCommon
  - React-RCTText (0.76.1):
    - React-Core/RCTTextHeaders (= 0.76.1)
    - Yoga
  - React-RCTVibration (0.76.1):
    - RCT-Folly (= 2024.01.01.00)
    - React-Core/RCTVibrationHeaders
    - React-jsi
    - React-NativeModulesApple
    - ReactCodegen
    - ReactCommon
  - React-rendererconsistency (0.76.1)
  - React-rendererdebug (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - RCT-Folly (= 2024.01.01.00)
    - React-debug
  - React-rncore (0.76.1)
  - React-RuntimeApple (0.76.1):
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - React-callinvoker
    - React-Core/Default
    - React-CoreModules
    - React-cxxreact
    - React-jserrorhandler
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-Mapbuffer
    - React-NativeModulesApple
    - React-RCTFabric
    - React-RuntimeCore
    - React-runtimeexecutor
    - React-RuntimeHermes
    - React-runtimescheduler
    - React-utils
  - React-RuntimeCore (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - React-cxxreact
    - React-featureflags
    - React-jserrorhandler
    - React-jsi
    - React-jsiexecutor
    - React-jsinspector
    - React-performancetimeline
    - React-runtimeexecutor
    - React-runtimescheduler
    - React-utils
  - React-runtimeexecutor (0.76.1):
    - React-jsi (= 0.76.1)
  - React-RuntimeHermes (0.76.1):
    - hermes-engine
    - RCT-Folly/Fabric (= 2024.01.01.00)
    - React-featureflags
    - React-hermes
    - React-jsi
    - React-jsinspector
    - React-jsitracing
    - React-nativeconfig
    - React-RuntimeCore
    - React-utils
  - React-runtimescheduler (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-callinvoker
    - React-cxxreact
    - React-debug
    - React-featureflags
    - React-jsi
    - React-performancetimeline
    - React-rendererconsistency
    - React-rendererdebug
    - React-runtimeexecutor
    - React-timing
    - React-utils
  - React-timing (0.76.1)
  - React-utils (0.76.1):
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-debug
    - React-jsi (= 0.76.1)
  - ReactCodegen (0.76.1):
    - DoubleConversion
    - glog
    - hermes-engine
    - RCT-Folly
    - RCTRequired
    - RCTTypeSafety
    - React-Core
    - React-debug
    - React-Fabric
    - React-FabricImage
    - React-featureflags
    - React-graphics
    - React-jsi
    - React-jsiexecutor
    - React-NativeModulesApple
    - React-rendererdebug
    - React-utils
    - ReactCommon/turbomodule/bridging
    - ReactCommon/turbomodule/core
  - ReactCommon (0.76.1):
    - ReactCommon/turbomodule (= 0.76.1)
  - ReactCommon/turbomodule (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-callinvoker (= 0.76.1)
    - React-cxxreact (= 0.76.1)
    - React-jsi (= 0.76.1)
    - React-logger (= 0.76.1)
    - React-perflogger (= 0.76.1)
    - ReactCommon/turbomodule/bridging (= 0.76.1)
    - ReactCommon/turbomodule/core (= 0.76.1)
  - ReactCommon/turbomodule/bridging (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-callinvoker (= 0.76.1)
    - React-cxxreact (= 0.76.1)
    - React-jsi (= 0.76.1)
    - React-logger (= 0.76.1)
    - React-perflogger (= 0.76.1)
  - ReactCommon/turbomodule/core (0.76.1):
    - DoubleConversion
    - fmt (= 9.1.0)
    - glog
    - hermes-engine
    - RCT-Folly (= 2024.01.01.00)
    - React-callinvoker (= 0.76.1)
    - React-cxxreact (= 0.76.1)
    - React-debug (= 0.76.1)
    - React-featureflags (= 0.76.1)
    - React-jsi (= 0.76.1)
    - React-logger (= 0.76.1)
    - React-perflogger (= 0.76.1)
    - React-utils (= 0.76.1)
  - SocketRocket (0.7.1)
  - Yoga (0.0.0)

DEPENDENCIES:

- boost (from `../node_modules/react-native/third-party-podspecs/boost.podspec`)
- DoubleConversion (from `../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec`)
- FBLazyVector (from `../node_modules/react-native/Libraries/FBLazyVector`)
- fmt (from `../node_modules/react-native/third-party-podspecs/fmt.podspec`)
- glog (from `../node_modules/react-native/third-party-podspecs/glog.podspec`)
- hermes-engine (from `../node_modules/react-native/sdks/hermes-engine/hermes-engine.podspec`)
- RCT-Folly (from `../node_modules/react-native/third-party-podspecs/RCT-Folly.podspec`)
- RCT-Folly/Fabric (from `../node_modules/react-native/third-party-podspecs/RCT-Folly.podspec`)
- RCTDeprecation (from `../node_modules/react-native/ReactApple/Libraries/RCTFoundation/RCTDeprecation`)
- RCTRequired (from `../node_modules/react-native/Libraries/Required`)
- RCTTypeSafety (from `../node_modules/react-native/Libraries/TypeSafety`)
- React (from `../node_modules/react-native/`)
- React-callinvoker (from `../node_modules/react-native/ReactCommon/callinvoker`)
- React-Core (from `../node_modules/react-native/`)
- React-Core/RCTWebSocket (from `../node_modules/react-native/`)
- React-CoreModules (from `../node_modules/react-native/React/CoreModules`)
- React-cxxreact (from `../node_modules/react-native/ReactCommon/cxxreact`)
- React-debug (from `../node_modules/react-native/ReactCommon/react/debug`)
- React-defaultsnativemodule (from `../node_modules/react-native/ReactCommon/react/nativemodule/defaults`)
- React-domnativemodule (from `../node_modules/react-native/ReactCommon/react/nativemodule/dom`)
- React-Fabric (from `../node_modules/react-native/ReactCommon`)
- React-FabricComponents (from `../node_modules/react-native/ReactCommon`)
- React-FabricImage (from `../node_modules/react-native/ReactCommon`)
- React-featureflags (from `../node_modules/react-native/ReactCommon/react/featureflags`)
- React-featureflagsnativemodule (from `../node_modules/react-native/ReactCommon/react/nativemodule/featureflags`)
- React-graphics (from `../node_modules/react-native/ReactCommon/react/renderer/graphics`)
- React-hermes (from `../node_modules/react-native/ReactCommon/hermes`)
- React-idlecallbacksnativemodule (from `../node_modules/react-native/ReactCommon/react/nativemodule/idlecallbacks`)
- React-ImageManager (from `../node_modules/react-native/ReactCommon/react/renderer/imagemanager/platform/ios`)
- React-jserrorhandler (from `../node_modules/react-native/ReactCommon/jserrorhandler`)
- React-jsi (from `../node_modules/react-native/ReactCommon/jsi`)
- React-jsiexecutor (from `../node_modules/react-native/ReactCommon/jsiexecutor`)
- React-jsinspector (from `../node_modules/react-native/ReactCommon/jsinspector-modern`)
- React-jsitracing (from `../node_modules/react-native/ReactCommon/hermes/executor/`)
- React-logger (from `../node_modules/react-native/ReactCommon/logger`)
- React-Mapbuffer (from `../node_modules/react-native/ReactCommon`)
- React-microtasksnativemodule (from `../node_modules/react-native/ReactCommon/react/nativemodule/microtasks`)
- react-native-google-maps (from `../..`)
- react-native-maps (from `../..`)
- React-nativeconfig (from `../node_modules/react-native/ReactCommon`)
- React-NativeModulesApple (from `../node_modules/react-native/ReactCommon/react/nativemodule/core/platform/ios`)
- React-perflogger (from `../node_modules/react-native/ReactCommon/reactperflogger`)
- React-performancetimeline (from `../node_modules/react-native/ReactCommon/react/performance/timeline`)
- React-RCTActionSheet (from `../node_modules/react-native/Libraries/ActionSheetIOS`)
- React-RCTAnimation (from `../node_modules/react-native/Libraries/NativeAnimation`)
- React-RCTAppDelegate (from `../node_modules/react-native/Libraries/AppDelegate`)
- React-RCTBlob (from `../node_modules/react-native/Libraries/Blob`)
- React-RCTFabric (from `../node_modules/react-native/React`)
- React-RCTImage (from `../node_modules/react-native/Libraries/Image`)
- React-RCTLinking (from `../node_modules/react-native/Libraries/LinkingIOS`)
- React-RCTNetwork (from `../node_modules/react-native/Libraries/Network`)
- React-RCTSettings (from `../node_modules/react-native/Libraries/Settings`)
- React-RCTText (from `../node_modules/react-native/Libraries/Text`)
- React-RCTVibration (from `../node_modules/react-native/Libraries/Vibration`)
- React-rendererconsistency (from `../node_modules/react-native/ReactCommon/react/renderer/consistency`)
- React-rendererdebug (from `../node_modules/react-native/ReactCommon/react/renderer/debug`)
- React-rncore (from `../node_modules/react-native/ReactCommon`)
- React-RuntimeApple (from `../node_modules/react-native/ReactCommon/react/runtime/platform/ios`)
- React-RuntimeCore (from `../node_modules/react-native/ReactCommon/react/runtime`)
- React-runtimeexecutor (from `../node_modules/react-native/ReactCommon/runtimeexecutor`)
- React-RuntimeHermes (from `../node_modules/react-native/ReactCommon/react/runtime`)
- React-runtimescheduler (from `../node_modules/react-native/ReactCommon/react/renderer/runtimescheduler`)
- React-timing (from `../node_modules/react-native/ReactCommon/react/timing`)
- React-utils (from `../node_modules/react-native/ReactCommon/react/utils`)
- ReactCodegen (from `build/generated/ios`)
- ReactCommon/turbomodule/core (from `../node_modules/react-native/ReactCommon`)
- Yoga (from `../node_modules/react-native/ReactCommon/yoga`)

SPEC REPOS:
trunk: - Google-Maps-iOS-Utils - GoogleMaps - SocketRocket

EXTERNAL SOURCES:
boost:
:podspec: "../node_modules/react-native/third-party-podspecs/boost.podspec"
DoubleConversion:
:podspec: "../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec"
FBLazyVector:
:path: "../node_modules/react-native/Libraries/FBLazyVector"
fmt:
:podspec: "../node_modules/react-native/third-party-podspecs/fmt.podspec"
glog:
:podspec: "../node_modules/react-native/third-party-podspecs/glog.podspec"
hermes-engine:
:podspec: "../node_modules/react-native/sdks/hermes-engine/hermes-engine.podspec"
:tag: hermes-2024-09-09-RNv0.76.0-db6d12e202e15f7a446d8848d6ca8f7abb3cfb32
RCT-Folly:
:podspec: "../node_modules/react-native/third-party-podspecs/RCT-Folly.podspec"
RCTDeprecation:
:path: "../node_modules/react-native/ReactApple/Libraries/RCTFoundation/RCTDeprecation"
RCTRequired:
:path: "../node_modules/react-native/Libraries/Required"
RCTTypeSafety:
:path: "../node_modules/react-native/Libraries/TypeSafety"
React:
:path: "../node_modules/react-native/"
React-callinvoker:
:path: "../node_modules/react-native/ReactCommon/callinvoker"
React-Core:
:path: "../node_modules/react-native/"
React-CoreModules:
:path: "../node_modules/react-native/React/CoreModules"
React-cxxreact:
:path: "../node_modules/react-native/ReactCommon/cxxreact"
React-debug:
:path: "../node_modules/react-native/ReactCommon/react/debug"
React-defaultsnativemodule:
:path: "../node_modules/react-native/ReactCommon/react/nativemodule/defaults"
React-domnativemodule:
:path: "../node_modules/react-native/ReactCommon/react/nativemodule/dom"
React-Fabric:
:path: "../node_modules/react-native/ReactCommon"
React-FabricComponents:
:path: "../node_modules/react-native/ReactCommon"
React-FabricImage:
:path: "../node_modules/react-native/ReactCommon"
React-featureflags:
:path: "../node_modules/react-native/ReactCommon/react/featureflags"
React-featureflagsnativemodule:
:path: "../node_modules/react-native/ReactCommon/react/nativemodule/featureflags"
React-graphics:
:path: "../node_modules/react-native/ReactCommon/react/renderer/graphics"
React-hermes:
:path: "../node_modules/react-native/ReactCommon/hermes"
React-idlecallbacksnativemodule:
:path: "../node_modules/react-native/ReactCommon/react/nativemodule/idlecallbacks"
React-ImageManager:
:path: "../node_modules/react-native/ReactCommon/react/renderer/imagemanager/platform/ios"
React-jserrorhandler:
:path: "../node_modules/react-native/ReactCommon/jserrorhandler"
React-jsi:
:path: "../node_modules/react-native/ReactCommon/jsi"
React-jsiexecutor:
:path: "../node_modules/react-native/ReactCommon/jsiexecutor"
React-jsinspector:
:path: "../node_modules/react-native/ReactCommon/jsinspector-modern"
React-jsitracing:
:path: "../node_modules/react-native/ReactCommon/hermes/executor/"
React-logger:
:path: "../node_modules/react-native/ReactCommon/logger"
React-Mapbuffer:
:path: "../node_modules/react-native/ReactCommon"
React-microtasksnativemodule:
:path: "../node_modules/react-native/ReactCommon/react/nativemodule/microtasks"
react-native-google-maps:
:path: "../.."
react-native-maps:
:path: "../.."
React-nativeconfig:
:path: "../node_modules/react-native/ReactCommon"
React-NativeModulesApple:
:path: "../node_modules/react-native/ReactCommon/react/nativemodule/core/platform/ios"
React-perflogger:
:path: "../node_modules/react-native/ReactCommon/reactperflogger"
React-performancetimeline:
:path: "../node_modules/react-native/ReactCommon/react/performance/timeline"
React-RCTActionSheet:
:path: "../node_modules/react-native/Libraries/ActionSheetIOS"
React-RCTAnimation:
:path: "../node_modules/react-native/Libraries/NativeAnimation"
React-RCTAppDelegate:
:path: "../node_modules/react-native/Libraries/AppDelegate"
React-RCTBlob:
:path: "../node_modules/react-native/Libraries/Blob"
React-RCTFabric:
:path: "../node_modules/react-native/React"
React-RCTImage:
:path: "../node_modules/react-native/Libraries/Image"
React-RCTLinking:
:path: "../node_modules/react-native/Libraries/LinkingIOS"
React-RCTNetwork:
:path: "../node_modules/react-native/Libraries/Network"
React-RCTSettings:
:path: "../node_modules/react-native/Libraries/Settings"
React-RCTText:
:path: "../node_modules/react-native/Libraries/Text"
React-RCTVibration:
:path: "../node_modules/react-native/Libraries/Vibration"
React-rendererconsistency:
:path: "../node_modules/react-native/ReactCommon/react/renderer/consistency"
React-rendererdebug:
:path: "../node_modules/react-native/ReactCommon/react/renderer/debug"
React-rncore:
:path: "../node_modules/react-native/ReactCommon"
React-RuntimeApple:
:path: "../node_modules/react-native/ReactCommon/react/runtime/platform/ios"
React-RuntimeCore:
:path: "../node_modules/react-native/ReactCommon/react/runtime"
React-runtimeexecutor:
:path: "../node_modules/react-native/ReactCommon/runtimeexecutor"
React-RuntimeHermes:
:path: "../node_modules/react-native/ReactCommon/react/runtime"
React-runtimescheduler:
:path: "../node_modules/react-native/ReactCommon/react/renderer/runtimescheduler"
React-timing:
:path: "../node_modules/react-native/ReactCommon/react/timing"
React-utils:
:path: "../node_modules/react-native/ReactCommon/react/utils"
ReactCodegen:
:path: build/generated/ios
ReactCommon:
:path: "../node_modules/react-native/ReactCommon"
Yoga:
:path: "../node_modules/react-native/ReactCommon/yoga"

SPEC CHECKSUMS:
boost: 1dca942403ed9342f98334bf4c3621f011aa7946
DoubleConversion: f16ae600a246532c4020132d54af21d0ddb2a385
FBLazyVector: 7075bb12898bc3998fd60f4b7ca422496cc2cdf7
fmt: 10c6e61f4be25dc963c36bd73fc7b1705fe975be
glog: 08b301085f15bcbb6ff8632a8ebaf239aae04e6a
Google-Maps-iOS-Utils: 66d6de12be1ce6d3742a54661e7a79cb317a9321
GoogleMaps: 8939898920281c649150e0af74aa291c60f2e77d
hermes-engine: 46f1ffbf0297f4298862068dd4c274d4ac17a1fd
RCT-Folly: bf5c0376ffe4dd2cf438dcf86db385df9fdce648
RCTDeprecation: fde92935b3caa6cb65cbff9fbb7d3a9867ffb259
RCTRequired: 75c6cee42d21c1530a6f204ba32ff57335d19007
RCTTypeSafety: 7e6fe47bfb693c50d4669db1a480ca5331795f5b
React: 8e73704cdd5c7f801936776d2fc434c605a7827b
React-callinvoker: fa27d1e091e683de88f576e6a5d4efc171929a4c
React-Core: 8dd14bffcc9b877091b698e45701160669a31f91
React-CoreModules: b4437acf2ef25ce3689c84df661dc5d806559b35
React-cxxreact: 6125cd820da7e18f9ca8343b3c42ee61634a4e0d
React-debug: f474f5c202a277f76c81bf7cf26284f2c09880d7
React-defaultsnativemodule: 7141fa704531cbf7a7e7af3bc02adfa367e831a7
React-domnativemodule: c1806b8584a53ed912012a4d8b2c6f96a84c77a3
React-Fabric: ba9636cfc7f9b77df6cb7edb2c70d0237026404b
React-FabricComponents: c408da05a4ea5ba071732245b4a7f48f904e610a
React-FabricImage: c409858f319f11709b49ffa6c5bca4faf794cb44
React-featureflags: 929732439d139ac0662e08f009f1a51ed2b91ed3
React-featureflagsnativemodule: 02dd903d4cbe4fae0e6cd02bc32a09d30543282f
React-graphics: a5cad35307286e9f83e212834e95fef4010d03d0
React-hermes: 14aafa9630579b84c2167b563bdb8c811970a03e
React-idlecallbacksnativemodule: 69581ac44bd355acce3739c3fe380c0f6d7a6d09
React-ImageManager: 41945afb3ace0c52255057ec4ae6af6f5a23539f
React-jserrorhandler: ecbc4622df7ab3d0066a4313cde4172d45745508
React-jsi: ff383df87c7047e976a66be45df59e4e0db5346e
React-jsiexecutor: 2bb8b172f226f2f502521d33dd7666e701d45f45
React-jsinspector: 4d51b903543f21076b658ef8412f3102778dbc92
React-jsitracing: 654f4d9cb9fd99b3d96f239ceb215ae49ce28ac0
React-logger: 97c9dafae1f1a638001a9d1d0e93d431f2f9cb7b
React-Mapbuffer: 3146a13424f9fec2ea1f1462d49d566e4d69b732
React-microtasksnativemodule: 02d218c79c72d373a92a8552183f4ead0d1c6e05
react-native-google-maps: e37f53ff027fbb3223c2f317e8010bb9633d7823
react-native-maps: 3ae17cf31b3959bafed98adecd53d31fb2114fdc
React-nativeconfig: 93fe8c85a8c40820c57814e30f3e44b94c995a7b
React-NativeModulesApple: b3e076fd0d7b73417fe1e8c8b26e3c57ae9b74aa
React-perflogger: 1c55bcd3c392137cbaf0d21d8bb87ce9a0cebb15
React-performancetimeline: e89249db10b8f7bf8f72c2e9bd471ac37d48b753
React-RCTActionSheet: 9407c795fbeee35da2dae3cd6b5c4e5da6ff8bd3
React-RCTAnimation: 7ee1c2a77aab7e5c568611d8092a994cfcbe8410
React-RCTAppDelegate: 10c2b0c434baf5a71b53d5c86c4d8d0dbd6bb380
React-RCTBlob: 761072706300d22624ec2d6bf860b77d95ebd3da
React-RCTFabric: 871d38933a94554d9e27963aa4bb67184dc7529e
React-RCTImage: b6614fde902ec9647f15236da94df2d24c40523f
React-RCTLinking: 25950eda5d5f786bfb3daf513ea7d848555a2a93
React-RCTNetwork: b69407c4119fd7a1cc07db4a94563f2546f8770d
React-RCTSettings: b310a4923446c3a8950fa866c8cf83323a9e1b87
React-RCTText: 77c6eda5be1dee657f5183f75fe0fdcdb7b2b35d
React-RCTVibration: b4889c7702aea1b07316be1ec0de2e36e9a4d077
React-rendererconsistency: 5ef1c4642fd6365bf6d5d4e29a3ae02c3a1b8980
React-rendererdebug: 7f6a24cbb5008a22ccb34a0d031a259b006facf6
React-rncore: 0e5394ce20a9d2bf12409d14395588c7b9e6e9ce
React-RuntimeApple: bbe293f233d17304c9597309acde7505080fd53d
React-RuntimeCore: 5a1cbfc3e7af4fbdea2b9b1efd39cd51a4d4006f
React-runtimeexecutor: ffac5f09795a5e881477e0d72a0fa6385456bed3
React-RuntimeHermes: 0a1fd1c150faed8341887dd89895eeb8d4d2d3c5
React-runtimescheduler: e7df538274de0c65736068e40efc0d2228f42d0d
React-timing: b3b233fe819d9e5b6ca32b605aa732621bdfa5aa
React-utils: 5362bd16a9563f9916e7a56c011ddc533507650f
ReactCodegen: 865bafc5c17ec2181620ced1a32c39c38ab2951d
ReactCommon: 422e364463f33e336fc4db196aeb50fd801d90d6
SocketRocket: d4aabe649be1e368d1318fdf28a022d714d65748
Yoga: db69236006b8b1c6d55ab453390c882306cbf219

PODFILE CHECKSUM: 90b4ba12452122f7040df0a07dde87ba0f44ed5c

COCOAPODS: 1.16.2
</file>

<file path="example/src/examples/AnimatedMarkers.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
  Platform,
} from 'react-native';

import MapView, {Marker, AnimatedRegion} from 'react-native-maps';

const screen = Dimensions.get('window');

const ASPECT_RATIO = screen.width / screen.height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class AnimatedMarkers extends React.Component<any, any> {
marker: any;
constructor(props: any) {
super(props);

    this.state = {
      coordinate: new AnimatedRegion({
        latitude: LATITUDE,
        longitude: LONGITUDE,
      }),
    };

}

animate() {
const {coordinate} = this.state;
const newCoordinate = {
latitude: LATITUDE + (Math.random() - 0.5) _ (LATITUDE_DELTA / 2),
longitude: LONGITUDE + (Math.random() - 0.5) _ (LONGITUDE_DELTA / 2),
};

    if (Platform.OS === 'android') {
      if (this.marker) {
        this.marker._component.animateMarkerToCoordinate(newCoordinate, 500);
      }
    } else {
      // `useNativeDriver` defaults to false if not passed explicitly
      coordinate.timing({...newCoordinate, useNativeDriver: true}).start();
    }

}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}>
<Marker.Animated
ref={(marker: any) => {
this.marker = marker;
}}
coordinate={this.state.coordinate}
/>
</MapView>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.animate()}
style={[styles.bubble, styles.button]}>
<Text>Animate</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default AnimatedMarkers;
</file>

<file path="example/src/examples/AnimatedNavigation.tsx">
import React, {Component} from 'react';

import {View, StyleSheet, TouchableOpacity, Text} from 'react-native';

import MapView, {Marker} from 'react-native-maps';
// @ts-ignore
import carImage from './assets/car.png';

export default class NavigationMap extends Component<any, any> {
map: any;
constructor(props: any) {
super(props);
this.state = {
prevPos: null,
curPos: {latitude: 37.420814, longitude: -122.081949},
curAng: 45,
latitudeDelta: 0.0922,
longitudeDelta: 0.0421,
};
this.changePosition = this.changePosition.bind(this);
this.getRotation = this.getRotation.bind(this);
this.updateMap = this.updateMap.bind(this);
}

changePosition(latOffset: number, lonOffset: number) {
const latitude = this.state.curPos.latitude + latOffset;
const longitude = this.state.curPos.longitude + lonOffset;
this.setState({
prevPos: this.state.curPos,
curPos: {latitude, longitude},
});
this.updateMap();
}

getRotation(prevPos: any, curPos: any) {
if (!prevPos) {
return 0;
}
const xDiff = curPos.latitude - prevPos.latitude;
const yDiff = curPos.longitude - prevPos.longitude;
return (Math.atan2(yDiff, xDiff) \* 180.0) / Math.PI;
}

updateMap() {
const {curPos, prevPos, curAng} = this.state;
const curRot = this.getRotation(prevPos, curPos);
this.map.animateCamera({heading: curRot, center: curPos, pitch: curAng});
}

render() {
return (
<View style={styles.flex}>
<MapView
ref={el => (this.map = el)}
style={styles.flex}
minZoomLevel={15}
initialRegion={{
            ...this.state.curPos,
            latitudeDelta: this.state.latitudeDelta,
            longitudeDelta: this.state.longitudeDelta,
          }}>
<Marker
coordinate={this.state.curPos}
anchor={{x: 0.5, y: 0.5}}
image={carImage}
/>
</MapView>
<View style={styles.buttonContainerUpDown}>
<TouchableOpacity
style={[styles.button, styles.up]}
onPress={() => this.changePosition(0.0001, 0)}>
<Text>+ Lat</Text>
</TouchableOpacity>
<TouchableOpacity
style={[styles.button, styles.down]}
onPress={() => this.changePosition(-0.0001, 0)}>
<Text>- Lat</Text>
</TouchableOpacity>
</View>
<View style={styles.buttonContainerLeftRight}>
<TouchableOpacity
style={[styles.button, styles.left]}
onPress={() => this.changePosition(0, -0.0001)}>
<Text>- Lon</Text>
</TouchableOpacity>
<TouchableOpacity
style={[styles.button, styles.right]}
onPress={() => this.changePosition(0, 0.0001)}>
<Text>+ Lon</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
flex: {
flex: 1,
width: '100%',
},
buttonContainerUpDown: {
...StyleSheet.absoluteFillObject,
flexDirection: 'row',
justifyContent: 'center',
},
buttonContainerLeftRight: {
...StyleSheet.absoluteFillObject,
flexDirection: 'column',
justifyContent: 'center',
},
button: {
backgroundColor: 'rgba(100,100,100,0.2)',
position: 'absolute',
alignItems: 'center',
justifyContent: 'center',
borderRadius: 20,
height: 50,
width: 50,
},
up: {
alignSelf: 'flex-start',
},
down: {
alignSelf: 'flex-end',
},
left: {
alignSelf: 'flex-start',
},
right: {
alignSelf: 'flex-end',
},
});
</file>

<file path="example/src/examples/AnimatedPriceMarker.tsx">
import React from 'react';
import {StyleSheet, Text, Animated} from 'react-native';

class AnimatedPriceMarker extends React.Component<any, any> {
render() {
const {amount, selected, style} = this.props;

    const background = selected.interpolate({
      inputRange: [0, 1],
      outputRange: ['#FF5A5F', '#4da2ab'],
    });

    const border = selected.interpolate({
      inputRange: [0, 1],
      outputRange: ['#D23F44', '#007a87'],
    });

    return (
      <Animated.View style={[styles.container, style]}>
        <Animated.View
          style={[
            styles.bubble,
            {
              backgroundColor: background,
              borderColor: border,
            },
          ]}>
          <Text style={styles.dollar}>$</Text>
          <Text style={styles.amount}>{amount}</Text>
        </Animated.View>
        <Animated.View style={[styles.arrowBorder, {borderTopColor: border}]} />
        <Animated.View style={[styles.arrow, {borderTopColor: background}]} />
      </Animated.View>
    );

}
}

const styles = StyleSheet.create({
container: {
flexDirection: 'column',
alignSelf: 'flex-start',
},
bubble: {
flex: 0,
flexDirection: 'row',
alignSelf: 'flex-start',
backgroundColor: '#FF5A5F',
paddingVertical: 2,
paddingHorizontal: 4,
borderRadius: 3,
borderColor: '#D23F44',
borderWidth: 0.5,
},
dollar: {
color: '#fff',
fontSize: 10,
},
amount: {
color: '#fff',
fontSize: 13,
},
arrow: {
backgroundColor: 'transparent',
borderColor: 'transparent',
borderWidth: 4,
borderTopColor: '#FF5A5F',
alignSelf: 'center',
marginTop: -9,
},
arrowBorder: {
backgroundColor: 'transparent',
borderColor: 'transparent',
borderWidth: 4,
borderTopColor: '#D23F44',
alignSelf: 'center',
marginTop: -0.5,
},
selectedBubble: {
backgroundColor: '#4da2ab',
borderColor: '#007a87',
},
selectedArrow: {
borderTopColor: '#4da2ab',
},
selectedArrowBorder: {
borderTopColor: '#007a87',
},
});

export default AnimatedPriceMarker;
</file>

<file path="example/src/examples/AnimatedViews.tsx">
import React from 'react';
import {StyleSheet, View, Dimensions, Animated} from 'react-native';

import {
Animated as AnimatedMap,
AnimatedRegion,
Marker,
} from 'react-native-maps';
import PanController from './PanController';
import PriceMarker from './AnimatedPriceMarker';

const screen = Dimensions.get('window');

const ASPECT_RATIO = screen.width / screen.height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

const ITEM_SPACING = 10;
const ITEM_PREVIEW = 10;
const ITEM_WIDTH = screen.width - 2 _ ITEM_SPACING - 2 _ ITEM_PREVIEW;
const SNAP_WIDTH = ITEM_WIDTH + ITEM_SPACING;
const ITEM_PREVIEW_HEIGHT = 150;
const SCALE_END = screen.width / ITEM_WIDTH;
const BREAKPOINT1 = 246;
const BREAKPOINT2 = 350;
const ONE = new Animated.Value(1);

function getMarkerState(panX: any, panY: any, scrollY: any, i: any) {
const xLeft = -SNAP_WIDTH _ i + SNAP_WIDTH / 2;
const xRight = -SNAP_WIDTH _ i - SNAP_WIDTH / 2;
const xPos = -SNAP_WIDTH \* i;

const isIndex = panX.interpolate({
inputRange: [xRight - 1, xRight, xLeft, xLeft + 1],
outputRange: [0, 1, 1, 0],
extrapolate: 'clamp',
});

const isNotIndex = panX.interpolate({
inputRange: [xRight - 1, xRight, xLeft, xLeft + 1],
outputRange: [1, 0, 0, 1],
extrapolate: 'clamp',
});

const center = panX.interpolate({
inputRange: [xPos - 10, xPos, xPos + 10],
outputRange: [0, 1, 0],
extrapolate: 'clamp',
});

const selected = panX.interpolate({
inputRange: [xRight, xPos, xLeft],
outputRange: [0, 1, 0],
extrapolate: 'clamp',
});

const translateY = Animated.multiply(isIndex, panY);

const translateX = panX;

const anim = Animated.multiply(
isIndex,
scrollY.interpolate({
inputRange: [0, BREAKPOINT1],
outputRange: [0, 1],
extrapolate: 'clamp',
}),
);

const scale = Animated.add(
ONE,
Animated.multiply(
isIndex,
scrollY.interpolate({
inputRange: [BREAKPOINT1, BREAKPOINT2],
outputRange: [0, SCALE_END - 1],
extrapolate: 'clamp',
}),
),
);

// [0 => 1]
let opacity = scrollY.interpolate({
inputRange: [BREAKPOINT1, BREAKPOINT2],
outputRange: [0, 1],
extrapolate: 'clamp',
});

// if i === index: [0 => 0]
// if i !== index: [0 => 1]
opacity = Animated.multiply(isNotIndex, opacity);

// if i === index: [1 => 1]
// if i !== index: [1 => 0]
opacity = opacity.interpolate({
inputRange: [0, 1],
outputRange: [1, 0],
});

let markerOpacity = scrollY.interpolate({
inputRange: [0, BREAKPOINT1],
outputRange: [0, 1],
extrapolate: 'clamp',
});

markerOpacity = Animated.multiply(isNotIndex, markerOpacity).interpolate({
inputRange: [0, 1],
outputRange: [1, 0],
});

const markerScale = selected.interpolate({
inputRange: [0, 1],
outputRange: [1, 1.2],
});

return {
translateY,
translateX,
scale,
opacity,
anim,
center,
selected,
markerOpacity,
markerScale,
};
}

class AnimatedViews extends React.Component<any, any> {
constructor(props: any) {
super(props);

    const panX = new Animated.Value(0);
    const panY = new Animated.Value(0);

    const scrollY = panY.interpolate({
      inputRange: [-1, 1],
      outputRange: [1, -1],
    });

    const scrollX = panX.interpolate({
      inputRange: [-1, 1],
      outputRange: [1, -1],
    });

    const scale = scrollY.interpolate({
      inputRange: [0, BREAKPOINT1],
      outputRange: [1, 1.6],
      extrapolate: 'clamp',
    });

    const translateY = scrollY.interpolate({
      inputRange: [0, BREAKPOINT1],
      outputRange: [0, -100],
      extrapolate: 'clamp',
    });

    const markers = [
      {
        id: 0,
        amount: 99,
        coordinate: {
          latitude: LATITUDE,
          longitude: LONGITUDE,
        },
      },
      {
        id: 1,
        amount: 199,
        coordinate: {
          latitude: LATITUDE + 0.004,
          longitude: LONGITUDE - 0.004,
        },
      },
      {
        id: 2,
        amount: 285,
        coordinate: {
          latitude: LATITUDE - 0.004,
          longitude: LONGITUDE - 0.004,
        },
      },
    ];

    const animations = markers.map((m, i) =>
      getMarkerState(panX, panY, scrollY, i),
    );

    this.state = {
      panX,
      panY,
      animations,
      index: 0,
      canMoveHorizontal: true,
      scrollY,
      scrollX,
      scale,
      translateY,
      markers,
      region: new AnimatedRegion({
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      }),
    };

}

componentDidMount() {
const {region, panX, panY, scrollX, markers} = this.state;

    panX.addListener(this.onPanXChange);
    panY.addListener(this.onPanYChange);

    region.stopAnimation();
    region
      .timing({
        latitude: scrollX.interpolate({
          inputRange: markers.map((m: any, i: any) => i * SNAP_WIDTH),
          outputRange: markers.map((m: any) => m.coordinate.latitude),
        }),
        longitude: scrollX.interpolate({
          inputRange: markers.map((m: any, i: any) => i * SNAP_WIDTH),
          outputRange: markers.map((m: any) => m.coordinate.longitude),
        }),
        useNativeDriver: true, // defaults to false if not passed explicitly
        duration: 0,
      })
      .start();

}

onStartShouldSetPanResponder = (e: any) => {
// we only want to move the view if they are starting the gesture on top
// of the view, so this calculates that and returns true if so. If we return
// false, the gesture should get passed to the map view appropriately.
const {panY} = this.state;
const {pageY} = e.nativeEvent;
const topOfMainWindow = ITEM_PREVIEW_HEIGHT + panY.\_\_getValue();
const topOfTap = screen.height - pageY;

    return topOfTap < topOfMainWindow;

};

onMoveShouldSetPanResponder = (e: any) => {
const {panY} = this.state;
const {pageY} = e.nativeEvent;
const topOfMainWindow = ITEM_PREVIEW_HEIGHT + panY.\_\_getValue();
const topOfTap = screen.height - pageY;

    return topOfTap < topOfMainWindow;

};

onPanXChange = ({value}: any) => {
const {index} = this.state;
const newIndex = Math.floor((-1 \* value + SNAP_WIDTH / 2) / SNAP_WIDTH);
if (index !== newIndex) {
this.setState({index: newIndex});
}
};

onPanYChange = ({value}: any) => {
const {canMoveHorizontal, region, scrollY, scrollX, markers, index} =
this.state;
const shouldBeMovable = Math.abs(value) < 2;
if (shouldBeMovable !== canMoveHorizontal) {
this.setState({canMoveHorizontal: shouldBeMovable});
if (!shouldBeMovable) {
const {coordinate} = markers[index];
region.stopAnimation();
region
.timing({
latitude: scrollY.interpolate({
inputRange: [0, BREAKPOINT1],
outputRange: [
coordinate.latitude,
coordinate.latitude - LATITUDE_DELTA * 0.5 * 0.375,
],
extrapolate: 'clamp',
}),
latitudeDelta: scrollY.interpolate({
inputRange: [0, BREAKPOINT1],
outputRange: [LATITUDE_DELTA, LATITUDE_DELTA * 0.5],
extrapolate: 'clamp',
}),
longitudeDelta: scrollY.interpolate({
inputRange: [0, BREAKPOINT1],
outputRange: [LONGITUDE_DELTA, LONGITUDE_DELTA * 0.5],
extrapolate: 'clamp',
}),
useNativeDriver: true, // defaults to false if not passed explictly
duration: 0,
})
.start();
} else {
region.stopAnimation();
region
.timing({
latitude: scrollX.interpolate({
inputRange: markers.map((m: any, i: any) => i _ SNAP_WIDTH),
outputRange: markers.map((m: any) => m.coordinate.latitude),
}),
longitude: scrollX.interpolate({
inputRange: markers.map((m: any, i: any) => i _ SNAP_WIDTH),
outputRange: markers.map((m: any) => m.coordinate.longitude),
}),
useNativeDriver: true, // defaults to false if not passed explictly
duration: 0,
})
.start();
}
}
};

onRegionChange(/_ region _/) {
// this.state.region.setValue(region);
}

render() {
const {panX, panY, animations, canMoveHorizontal, markers, region} =
this.state;

    return (
      <View style={styles.container}>
        <PanController
          style={styles.container}
          vertical
          horizontal={canMoveHorizontal}
          xMode="snap"
          snapSpacingX={SNAP_WIDTH}
          yBounds={[-1 * screen.height, 0]}
          xBounds={[-screen.width * (markers.length - 1), 0]}
          panY={panY}
          panX={panX}
          onStartShouldSetPanResponder={this.onStartShouldSetPanResponder}
          onMoveShouldSetPanResponder={this.onMoveShouldSetPanResponder}>
          <AnimatedMap
            provider={this.props.provider}
            style={styles.map}
            region={region}
            onRegionChange={this.onRegionChange}>
            {markers.map((marker: any, i: any) => {
              const {selected, markerOpacity, markerScale} = animations[i];

              return (
                <Marker key={marker.id} coordinate={marker.coordinate}>
                  <PriceMarker
                    style={{
                      opacity: markerOpacity,
                      transform: [{scale: markerScale}],
                    }}
                    amount={marker.amount}
                    selected={selected}
                  />
                </Marker>
              );
            })}
          </AnimatedMap>
          <View style={styles.itemContainer}>
            {markers.map((marker: any, i: any) => {
              const {translateY, translateX, scale, opacity} = animations[i];

              return (
                <Animated.View
                  key={marker.id}
                  style={[
                    styles.item,
                    {
                      opacity,
                      transform: [{translateY}, {translateX}, {scale}],
                    },
                  ]}
                />
              );
            })}
          </View>
        </PanController>
      </View>
    );

}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
},
itemContainer: {
backgroundColor: 'transparent',
flexDirection: 'row',
paddingHorizontal: ITEM_SPACING / 2 + ITEM_PREVIEW,
position: 'absolute',
// top: screen.height - ITEM_PREVIEW_HEIGHT - 64,
paddingTop: screen.height - ITEM_PREVIEW_HEIGHT - 64,
// paddingTop: !ANDROID ? 0 : screen.height - ITEM_PREVIEW_HEIGHT - 64,
},
map: {
backgroundColor: 'transparent',
...StyleSheet.absoluteFillObject,
},
item: {
width: ITEM_WIDTH,
height: screen.height + 2 \* ITEM_PREVIEW_HEIGHT,
backgroundColor: 'red',
marginHorizontal: ITEM_SPACING / 2,
overflow: 'hidden',
borderRadius: 3,
borderColor: '#000',
},
});

export default AnimatedViews;
</file>

<file path="example/src/examples/BugMarkerWontUpdate.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';
import MapView from 'react-native-maps';
import MyLocationMapMarker from './MyLocationMapMarker';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class BugMarkerWontUpdate extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      coordinate: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
      },
      amount: 0,
      enableHack: false,
    };

}

increment() {
this.setState({amount: this.state.amount + 10});
}

decrement() {
this.setState({amount: this.state.amount - 10});
}

toggleHack() {
this.setState({enableHack: !this.state.enableHack});
}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}>
<MyLocationMapMarker
// coordinate={this.state.coordinate}
// heading={this.state.amount}
// enableHack={this.state.enableHack}
/>
</MapView>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.toggleHack()}
style={[styles.bubble, styles.button, styles.hackButton]}>
<Text style={styles.toggleHack}>
{this.state.enableHack ? 'Disable Hack' : 'Enable Hack'}
</Text>
</TouchableOpacity>
</View>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.decrement()}
style={[styles.bubble, styles.button]}>
<Text style={styles.ammountButton}>-</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.increment()}
style={[styles.bubble, styles.button]}>
<Text style={styles.ammountButton}>+</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
hackButton: {
width: 200,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
toggleHack: {fontSize: 12, fontWeight: 'bold'},
ammountButton: {fontSize: 20, fontWeight: 'bold'},
});

export default BugMarkerWontUpdate;
</file>

<file path="example/src/examples/CachedMap.tsx">
import React from 'react';
import {
  Text,
  View,
  Dimensions,
  StyleSheet,
  FlatList,
  TouchableOpacity,
} from 'react-native';

import MapView, {Marker} from 'react-native-maps';
import flagImg from './assets/flag-blue.png';

const HORIZONTAL_PADDING = 12;
const VERTICAL_PADDING = 6;

class CachedMap extends React.Component<any, any> {
constructor(props: any) {
super(props);
this.state = {
data: {...COUNTRIES},
cache: true,
};
}

toggleCache() {
// a hack to force listview to reload with the same data
this.setState({
data: this.state.data,
});
this.setState({
cache: !this.state.cache,
data: {...COUNTRIES},
});
}

render() {
const {width} = Dimensions.get('window');
const mapSize = width - HORIZONTAL_PADDING \* 2;
return (
<View style={styles.container}>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.toggleCache()}
style={[styles.bubble, styles.button]}>
<Text style={styles.buttonText}>
{this.state.cache ? 'Cached' : 'Not cached'}
</Text>
</TouchableOpacity>
</View>
<FlatList
data={this.state.data}
renderItem={({item: region}) => (
<View style={styles.item}>
<Text>{region.name}</Text>
<MapView
provider={this.props.provider}
style={{
                  width: mapSize,
                  height: mapSize,
                }}
initialRegion={region}
cacheEnabled={this.state.cache}
zoomEnabled
loadingIndicatorColor="#666666"
loadingBackgroundColor="#eeeeee">
<Marker
coordinate={region}
centerOffset={{x: -18, y: -60}}
anchor={{x: 0.69, y: 1}}
image={flagImg}
/>
</MapView>
</View>
)}
keyExtractor={(item, index) => index.toString()}
/>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
flex: 1,
},
item: {
backgroundColor: 'white',
paddingHorizontal: HORIZONTAL_PADDING,
paddingVertical: VERTICAL_PADDING,
},
bubble: {
backgroundColor: 'rgba(0,128,255,1.0)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
button: {
width: 100,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
justifyContent: 'flex-end',
},
buttonText: {
color: 'white',
},
});

const COUNTRIES = [
{
latitude: 33.93911,
longitudeDelta: 10.0,
name: 'Afghanistan',
longitude: 67.709953,
latitudeDelta: 10.0,
},
{
latitude: 41.153332,
longitudeDelta: 10.0,
name: 'Albania',
longitude: 20.168331,
latitudeDelta: 10.0,
},
{
latitude: 28.033886,
longitudeDelta: 10.0,
name: 'Algeria',
longitude: 1.659626,
latitudeDelta: 10.0,
},
{
latitude: -14.270972,
longitudeDelta: 10.0,
name: 'American Samoa',
longitude: -170.132217,
latitudeDelta: 10.0,
},
{
latitude: 42.546245,
longitudeDelta: 10.0,
name: 'Andorra',
longitude: 1.601554,
latitudeDelta: 10.0,
},
{
latitude: -11.202692,
longitudeDelta: 10.0,
name: 'Angola',
longitude: 17.873887,
latitudeDelta: 10.0,
},
{
latitude: 18.220554,
longitudeDelta: 10.0,
name: 'Anguilla',
longitude: -63.068615,
latitudeDelta: 10.0,
},
{
latitude: -75.250973,
longitudeDelta: 10.0,
name: 'Antarctica',
longitude: -0.071389,
latitudeDelta: 10.0,
},
{
latitude: 17.060816,
longitudeDelta: 10.0,
name: 'Antigua and Barbuda',
longitude: -61.796428,
latitudeDelta: 10.0,
},
{
latitude: -38.416097,
longitudeDelta: 10.0,
name: 'Argentina',
longitude: -63.616672,
latitudeDelta: 10.0,
},
{
latitude: 40.069099,
longitudeDelta: 10.0,
name: 'Armenia',
longitude: 45.038189,
latitudeDelta: 10.0,
},
{
latitude: 12.52111,
longitudeDelta: 10.0,
name: 'Aruba',
longitude: -69.968338,
latitudeDelta: 10.0,
},
{
latitude: -25.274398,
longitudeDelta: 10.0,
name: 'Australia',
longitude: 133.775136,
latitudeDelta: 10.0,
},
{
latitude: 47.516231,
longitudeDelta: 10.0,
name: 'Austria',
longitude: 14.550072,
latitudeDelta: 10.0,
},
{
latitude: 40.143105,
longitudeDelta: 10.0,
name: 'Azerbaijan',
longitude: 47.576927,
latitudeDelta: 10.0,
},
{
latitude: 25.03428,
longitudeDelta: 10.0,
name: 'Bahamas',
longitude: -77.39628,
latitudeDelta: 10.0,
},
{
latitude: 25.930414,
longitudeDelta: 10.0,
name: 'Bahrain',
longitude: 50.637772,
latitudeDelta: 10.0,
},
{
latitude: 23.684994,
longitudeDelta: 10.0,
name: 'Bangladesh',
longitude: 90.356331,
latitudeDelta: 10.0,
},
{
latitude: 13.193887,
longitudeDelta: 10.0,
name: 'Barbados',
longitude: -59.543198,
latitudeDelta: 10.0,
},
{
latitude: 53.709807,
longitudeDelta: 10.0,
name: 'Belarus',
longitude: 27.953389,
latitudeDelta: 10.0,
},
{
latitude: 50.503887,
longitudeDelta: 10.0,
name: 'Belgium',
longitude: 4.469936,
latitudeDelta: 10.0,
},
{
latitude: 17.189877,
longitudeDelta: 10.0,
name: 'Belize',
longitude: -88.49765,
latitudeDelta: 10.0,
},
{
latitude: 9.30769,
longitudeDelta: 10.0,
name: 'Benin',
longitude: 2.315834,
latitudeDelta: 10.0,
},
{
latitude: 32.321384,
longitudeDelta: 10.0,
name: 'Bermuda',
longitude: -64.75737,
latitudeDelta: 10.0,
},
{
latitude: 27.514162,
longitudeDelta: 10.0,
name: 'Bhutan',
longitude: 90.433601,
latitudeDelta: 10.0,
},
{
latitude: -16.290154,
longitudeDelta: 10.0,
name: 'Bolivia',
longitude: -63.588653,
latitudeDelta: 10.0,
},
{
latitude: 43.915886,
longitudeDelta: 10.0,
name: 'Bosnia and Herzegovina',
longitude: 17.679076,
latitudeDelta: 10.0,
},
{
latitude: -22.328474,
longitudeDelta: 10.0,
name: 'Botswana',
longitude: 24.684866,
latitudeDelta: 10.0,
},
{
latitude: -54.423199,
longitudeDelta: 10.0,
name: 'Bouvet Island',
longitude: 3.413194,
latitudeDelta: 10.0,
},
{
latitude: -14.235004,
longitudeDelta: 10.0,
name: 'Brazil',
longitude: -51.92528,
latitudeDelta: 10.0,
},
{
latitude: -6.343194,
longitudeDelta: 10.0,
name: 'British Indian Ocean Territory',
longitude: 71.876519,
latitudeDelta: 10.0,
},
{
latitude: 18.420695,
longitudeDelta: 10.0,
name: 'British Virgin Islands',
longitude: -64.639968,
latitudeDelta: 10.0,
},
{
latitude: 4.535277,
longitudeDelta: 10.0,
name: 'Brunei',
longitude: 114.727669,
latitudeDelta: 10.0,
},
{
latitude: 42.733883,
longitudeDelta: 10.0,
name: 'Bulgaria',
longitude: 25.48583,
latitudeDelta: 10.0,
},
{
latitude: 12.238333,
longitudeDelta: 10.0,
name: 'Burkina Faso',
longitude: -1.561593,
latitudeDelta: 10.0,
},
{
latitude: -3.373056,
longitudeDelta: 10.0,
name: 'Burundi',
longitude: 29.918886,
latitudeDelta: 10.0,
},
{
latitude: 12.565679,
longitudeDelta: 10.0,
name: 'Cambodia',
longitude: 104.990963,
latitudeDelta: 10.0,
},
{
latitude: 7.369722,
longitudeDelta: 10.0,
name: 'Cameroon',
longitude: 12.354722,
latitudeDelta: 10.0,
},
{
latitude: 56.130366,
longitudeDelta: 10.0,
name: 'Canada',
longitude: -106.346771,
latitudeDelta: 10.0,
},
{
latitude: 16.002082,
longitudeDelta: 10.0,
name: 'Cape Verde',
longitude: -24.013197,
latitudeDelta: 10.0,
},
{
latitude: 19.513469,
longitudeDelta: 10.0,
name: 'Cayman Islands',
longitude: -80.566956,
latitudeDelta: 10.0,
},
{
latitude: 6.611111,
longitudeDelta: 10.0,
name: 'Central African Republic',
longitude: 20.939444,
latitudeDelta: 10.0,
},
{
latitude: 15.454166,
longitudeDelta: 10.0,
name: 'Chad',
longitude: 18.732207,
latitudeDelta: 10.0,
},
{
latitude: -35.675147,
longitudeDelta: 10.0,
name: 'Chile',
longitude: -71.542969,
latitudeDelta: 10.0,
},
{
latitude: 35.86166,
longitudeDelta: 10.0,
name: 'China',
longitude: 104.195397,
latitudeDelta: 10.0,
},
{
latitude: -10.447525,
longitudeDelta: 10.0,
name: 'Christmas Island',
longitude: 105.690449,
latitudeDelta: 10.0,
},
{
latitude: -12.164165,
longitudeDelta: 10.0,
name: 'Cocos [Keeling] Islands',
longitude: 96.870956,
latitudeDelta: 10.0,
},
{
latitude: 4.570868,
longitudeDelta: 10.0,
name: 'Colombia',
longitude: -74.297333,
latitudeDelta: 10.0,
},
{
latitude: -11.875001,
longitudeDelta: 10.0,
name: 'Comoros',
longitude: 43.872219,
latitudeDelta: 10.0,
},
{
latitude: -4.038333,
longitudeDelta: 10.0,
name: 'Congo [DRC]',
longitude: 21.758664,
latitudeDelta: 10.0,
},
{
latitude: -0.228021,
longitudeDelta: 10.0,
name: 'Congo [Republic]',
longitude: 15.827659,
latitudeDelta: 10.0,
},
{
latitude: -21.236736,
longitudeDelta: 10.0,
name: 'Cook Islands',
longitude: -159.777671,
latitudeDelta: 10.0,
},
{
latitude: 9.748917,
longitudeDelta: 10.0,
name: 'Costa Rica',
longitude: -83.753428,
latitudeDelta: 10.0,
},
{
latitude: 45.1,
longitudeDelta: 10.0,
name: 'Croatia',
longitude: 15.2,
latitudeDelta: 10.0,
},
{
latitude: 21.521757,
longitudeDelta: 10.0,
name: 'Cuba',
longitude: -77.781167,
latitudeDelta: 10.0,
},
{
latitude: 35.126413,
longitudeDelta: 10.0,
name: 'Cyprus',
longitude: 33.429859,
latitudeDelta: 10.0,
},
{
latitude: 49.817492,
longitudeDelta: 10.0,
name: 'Czech Republic',
longitude: 15.472962,
latitudeDelta: 10.0,
},
{
latitude: 7.539989,
longitudeDelta: 10.0,
name: "C\u00f4te d'Ivoire",
longitude: -5.54708,
latitudeDelta: 10.0,
},
{
latitude: 56.26392,
longitudeDelta: 10.0,
name: 'Denmark',
longitude: 9.501785,
latitudeDelta: 10.0,
},
{
latitude: 11.825138,
longitudeDelta: 10.0,
name: 'Djibouti',
longitude: 42.590275,
latitudeDelta: 10.0,
},
{
latitude: 15.414999,
longitudeDelta: 10.0,
name: 'Dominica',
longitude: -61.370976,
latitudeDelta: 10.0,
},
{
latitude: 18.735693,
longitudeDelta: 10.0,
name: 'Dominican Republic',
longitude: -70.162651,
latitudeDelta: 10.0,
},
{
latitude: -1.831239,
longitudeDelta: 10.0,
name: 'Ecuador',
longitude: -78.183406,
latitudeDelta: 10.0,
},
{
latitude: 26.820553,
longitudeDelta: 10.0,
name: 'Egypt',
longitude: 30.802498,
latitudeDelta: 10.0,
},
{
latitude: 13.794185,
longitudeDelta: 10.0,
name: 'El Salvador',
longitude: -88.89653,
latitudeDelta: 10.0,
},
{
latitude: 1.650801,
longitudeDelta: 10.0,
name: 'Equatorial Guinea',
longitude: 10.267895,
latitudeDelta: 10.0,
},
{
latitude: 15.179384,
longitudeDelta: 10.0,
name: 'Eritrea',
longitude: 39.782334,
latitudeDelta: 10.0,
},
{
latitude: 58.595272,
longitudeDelta: 10.0,
name: 'Estonia',
longitude: 25.013607,
latitudeDelta: 10.0,
},
{
latitude: 9.145,
longitudeDelta: 10.0,
name: 'Ethiopia',
longitude: 40.489673,
latitudeDelta: 10.0,
},
{
latitude: -51.796253,
longitudeDelta: 10.0,
name: 'Falkland Islands [Islas Malvinas]',
longitude: -59.523613,
latitudeDelta: 10.0,
},
{
latitude: 61.892635,
longitudeDelta: 10.0,
name: 'Faroe Islands',
longitude: -6.911806,
latitudeDelta: 10.0,
},
{
latitude: -16.578193,
longitudeDelta: 10.0,
name: 'Fiji',
longitude: 179.414413,
latitudeDelta: 10.0,
},
{
latitude: 61.92411,
longitudeDelta: 10.0,
name: 'Finland',
longitude: 25.748151,
latitudeDelta: 10.0,
},
{
latitude: 46.227638,
longitudeDelta: 10.0,
name: 'France',
longitude: 2.213749,
latitudeDelta: 10.0,
},
{
latitude: 3.933889,
longitudeDelta: 10.0,
name: 'French Guiana',
longitude: -53.125782,
latitudeDelta: 10.0,
},
{
latitude: -17.679742,
longitudeDelta: 10.0,
name: 'French Polynesia',
longitude: -149.406843,
latitudeDelta: 10.0,
},
{
latitude: -49.280366,
longitudeDelta: 10.0,
name: 'French Southern Territories',
longitude: 69.348557,
latitudeDelta: 10.0,
},
{
latitude: -0.803689,
longitudeDelta: 10.0,
name: 'Gabon',
longitude: 11.609444,
latitudeDelta: 10.0,
},
{
latitude: 13.443182,
longitudeDelta: 10.0,
name: 'Gambia',
longitude: -15.310139,
latitudeDelta: 10.0,
},
{
latitude: 31.354676,
longitudeDelta: 10.0,
name: 'Gaza Strip',
longitude: 34.308825,
latitudeDelta: 10.0,
},
{
latitude: 42.315407,
longitudeDelta: 10.0,
name: 'Georgia',
longitude: 43.356892,
latitudeDelta: 10.0,
},
{
latitude: 51.165691,
longitudeDelta: 10.0,
name: 'Germany',
longitude: 10.451526,
latitudeDelta: 10.0,
},
{
latitude: 7.946527,
longitudeDelta: 10.0,
name: 'Ghana',
longitude: -1.023194,
latitudeDelta: 10.0,
},
{
latitude: 36.137741,
longitudeDelta: 10.0,
name: 'Gibraltar',
longitude: -5.345374,
latitudeDelta: 10.0,
},
{
latitude: 39.074208,
longitudeDelta: 10.0,
name: 'Greece',
longitude: 21.824312,
latitudeDelta: 10.0,
},
{
latitude: 71.706936,
longitudeDelta: 10.0,
name: 'Greenland',
longitude: -42.604303,
latitudeDelta: 10.0,
},
{
latitude: 12.262776,
longitudeDelta: 10.0,
name: 'Grenada',
longitude: -61.604171,
latitudeDelta: 10.0,
},
{
latitude: 16.995971,
longitudeDelta: 10.0,
name: 'Guadeloupe',
longitude: -62.067641,
latitudeDelta: 10.0,
},
{
latitude: 13.444304,
longitudeDelta: 10.0,
name: 'Guam',
longitude: 144.793731,
latitudeDelta: 10.0,
},
{
latitude: 15.783471,
longitudeDelta: 10.0,
name: 'Guatemala',
longitude: -90.230759,
latitudeDelta: 10.0,
},
{
latitude: 49.465691,
longitudeDelta: 10.0,
name: 'Guernsey',
longitude: -2.585278,
latitudeDelta: 10.0,
},
{
latitude: 9.945587,
longitudeDelta: 10.0,
name: 'Guinea',
longitude: -9.696645,
latitudeDelta: 10.0,
},
{
latitude: 11.803749,
longitudeDelta: 10.0,
name: 'Guinea-Bissau',
longitude: -15.180413,
latitudeDelta: 10.0,
},
{
latitude: 4.860416,
longitudeDelta: 10.0,
name: 'Guyana',
longitude: -58.93018,
latitudeDelta: 10.0,
},
{
latitude: 18.971187,
longitudeDelta: 10.0,
name: 'Haiti',
longitude: -72.285215,
latitudeDelta: 10.0,
},
{
latitude: -53.08181,
longitudeDelta: 10.0,
name: 'Heard Island and McDonald Islands',
longitude: 73.504158,
latitudeDelta: 10.0,
},
{
latitude: 15.199999,
longitudeDelta: 10.0,
name: 'Honduras',
longitude: -86.241905,
latitudeDelta: 10.0,
},
{
latitude: 22.396428,
longitudeDelta: 10.0,
name: 'Hong Kong',
longitude: 114.109497,
latitudeDelta: 10.0,
},
{
latitude: 47.162494,
longitudeDelta: 10.0,
name: 'Hungary',
longitude: 19.503304,
latitudeDelta: 10.0,
},
{
latitude: 64.963051,
longitudeDelta: 10.0,
name: 'Iceland',
longitude: -19.020835,
latitudeDelta: 10.0,
},
{
latitude: 20.593684,
longitudeDelta: 10.0,
name: 'India',
longitude: 78.96288,
latitudeDelta: 10.0,
},
{
latitude: -0.789275,
longitudeDelta: 10.0,
name: 'Indonesia',
longitude: 113.921327,
latitudeDelta: 10.0,
},
{
latitude: 32.427908,
longitudeDelta: 10.0,
name: 'Iran',
longitude: 53.688046,
latitudeDelta: 10.0,
},
{
latitude: 33.223191,
longitudeDelta: 10.0,
name: 'Iraq',
longitude: 43.679291,
latitudeDelta: 10.0,
},
{
latitude: 53.41291,
longitudeDelta: 10.0,
name: 'Ireland',
longitude: -8.24389,
latitudeDelta: 10.0,
},
{
latitude: 54.236107,
longitudeDelta: 10.0,
name: 'Isle of Man',
longitude: -4.548056,
latitudeDelta: 10.0,
},
{
latitude: 31.046051,
longitudeDelta: 10.0,
name: 'Israel',
longitude: 34.851612,
latitudeDelta: 10.0,
},
{
latitude: 41.87194,
longitudeDelta: 10.0,
name: 'Italy',
longitude: 12.56738,
latitudeDelta: 10.0,
},
{
latitude: 18.109581,
longitudeDelta: 10.0,
name: 'Jamaica',
longitude: -77.297508,
latitudeDelta: 10.0,
},
{
latitude: 36.204824,
longitudeDelta: 10.0,
name: 'Japan',
longitude: 138.252924,
latitudeDelta: 10.0,
},
{
latitude: 49.214439,
longitudeDelta: 10.0,
name: 'Jersey',
longitude: -2.13125,
latitudeDelta: 10.0,
},
{
latitude: 30.585164,
longitudeDelta: 10.0,
name: 'Jordan',
longitude: 36.238414,
latitudeDelta: 10.0,
},
{
latitude: 48.019573,
longitudeDelta: 10.0,
name: 'Kazakhstan',
longitude: 66.923684,
latitudeDelta: 10.0,
},
{
latitude: -0.023559,
longitudeDelta: 10.0,
name: 'Kenya',
longitude: 37.906193,
latitudeDelta: 10.0,
},
{
latitude: -3.370417,
longitudeDelta: 10.0,
name: 'Kiribati',
longitude: -168.734039,
latitudeDelta: 10.0,
},
{
latitude: 42.602636,
longitudeDelta: 10.0,
name: 'Kosovo',
longitude: 20.902977,
latitudeDelta: 10.0,
},
{
latitude: 29.31166,
longitudeDelta: 10.0,
name: 'Kuwait',
longitude: 47.481766,
latitudeDelta: 10.0,
},
{
latitude: 41.20438,
longitudeDelta: 10.0,
name: 'Kyrgyzstan',
longitude: 74.766098,
latitudeDelta: 10.0,
},
{
latitude: 19.85627,
longitudeDelta: 10.0,
name: 'Laos',
longitude: 102.495496,
latitudeDelta: 10.0,
},
{
latitude: 56.879635,
longitudeDelta: 10.0,
name: 'Latvia',
longitude: 24.603189,
latitudeDelta: 10.0,
},
{
latitude: 33.854721,
longitudeDelta: 10.0,
name: 'Lebanon',
longitude: 35.862285,
latitudeDelta: 10.0,
},
{
latitude: -29.609988,
longitudeDelta: 10.0,
name: 'Lesotho',
longitude: 28.233608,
latitudeDelta: 10.0,
},
{
latitude: 6.428055,
longitudeDelta: 10.0,
name: 'Liberia',
longitude: -9.429499,
latitudeDelta: 10.0,
},
{
latitude: 26.3351,
longitudeDelta: 10.0,
name: 'Libya',
longitude: 17.228331,
latitudeDelta: 10.0,
},
{
latitude: 47.166,
longitudeDelta: 10.0,
name: 'Liechtenstein',
longitude: 9.555373,
latitudeDelta: 10.0,
},
{
latitude: 55.169438,
longitudeDelta: 10.0,
name: 'Lithuania',
longitude: 23.881275,
latitudeDelta: 10.0,
},
{
latitude: 49.815273,
longitudeDelta: 10.0,
name: 'Luxembourg',
longitude: 6.129583,
latitudeDelta: 10.0,
},
{
latitude: 22.198745,
longitudeDelta: 10.0,
name: 'Macau',
longitude: 113.543873,
latitudeDelta: 10.0,
},
{
latitude: 41.608635,
longitudeDelta: 10.0,
name: 'Macedonia [FYROM]',
longitude: 21.745275,
latitudeDelta: 10.0,
},
{
latitude: -18.766947,
longitudeDelta: 10.0,
name: 'Madagascar',
longitude: 46.869107,
latitudeDelta: 10.0,
},
{
latitude: -13.254308,
longitudeDelta: 10.0,
name: 'Malawi',
longitude: 34.301525,
latitudeDelta: 10.0,
},
{
latitude: 4.210484,
longitudeDelta: 10.0,
name: 'Malaysia',
longitude: 101.975766,
latitudeDelta: 10.0,
},
{
latitude: 3.202778,
longitudeDelta: 10.0,
name: 'Maldives',
longitude: 73.22068,
latitudeDelta: 10.0,
},
{
latitude: 17.570692,
longitudeDelta: 10.0,
name: 'Mali',
longitude: -3.996166,
latitudeDelta: 10.0,
},
{
latitude: 35.937496,
longitudeDelta: 10.0,
name: 'Malta',
longitude: 14.375416,
latitudeDelta: 10.0,
},
{
latitude: 7.131474,
longitudeDelta: 10.0,
name: 'Marshall Islands',
longitude: 171.184478,
latitudeDelta: 10.0,
},
{
latitude: 14.641528,
longitudeDelta: 10.0,
name: 'Martinique',
longitude: -61.024174,
latitudeDelta: 10.0,
},
{
latitude: 21.00789,
longitudeDelta: 10.0,
name: 'Mauritania',
longitude: -10.940835,
latitudeDelta: 10.0,
},
{
latitude: -20.348404,
longitudeDelta: 10.0,
name: 'Mauritius',
longitude: 57.552152,
latitudeDelta: 10.0,
},
{
latitude: -12.8275,
longitudeDelta: 10.0,
name: 'Mayotte',
longitude: 45.166244,
latitudeDelta: 10.0,
},
{
latitude: 23.634501,
longitudeDelta: 10.0,
name: 'Mexico',
longitude: -102.552784,
latitudeDelta: 10.0,
},
{
latitude: 7.425554,
longitudeDelta: 10.0,
name: 'Micronesia',
longitude: 150.550812,
latitudeDelta: 10.0,
},
{
latitude: 47.411631,
longitudeDelta: 10.0,
name: 'Moldova',
longitude: 28.369885,
latitudeDelta: 10.0,
},
{
latitude: 43.750298,
longitudeDelta: 10.0,
name: 'Monaco',
longitude: 7.412841,
latitudeDelta: 10.0,
},
{
latitude: 46.862496,
longitudeDelta: 10.0,
name: 'Mongolia',
longitude: 103.846656,
latitudeDelta: 10.0,
},
{
latitude: 42.708678,
longitudeDelta: 10.0,
name: 'Montenegro',
longitude: 19.37439,
latitudeDelta: 10.0,
},
{
latitude: 16.742498,
longitudeDelta: 10.0,
name: 'Montserrat',
longitude: -62.187366,
latitudeDelta: 10.0,
},
{
latitude: 31.791702,
longitudeDelta: 10.0,
name: 'Morocco',
longitude: -7.09262,
latitudeDelta: 10.0,
},
{
latitude: -18.665695,
longitudeDelta: 10.0,
name: 'Mozambique',
longitude: 35.529562,
latitudeDelta: 10.0,
},
{
latitude: 21.913965,
longitudeDelta: 10.0,
name: 'Myanmar [Burma]',
longitude: 95.956223,
latitudeDelta: 10.0,
},
{
latitude: -22.95764,
longitudeDelta: 10.0,
name: 'Namibia',
longitude: 18.49041,
latitudeDelta: 10.0,
},
{
latitude: -0.522778,
longitudeDelta: 10.0,
name: 'Nauru',
longitude: 166.931503,
latitudeDelta: 10.0,
},
{
latitude: 28.394857,
longitudeDelta: 10.0,
name: 'Nepal',
longitude: 84.124008,
latitudeDelta: 10.0,
},
{
latitude: 52.132633,
longitudeDelta: 10.0,
name: 'Netherlands',
longitude: 5.291266,
latitudeDelta: 10.0,
},
{
latitude: 12.226079,
longitudeDelta: 10.0,
name: 'Netherlands Antilles',
longitude: -69.060087,
latitudeDelta: 10.0,
},
{
latitude: -20.904305,
longitudeDelta: 10.0,
name: 'New Caledonia',
longitude: 165.618042,
latitudeDelta: 10.0,
},
{
latitude: -40.900557,
longitudeDelta: 10.0,
name: 'New Zealand',
longitude: 174.885971,
latitudeDelta: 10.0,
},
{
latitude: 12.865416,
longitudeDelta: 10.0,
name: 'Nicaragua',
longitude: -85.207229,
latitudeDelta: 10.0,
},
{
latitude: 17.607789,
longitudeDelta: 10.0,
name: 'Niger',
longitude: 8.081666,
latitudeDelta: 10.0,
},
{
latitude: 9.081999,
longitudeDelta: 10.0,
name: 'Nigeria',
longitude: 8.675277,
latitudeDelta: 10.0,
},
{
latitude: -19.054445,
longitudeDelta: 10.0,
name: 'Niue',
longitude: -169.867233,
latitudeDelta: 10.0,
},
{
latitude: -29.040835,
longitudeDelta: 10.0,
name: 'Norfolk Island',
longitude: 167.954712,
latitudeDelta: 10.0,
},
{
latitude: 40.339852,
longitudeDelta: 10.0,
name: 'North Korea',
longitude: 127.510093,
latitudeDelta: 10.0,
},
{
latitude: 17.33083,
longitudeDelta: 10.0,
name: 'Northern Mariana Islands',
longitude: 145.38469,
latitudeDelta: 10.0,
},
{
latitude: 60.472024,
longitudeDelta: 10.0,
name: 'Norway',
longitude: 8.468946,
latitudeDelta: 10.0,
},
{
latitude: 21.512583,
longitudeDelta: 10.0,
name: 'Oman',
longitude: 55.923255,
latitudeDelta: 10.0,
},
{
latitude: 30.375321,
longitudeDelta: 10.0,
name: 'Pakistan',
longitude: 69.345116,
latitudeDelta: 10.0,
},
{
latitude: 7.51498,
longitudeDelta: 10.0,
name: 'Palau',
longitude: 134.58252,
latitudeDelta: 10.0,
},
{
latitude: 31.952162,
longitudeDelta: 10.0,
name: 'Palestinian Territories',
longitude: 35.233154,
latitudeDelta: 10.0,
},
{
latitude: 8.537981,
longitudeDelta: 10.0,
name: 'Panama',
longitude: -80.782127,
latitudeDelta: 10.0,
},
{
latitude: -6.314993,
longitudeDelta: 10.0,
name: 'Papua New Guinea',
longitude: 143.95555,
latitudeDelta: 10.0,
},
{
latitude: -23.442503,
longitudeDelta: 10.0,
name: 'Paraguay',
longitude: -58.443832,
latitudeDelta: 10.0,
},
{
latitude: -9.189967,
longitudeDelta: 10.0,
name: 'Peru',
longitude: -75.015152,
latitudeDelta: 10.0,
},
{
latitude: 12.879721,
longitudeDelta: 10.0,
name: 'Philippines',
longitude: 121.774017,
latitudeDelta: 10.0,
},
{
latitude: -24.703615,
longitudeDelta: 10.0,
name: 'Pitcairn Islands',
longitude: -127.439308,
latitudeDelta: 10.0,
},
{
latitude: 51.919438,
longitudeDelta: 10.0,
name: 'Poland',
longitude: 19.145136,
latitudeDelta: 10.0,
},
{
latitude: 39.399872,
longitudeDelta: 10.0,
name: 'Portugal',
longitude: -8.224454,
latitudeDelta: 10.0,
},
{
latitude: 18.220833,
longitudeDelta: 10.0,
name: 'Puerto Rico',
longitude: -66.590149,
latitudeDelta: 10.0,
},
{
latitude: 25.354826,
longitudeDelta: 10.0,
name: 'Qatar',
longitude: 51.183884,
latitudeDelta: 10.0,
},
{
latitude: 45.943161,
longitudeDelta: 10.0,
name: 'Romania',
longitude: 24.96676,
latitudeDelta: 10.0,
},
{
latitude: 61.52401,
longitudeDelta: 10.0,
name: 'Russia',
longitude: 105.318756,
latitudeDelta: 10.0,
},
{
latitude: -1.940278,
longitudeDelta: 10.0,
name: 'Rwanda',
longitude: 29.873888,
latitudeDelta: 10.0,
},
{
latitude: -21.115141,
longitudeDelta: 10.0,
name: 'R\u00e9union',
longitude: 55.536384,
latitudeDelta: 10.0,
},
{
latitude: -24.143474,
longitudeDelta: 10.0,
name: 'Saint Helena',
longitude: -10.030696,
latitudeDelta: 10.0,
},
{
latitude: 17.357822,
longitudeDelta: 10.0,
name: 'Saint Kitts and Nevis',
longitude: -62.782998,
latitudeDelta: 10.0,
},
{
latitude: 13.909444,
longitudeDelta: 10.0,
name: 'Saint Lucia',
longitude: -60.978893,
latitudeDelta: 10.0,
},
{
latitude: 46.941936,
longitudeDelta: 10.0,
name: 'Saint Pierre and Miquelon',
longitude: -56.27111,
latitudeDelta: 10.0,
},
{
latitude: 12.984305,
longitudeDelta: 10.0,
name: 'Saint Vincent and the Grenadines',
longitude: -61.287228,
latitudeDelta: 10.0,
},
{
latitude: -13.759029,
longitudeDelta: 10.0,
name: 'Samoa',
longitude: -172.104629,
latitudeDelta: 10.0,
},
{
latitude: 43.94236,
longitudeDelta: 10.0,
name: 'San Marino',
longitude: 12.457777,
latitudeDelta: 10.0,
},
{
latitude: 23.885942,
longitudeDelta: 10.0,
name: 'Saudi Arabia',
longitude: 45.079162,
latitudeDelta: 10.0,
},
{
latitude: 14.497401,
longitudeDelta: 10.0,
name: 'Senegal',
longitude: -14.452362,
latitudeDelta: 10.0,
},
{
latitude: 44.016521,
longitudeDelta: 10.0,
name: 'Serbia',
longitude: 21.005859,
latitudeDelta: 10.0,
},
{
latitude: -4.679574,
longitudeDelta: 10.0,
name: 'Seychelles',
longitude: 55.491977,
latitudeDelta: 10.0,
},
{
latitude: 8.460555,
longitudeDelta: 10.0,
name: 'Sierra Leone',
longitude: -11.779889,
latitudeDelta: 10.0,
},
{
latitude: 1.352083,
longitudeDelta: 10.0,
name: 'Singapore',
longitude: 103.819836,
latitudeDelta: 10.0,
},
{
latitude: 48.669026,
longitudeDelta: 10.0,
name: 'Slovakia',
longitude: 19.699024,
latitudeDelta: 10.0,
},
{
latitude: 46.151241,
longitudeDelta: 10.0,
name: 'Slovenia',
longitude: 14.995463,
latitudeDelta: 10.0,
},
{
latitude: -9.64571,
longitudeDelta: 10.0,
name: 'Solomon Islands',
longitude: 160.156194,
latitudeDelta: 10.0,
},
{
latitude: 5.152149,
longitudeDelta: 10.0,
name: 'Somalia',
longitude: 46.199616,
latitudeDelta: 10.0,
},
{
latitude: -30.559482,
longitudeDelta: 10.0,
name: 'South Africa',
longitude: 22.937506,
latitudeDelta: 10.0,
},
{
latitude: -54.429579,
longitudeDelta: 10.0,
name: 'South Georgia and the South Sandwich Islands',
longitude: -36.587909,
latitudeDelta: 10.0,
},
{
latitude: 35.907757,
longitudeDelta: 10.0,
name: 'South Korea',
longitude: 127.766922,
latitudeDelta: 10.0,
},
{
latitude: 40.463667,
longitudeDelta: 10.0,
name: 'Spain',
longitude: -3.74922,
latitudeDelta: 10.0,
},
{
latitude: 7.873054,
longitudeDelta: 10.0,
name: 'Sri Lanka',
longitude: 80.771797,
latitudeDelta: 10.0,
},
{
latitude: 12.862807,
longitudeDelta: 10.0,
name: 'Sudan',
longitude: 30.217636,
latitudeDelta: 10.0,
},
{
latitude: 3.919305,
longitudeDelta: 10.0,
name: 'Suriname',
longitude: -56.027783,
latitudeDelta: 10.0,
},
{
latitude: 77.553604,
longitudeDelta: 10.0,
name: 'Svalbard and Jan Mayen',
longitude: 23.670272,
latitudeDelta: 10.0,
},
{
latitude: -26.522503,
longitudeDelta: 10.0,
name: 'Swaziland',
longitude: 31.465866,
latitudeDelta: 10.0,
},
{
latitude: 60.128161,
longitudeDelta: 10.0,
name: 'Sweden',
longitude: 18.643501,
latitudeDelta: 10.0,
},
{
latitude: 46.818188,
longitudeDelta: 10.0,
name: 'Switzerland',
longitude: 8.227512,
latitudeDelta: 10.0,
},
{
latitude: 34.802075,
longitudeDelta: 10.0,
name: 'Syria',
longitude: 38.996815,
latitudeDelta: 10.0,
},
{
latitude: 0.18636,
longitudeDelta: 10.0,
name: 'S\u00e3o Tom\u00e9 and Pr\u00edncipe',
longitude: 6.613081,
latitudeDelta: 10.0,
},
{
latitude: 23.69781,
longitudeDelta: 10.0,
name: 'Taiwan',
longitude: 120.960515,
latitudeDelta: 10.0,
},
{
latitude: 38.861034,
longitudeDelta: 10.0,
name: 'Tajikistan',
longitude: 71.276093,
latitudeDelta: 10.0,
},
{
latitude: -6.369028,
longitudeDelta: 10.0,
name: 'Tanzania',
longitude: 34.888822,
latitudeDelta: 10.0,
},
{
latitude: 15.870032,
longitudeDelta: 10.0,
name: 'Thailand',
longitude: 100.992541,
latitudeDelta: 10.0,
},
{
latitude: -8.874217,
longitudeDelta: 10.0,
name: 'Timor-Leste',
longitude: 125.727539,
latitudeDelta: 10.0,
},
{
latitude: 8.619543,
longitudeDelta: 10.0,
name: 'Togo',
longitude: 0.824782,
latitudeDelta: 10.0,
},
{
latitude: -8.967363,
longitudeDelta: 10.0,
name: 'Tokelau',
longitude: -171.855881,
latitudeDelta: 10.0,
},
{
latitude: -21.178986,
longitudeDelta: 10.0,
name: 'Tonga',
longitude: -175.198242,
latitudeDelta: 10.0,
},
{
latitude: 10.691803,
longitudeDelta: 10.0,
name: 'Trinidad and Tobago',
longitude: -61.222503,
latitudeDelta: 10.0,
},
{
latitude: 33.886917,
longitudeDelta: 10.0,
name: 'Tunisia',
longitude: 9.537499,
latitudeDelta: 10.0,
},
{
latitude: 38.963745,
longitudeDelta: 10.0,
name: 'Turkey',
longitude: 35.243322,
latitudeDelta: 10.0,
},
{
latitude: 38.969719,
longitudeDelta: 10.0,
name: 'Turkmenistan',
longitude: 59.556278,
latitudeDelta: 10.0,
},
{
latitude: 21.694025,
longitudeDelta: 10.0,
name: 'Turks and Caicos Islands',
longitude: -71.797928,
latitudeDelta: 10.0,
},
{
latitude: -7.109535,
longitudeDelta: 10.0,
name: 'Tuvalu',
longitude: 177.64933,
latitudeDelta: 10.0,
},
{
latitude: 18.335765,
longitudeDelta: 10.0,
name: 'U.S. Virgin Islands',
longitude: -64.896335,
latitudeDelta: 10.0,
},
{
latitude: 1.373333,
longitudeDelta: 10.0,
name: 'Uganda',
longitude: 32.290275,
latitudeDelta: 10.0,
},
{
latitude: 48.379433,
longitudeDelta: 10.0,
name: 'Ukraine',
longitude: 31.16558,
latitudeDelta: 10.0,
},
{
latitude: 23.424076,
longitudeDelta: 10.0,
name: 'United Arab Emirates',
longitude: 53.847818,
latitudeDelta: 10.0,
},
{
latitude: 55.378051,
longitudeDelta: 10.0,
name: 'United Kingdom',
longitude: -3.435973,
latitudeDelta: 10.0,
},
{
latitude: 37.09024,
longitudeDelta: 10.0,
name: 'United States',
longitude: -95.712891,
latitudeDelta: 10.0,
},
{
latitude: -32.522779,
longitudeDelta: 10.0,
name: 'Uruguay',
longitude: -55.765835,
latitudeDelta: 10.0,
},
{
latitude: 41.377491,
longitudeDelta: 10.0,
name: 'Uzbekistan',
longitude: 64.585262,
latitudeDelta: 10.0,
},
{
latitude: -15.376706,
longitudeDelta: 10.0,
name: 'Vanuatu',
longitude: 166.959158,
latitudeDelta: 10.0,
},
{
latitude: 41.902916,
longitudeDelta: 10.0,
name: 'Vatican City',
longitude: 12.453389,
latitudeDelta: 10.0,
},
{
latitude: 6.42375,
longitudeDelta: 10.0,
name: 'Venezuela',
longitude: -66.58973,
latitudeDelta: 10.0,
},
{
latitude: 14.058324,
longitudeDelta: 10.0,
name: 'Vietnam',
longitude: 108.277199,
latitudeDelta: 10.0,
},
{
latitude: -13.768752,
longitudeDelta: 10.0,
name: 'Wallis and Futuna',
longitude: -177.156097,
latitudeDelta: 10.0,
},
{
latitude: 24.215527,
longitudeDelta: 10.0,
name: 'Western Sahara',
longitude: -12.885834,
latitudeDelta: 10.0,
},
{
latitude: 15.552727,
longitudeDelta: 10.0,
name: 'Yemen',
longitude: 48.516388,
latitudeDelta: 10.0,
},
{
latitude: -13.133897,
longitudeDelta: 10.0,
name: 'Zambia',
longitude: 27.849332,
latitudeDelta: 10.0,
},
{
latitude: -19.015438,
longitudeDelta: 10.0,
name: 'Zimbabwe',
longitude: 29.154857,
latitudeDelta: 10.0,
},
];

export default CachedMap;
</file>

<file path="example/src/examples/CacheURLTiles.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';

import MapView, {MAP_TYPES, PROVIDER_DEFAULT, UrlTile} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class CustomTiles extends React.Component<any, any> {
constructor(props: any, context: any) {
super(props, context);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

}

get mapType() {
// MapKit does not support 'none' as a base map
return this.props.provider === PROVIDER_DEFAULT
? MAP_TYPES.STANDARD
: MAP_TYPES.NONE;
}

render() {
const {region} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          mapType={this.mapType}
          style={styles.map}
          initialRegion={region}>
<UrlTile
urlTemplate="https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png"
zIndex={-1}
// Test steps:
// 1) Without new tile provider properties: comment out tileCachePath & maximumNativeZ
// 2) With maximumNativeZ only to test scaling past maxNativeZoom level
// 3) With doubleTileSize (only on Android)
// 4) With tileCachePath too - test caching performance with cutting & throttling network connectivity
// 5) With tileCacheMaxAge too
// 6) With offlineMode=true too - test zoom in to test scaling of lower zoom level tiles to higher zoom levels
//
maximumNativeZ={15}
// For testing activate different tile cache paths, examples below
// work for simulator / emulator testing
// This is for iOS simulator, both as fileURL and directory paths to be tested separately
tileCachePath="file:///Users/suomimar/Library/Developer/CoreSimulator/tiles/"
//tileCachePath="/Users/suomimar/Library/Developer/CoreSimulator/tiles"
// This is for Android simulator, both as fileURL and directory paths to be tested separately
//tileCachePath="file:///data/user/0/com.airbnb.android.react.maps.example/files/tiles"
//tileCachePath="/data/user/0/com.airbnb.android.react.maps.example/files/tiles"
tileCacheMaxAge={20}
doubleTileSize={true}
opacity={1.0}
//offlineMode={true}
/>
</MapView>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text>Cached URLTiles</Text>
</View>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default CustomTiles;
</file>

<file path="example/src/examples/CacheWMSTiles.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';

import MapView, {MAP_TYPES, PROVIDER_DEFAULT, WMSTile} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 63.5;
const LONGITUDE = 23.5;
const LATITUDE_DELTA = 0.152;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class CustomTiles extends React.Component<any, any> {
constructor(props: any, context: any) {
super(props, context);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

}

get mapType() {
// MapKit does not support 'none' as a base map
return this.props.provider === PROVIDER_DEFAULT
? MAP_TYPES.STANDARD
: MAP_TYPES.NONE;
}

render() {
const {region} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          mapType={MAP_TYPES.SATELLITE}
          style={styles.map}
          initialRegion={region}>
<WMSTile
urlTemplate="https://julkinen.vayla.fi/inspirepalvelu/wms?service=WMS&version=1.1.1&request=GetMap&layers=avoin:TL137&format=image/png&transparent=true&styles=&bbox={minX},{minY},{maxX},{maxY}&width={width}&height={height}&srs=EPSG:3857"
zIndex={2}
tileSize={256}
// Test steps:
// 1) Without new tile provider properties: comment out tileCachePath & maximumNativeZ
// 2) With maximumNativeZ only to test scaling past maxNativeZoom level
// 3) With tileCachePath too - test caching performance with cutting & throttling network connectivity
// 4) With tileCacheMaxAge too
// 5) With offlineMode=true too - zoom in to test scaling of lower zoom level tiles to higher zoom levels
//
maximumNativeZ={12}
// For testing activate different tile cache paths, examples below
// work for simulator / emulator testing
// This is for iOS simulator, both as fileURL and directory paths to be tested separately
tileCachePath="file:///Users/suomimar/Library/Developer/CoreSimulator/wms_tiles"
//tileCachePath="/Users/suomimar/Library/Developer/CoreSimulator/wms_tiles"
// This is for Android simulator, both as fileURL and directory paths to be tested separately
//tileCachePath="file:///data/user/0/com.airbnb.android.react.maps.example/files/wms_tiles"
//tileCachePath="/data/user/0/com.airbnb.android.react.maps.example/files/wms_tiles"
tileCacheMaxAge={20}
opacity={1.0}
//offlineMode={true}
/>
</MapView>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text>Cached WMSTiles</Text>
</View>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default CustomTiles;
</file>

<file path="example/src/examples/Callouts.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
  Alert,
} from 'react-native';
import MapView, {Marker, Callout, CalloutSubview} from 'react-native-maps';
import CustomCallout from './CustomCallout';

const {width, height} = Dimensions.get('window');
const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

class Callouts extends React.Component<any, any> {
marker1: any;
marker2: any;
marker4: any;
constructor(props: any) {
super(props);

    this.state = {
      cnt: 0,
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      markers: [
        {
          coordinate: {
            latitude: LATITUDE + SPACE,
            longitude: LONGITUDE + SPACE,
          },
        },
        {
          coordinate: {
            latitude: LATITUDE + SPACE,
            longitude: LONGITUDE - SPACE,
          },
        },
        {
          coordinate: {
            latitude: LATITUDE,
            longitude: LONGITUDE,
          },
        },
        {
          coordinate: {
            latitude: LATITUDE,
            longitude: LONGITUDE - SPACE / 2,
          },
        },
      ],
    };

}

show() {
this.marker1.showCallout();
}

hide() {
this.marker1.hideCallout();
}

render() {
const {region, markers} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={region}
          zoomTapEnabled={false}>
<Marker
ref={ref => {
this.marker1 = ref;
}}
coordinate={markers[0].coordinate}
title="This is a native view"
description="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation"
/>
<Marker coordinate={markers[1].coordinate}>
<Callout style={styles.plainView}>
<View>
<Text>This is a plain view</Text>
</View>
</Callout>
</Marker>
<Marker
coordinate={markers[2].coordinate}
calloutOffset={{x: -8, y: 28}}
calloutAnchor={{x: 0.5, y: 0.4}}
ref={ref => {
this.marker2 = ref;
}}>
<Callout
alphaHitTest
tooltip
onPress={\_ => {
Alert.alert('callout pressed');
}}
style={styles.customView}>
<CustomCallout>
<Text>{`This is a custom callout bubble view ${this.state.cnt}`}</Text>
<CalloutSubview
onPress={() => {
this.setState({cnt: this.state.cnt + 1}, () => {
this.marker2.redrawCallout();
});
}}
style={[styles.calloutButton]}>
<Text>Click me</Text>
</CalloutSubview>
</CustomCallout>
</Callout>
</Marker>
<Marker
ref={ref => {
this.marker4 = ref;
}}
coordinate={markers[3].coordinate}
title="You can also open this callout"
description="by pressing on transparent area of custom callout"
/>
</MapView>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text>Tap on markers to see different callouts</Text>
</View>
</View>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.show()}
style={[styles.bubble, styles.button]}>
<Text>Show</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.hide()}
style={[styles.bubble, styles.button]}>
<Text>Hide</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
customView: {
width: 140,
height: 140,
},
plainView: {
width: 60,
},
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
calloutButton: {
width: 'auto',
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 6,
paddingVertical: 6,
borderRadius: 12,
alignItems: 'center',
marginHorizontal: 10,
marginVertical: 10,
},
});

export default Callouts;
</file>

<file path="example/src/examples/CameraControl.tsx">
import React from 'react';
import {StyleSheet, View, TouchableOpacity, Text, Alert} from 'react-native';

import MapView from 'react-native-maps';

const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;

class CameraControl extends React.Component<any, any> {
map: any;
async getCamera() {
const camera = await this.map.getCamera();
Alert.alert('Current camera', JSON.stringify(camera), [{text: 'OK'}], {
cancelable: true,
});
}

async setCamera() {
const camera = await this.map.getCamera();
// Note that we do not have to pass a full camera object to setCamera().
// Similar to setState(), we can pass only the properties you like to change.
this.map.setCamera({
heading: camera.heading + 10,
});
}

async animateCamera() {
const camera = await this.map.getCamera();
camera.heading += 40;
camera.pitch += 10;
camera.altitude += 1000;
camera.zoom -= 1;
camera.center.latitude += 0.5;
this.map.animateCamera(camera, {duration: 2000});
}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
ref={ref => {
this.map = ref;
}}
style={styles.map}
initialCamera={{
            center: {
              latitude: LATITUDE,
              longitude: LONGITUDE,
            },
            pitch: 45,
            heading: 90,
            altitude: 1000,
            zoom: 10,
          }}
/>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.getCamera()}
style={[styles.bubble, styles.button]}>
<Text>Get current camera</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.setCamera()}
style={[styles.bubble, styles.button]}>
<Text>Set Camera</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.animateCamera()}
style={[styles.bubble, styles.button]}>
<Text>Animate Camera</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
button: {
marginTop: 12,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'column',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default CameraControl;
</file>

<file path="example/src/examples/CustomCallout.tsx">
import React from 'react';

import {StyleSheet, View} from 'react-native';

class CustomCallout extends React.Component<any, any> {
render() {
return (
<View style={[styles.container, this.props.style]}>
<View style={styles.bubble}>
<View style={styles.amount}>{this.props.children}</View>
</View>
<View style={styles.arrowBorder} />
<View style={styles.arrow} />
</View>
);
}
}

const styles = StyleSheet.create({
container: {
flexDirection: 'column',
alignSelf: 'flex-start',
},
bubble: {
width: 140,
flexDirection: 'row',
alignSelf: 'flex-start',
backgroundColor: '#4da2ab',
paddingHorizontal: 20,
paddingVertical: 12,
borderRadius: 6,
borderColor: '#007a87',
borderWidth: 0.5,
},
amount: {
flex: 1,
},
arrow: {
backgroundColor: 'transparent',
borderWidth: 16,
borderColor: 'transparent',
borderTopColor: '#4da2ab',
alignSelf: 'center',
marginTop: -32,
},
arrowBorder: {
backgroundColor: 'transparent',
borderWidth: 16,
borderColor: 'transparent',
borderTopColor: '#007a87',
alignSelf: 'center',
marginTop: -0.5,
},
});

export default CustomCallout;
</file>

<file path="example/src/examples/CustomMarkers.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';

import MapView, {Marker} from 'react-native-maps';
import flagPinkImg from './assets/flag-pink.png';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
let id = 0;

class CustomMarkers extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      markers: [],
    };

    this.onMapPress = this.onMapPress.bind(this);

}

onMapPress(e: any) {
this.setState({
markers: [
...this.state.markers,
{
coordinate: e.nativeEvent.coordinate,
key: `foo${id++}`,
},
],
});
}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}
          onPress={this.onMapPress}>
{this.state.markers.map((marker: any) => (
<Marker
              title={marker.key}
              image={flagPinkImg}
              key={marker.key}
              coordinate={marker.coordinate}
            />
))}
</MapView>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.setState({markers: []})}
style={styles.bubble}>
<Text>Tap map to create a marker of random color</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default CustomMarkers;
</file>

<file path="example/src/examples/CustomOverlay.tsx">
import React from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';

import MapView from 'react-native-maps';
import XMarksTheSpot from './CustomOverlayXMarksTheSpot';

const {width, height} = Dimensions.get('window');
const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class CustomOverlay extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      coordinates: [
        {
          longitude: -122.442753,
          latitude: 37.79879,
        },
        {
          longitude: -122.424728,
          latitude: 37.801232,
        },
        {
          longitude: -122.422497,
          latitude: 37.790651,
        },
        {
          longitude: -122.440693,
          latitude: 37.788209,
        },
      ],
      center: {
        longitude: -122.4326648935676,
        latitude: 37.79418561114521,
      },
    };

}

render() {
const {coordinates, center, region} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={region}>
<XMarksTheSpot coordinates={coordinates} center={center} />
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
});

export default CustomOverlay;
</file>

<file path="example/src/examples/CustomOverlayXMarksTheSpot.tsx">
import React from 'react';
import {View} from 'react-native';
import {Polygon, Polyline, Marker} from 'react-native-maps';

class XMarksTheSpot extends React.Component<any, any> {
render() {
return (
<View>
<Polygon
          coordinates={this.props.coordinates}
          strokeColor="rgba(0, 0, 0, 1)"
          strokeWidth={3}
        />
<Polyline
coordinates={[this.props.coordinates[0], this.props.coordinates[2]]}
/>
<Polyline
coordinates={[this.props.coordinates[1], this.props.coordinates[3]]}
/>
<Marker coordinate={this.props.center} />
</View>
);
}
}

export default XMarksTheSpot;
</file>

<file path="example/src/examples/CustomTiles.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';
import MapView, {MAP_TYPES, PROVIDER_DEFAULT, UrlTile} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class CustomTiles extends React.Component<any, any> {
constructor(props: any, context: any) {
super(props, context);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

}

get mapType() {
// MapKit does not support 'none' as a base map
return this.props.provider === PROVIDER_DEFAULT
? MAP_TYPES.STANDARD
: MAP_TYPES.NONE;
}

render() {
const {region} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          mapType={this.mapType}
          style={styles.map}
          initialRegion={region}>
<UrlTile
            urlTemplate="http://c.tile.stamen.com/watercolor/{z}/{x}/{y}.jpg"
            zIndex={-1}
          />
</MapView>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text>Custom Tiles</Text>
</View>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default CustomTiles;
</file>

<file path="example/src/examples/CustomTilesLocal.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';
import MapView, {
  MAP_TYPES,
  PROVIDER_DEFAULT,
  LocalTile,
} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class CustomTiles extends React.Component<any, any> {
constructor(props: any, context: any) {
super(props, context);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

}

get mapType() {
// MapKit does not support 'none' as a base map
return this.props.provider === PROVIDER_DEFAULT
? MAP_TYPES.STANDARD
: MAP_TYPES.NONE;
}

render() {
const {region} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          mapType={this.mapType}
          style={styles.map}
          initialRegion={region}>
<LocalTile
            pathTemplate="/path/to/locally/saved/tiles/{z}/{x}/{y}.png"
            tileSize={256}
            zIndex={-1}
          />
</MapView>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text>Custom Tiles Local</Text>
</View>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default CustomTiles;
</file>

<file path="example/src/examples/DefaultMarkers.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';
import MapView, {Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
let id = 0;

function randomColor() {
return `#${Math.floor(Math.random() * 16777215)
    .toString(16)
    .padStart(6)}`;
}

class DefaultMarkers extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      markers: [],
    };

}

onMapPress(e: any) {
this.setState({
markers: [
...this.state.markers,
{
coordinate: e.nativeEvent.coordinate,
key: id++,
color: randomColor(),
},
],
});
}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={this.state.region}
poiClickEnabled={false}
onPress={e => this.onMapPress(e)}>
{this.state.markers.map((marker: any) => (
<Marker
              key={marker.key}
              coordinate={marker.coordinate}
              pinColor={marker.color}
            />
))}
</MapView>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.setState({markers: []})}
style={styles.bubble}>
<Text>Tap map to create a marker of random color</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default DefaultMarkers;
</file>

<file path="example/src/examples/DisplayLatLng.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';

import MapView, {MAP_TYPES} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class DisplayLatLng extends React.Component<any, any> {
map: any;
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

}

onRegionChange(region: any) {
this.setState({region});
}

jumpRandom() {
this.setState({region: this.randomRegion()});
}

animateRandom() {
this.map.animateToRegion(this.randomRegion());
}

animateRandomCoordinate() {
this.map.animateCamera({center: this.randomCoordinate()});
}

animateToRandomBearing() {
this.map.animateCamera({heading: this.getRandomFloat(-360, 360)});
}

animateToRandomViewingAngle() {
this.map.animateCamera({pitch: this.getRandomFloat(0, 90)});
}

getRandomFloat(min: any, max: any) {
return Math.random() \* (max - min) + min;
}

randomCoordinate() {
const region = this.state.region;
return {
latitude:
region.latitude + (Math.random() - 0.5) _ (region.latitudeDelta / 2),
longitude:
region.longitude + (Math.random() - 0.5) _ (region.longitudeDelta / 2),
};
}

randomRegion() {
return {
...this.state.region,
...this.randomCoordinate(),
};
}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
ref={ref => {
this.map = ref;
}}
mapType={MAP_TYPES.TERRAIN}
style={styles.map}
initialRegion={this.state.region}
onRegionChange={region => this.onRegionChange(region)}
/>
<View style={[styles.bubble, styles.latlng]}>
<Text style={styles.centeredText}>
{this.state.region.latitude.toPrecision(7)},
{this.state.region.longitude.toPrecision(7)}
</Text>
</View>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.jumpRandom()}
style={[styles.bubble, styles.button]}>
<Text style={styles.buttonText}>Jump</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.animateRandom()}
style={[styles.bubble, styles.button]}>
<Text style={styles.buttonText}>Animate (Region)</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.animateRandomCoordinate()}
style={[styles.bubble, styles.button]}>
<Text style={styles.buttonText}>Animate (Coordinate)</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.animateToRandomBearing()}
style={[styles.bubble, styles.button]}>
<Text style={styles.buttonText}>Animate (Bearing)</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.animateToRandomViewingAngle()}
style={[styles.bubble, styles.button]}>
<Text style={styles.buttonText}>Animate (View Angle)</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 100,
paddingHorizontal: 8,
alignItems: 'center',
justifyContent: 'center',
marginHorizontal: 5,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
buttonText: {
textAlign: 'center',
},
centeredText: {textAlign: 'center'},
});

export default DisplayLatLng;
</file>

<file path="example/src/examples/DraggableMarkers.tsx">
import React from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';

import MapView, {Marker} from 'react-native-maps';
import PriceMarker from './PriceMarker';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

function log(eventName: any, e: any) {
console.log(eventName, e.nativeEvent);
}

class MarkerTypes extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      a: {
        latitude: LATITUDE + SPACE,
        longitude: LONGITUDE + SPACE,
      },
      b: {
        latitude: LATITUDE - SPACE,
        longitude: LONGITUDE - SPACE,
      },
    };

}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}>
<Marker
coordinate={this.state.a}
onSelect={e => log('onSelect', e)}
onDrag={e => log('onDrag', e)}
onDragStart={e => log('onDragStart', e)}
onDragEnd={e => log('onDragEnd', e)}
onPress={e => log('onPress', e)}
draggable>
<PriceMarker amount={99} />
</Marker>
<Marker
coordinate={this.state.b}
onSelect={e => log('onSelect', e)}
onDrag={e => log('onDrag', e)}
onDragStart={e => log('onDragStart', e)}
onDragEnd={e => log('onDragEnd', e)}
onPress={e => log('onPress', e)}
draggable
/>
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
});

export default MarkerTypes;
</file>

<file path="example/src/examples/EventListener.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions, ScrollView} from 'react-native';
import MapView, {Marker, Polygon, Polyline, Callout} from 'react-native-maps';
import PriceMarker from './PriceMarker';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
let id = 0;

class Event extends React.Component<any, any> {
shouldComponentUpdate(nextProps: any) {
return this.props.event.id !== nextProps.event.id;
}

render() {
const {event} = this.props;
return (
<View style={styles.event}>
<Text style={styles.eventName}>{event.name}</Text>
<Text style={styles.eventData}>
{JSON.stringify(event.data, null, 2)}
</Text>
</View>
);
}
}

class EventListener extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      events: [],
    };

}

makeEvent(e: any, name: any) {
return {
id: id++,
name,
data: e.nativeEvent ? e.nativeEvent : e,
};
}

recordEvent(name: any) {
return (e: any) => {
if (e.persist) {
e.persist(); // Avoids warnings relating to https://fb.me/react-event-pooling
}
this.setState((prevState: any) => ({
events: [this.makeEvent(e, name), ...prevState.events.slice(0, 10)],
}));
};
}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={this.state.region}
showsUserLocation
showsMyLocationButton
onRegionChangeStart={this.recordEvent('Map::onRegionChangeStart')}
onRegionChange={this.recordEvent('Map::onRegionChange')}
onRegionChangeComplete={this.recordEvent(
'Map::onRegionChangeComplete',
)}
onPress={this.recordEvent('Map::onPress')}
onPanDrag={this.recordEvent('Map::onPanDrag')}
onLongPress={this.recordEvent('Map::onLongPress')}
onMarkerPress={this.recordEvent('Map::onMarkerPress')}
onMarkerSelect={this.recordEvent('Map::onMarkerSelect')}
onMarkerDeselect={this.recordEvent('Map::onMarkerDeselect')}
onCalloutPress={this.recordEvent('Map::onCalloutPress')}
onUserLocationChange={this.recordEvent('Map::onUserLocationChange')}>
<Marker
coordinate={{
              latitude: LATITUDE + LATITUDE_DELTA / 2,
              longitude: LONGITUDE + LONGITUDE_DELTA / 2,
            }}
/>
<Marker
coordinate={{
              latitude: LATITUDE - LATITUDE_DELTA / 2,
              longitude: LONGITUDE - LONGITUDE_DELTA / 2,
            }}
/>
<Marker
title="This is a title"
description="This is a description"
coordinate={this.state.region}
onPress={this.recordEvent('Marker::onPress')}
onSelect={this.recordEvent('Marker::onSelect')}
onDeselect={this.recordEvent('Marker::onDeselect')}
onCalloutPress={this.recordEvent('Marker::onCalloutPress')}>
<PriceMarker amount={99} />
<Callout
style={styles.callout}
onPress={this.recordEvent('Callout::onPress')}>
<View>
<Text>Well hello there...</Text>
</View>
</Callout>
</Marker>
<Polygon
fillColor={'rgba(255,0,0,0.3)'}
onPress={this.recordEvent('Polygon::onPress')}
tappable
coordinates={[
{
latitude: LATITUDE + LATITUDE_DELTA / 5,
longitude: LONGITUDE + LONGITUDE_DELTA / 4,
},
{
latitude: LATITUDE + LATITUDE_DELTA / 3,
longitude: LONGITUDE + LONGITUDE_DELTA / 4,
},
{
latitude: LATITUDE + LATITUDE_DELTA / 4,
longitude: LONGITUDE + LONGITUDE_DELTA / 2,
},
]}
/>
<Polyline
strokeColor={'rgba(255,0,0,1)'}
onPress={this.recordEvent('Polyline::onPress')}
tappable
coordinates={[
{
latitude: LATITUDE + LATITUDE_DELTA / 5,
longitude: LONGITUDE - LONGITUDE_DELTA / 4,
},
{
latitude: LATITUDE + LATITUDE_DELTA / 3,
longitude: LONGITUDE - LONGITUDE_DELTA / 4,
},
{
latitude: LATITUDE + LATITUDE_DELTA / 4,
longitude: LONGITUDE - LONGITUDE_DELTA / 2,
},
]}
/>
</MapView>
<View style={styles.eventList}>
<ScrollView>
{this.state.events.map((event: any) => (
<Event key={event.id} event={event} />
))}
</ScrollView>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
callout: {
width: 60,
},
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
event: {
borderBottomWidth: 1,
borderBottomColor: '#ccc',
padding: 8,
},
eventData: {
fontSize: 10,
fontFamily: 'courier',
color: '#555',
},
eventName: {
fontSize: 13,
fontWeight: 'bold',
color: '#222',
},
eventList: {
position: 'absolute',
top: height / 2,
left: 0,
right: 0,
bottom: 0,
},
map: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: height / 2,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default EventListener;
</file>

<file path="example/src/examples/FitToCoordinates.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Dimensions,
  TouchableOpacity,
  Text,
} from 'react-native';

import MapView, {Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

function createMarker(modifier = 1) {
return {
latitude: LATITUDE - SPACE _ modifier,
longitude: LONGITUDE - SPACE _ modifier,
};
}

const MARKERS = [
createMarker(),
createMarker(2),
createMarker(3),
createMarker(4),
];

const DEFAULT_PADDING = {top: 40, right: 40, bottom: 40, left: 40};

class FitToCoordinates extends React.Component {
map: any;
async logFrames() {
const visMarkersFrames = await this.map.getMarkersFrames(true);
console.log('Visible markers frames:', visMarkersFrames);
const allMarkersFrames = await this.map.getMarkersFrames();
console.log('All markers frames:', allMarkersFrames);
}

fitPadding() {
this.map.fitToCoordinates([MARKERS[2], MARKERS[3]], {
edgePadding: {top: 100, right: 100, bottom: 100, left: 100},
animated: true,
});
}

fitBottomTwoMarkers() {
this.map.fitToCoordinates([MARKERS[2], MARKERS[3]], {
edgePadding: DEFAULT_PADDING,
animated: true,
});
}

fitAllMarkers() {
this.map.fitToCoordinates(MARKERS, {
edgePadding: DEFAULT_PADDING,
animated: true,
});
}

render() {
return (
<View style={styles.container}>
<MapView
ref={ref => {
this.map = ref;
}}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}>
{MARKERS.map((marker, i) => (
<Marker key={i} identifier={`id${i}`} coordinate={marker} />
))}
</MapView>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.fitPadding()}
style={[styles.bubble, styles.button]}>
<Text>Fit Bottom Two Markers with Padding</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.fitBottomTwoMarkers()}
style={[styles.bubble, styles.button]}>
<Text>Fit Bottom Two Markers</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.fitAllMarkers()}
style={[styles.bubble, styles.button]}>
<Text>Fit All Markers</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.logFrames()}
style={[styles.bubble, styles.button]}>
<Text>Log markers frames</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
button: {
marginTop: 12,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'column',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default FitToCoordinates;
</file>

<file path="example/src/examples/FitToSuppliedMarkers.tsx">
import React from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';
import MapView, {Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

const markerIDs = ['Marker1', 'Marker2', 'Marker3', 'Marker4', 'Marker5'];
const timeout = 4000;
let animationTimeout: any;

class FocusOnMarkers extends React.Component<any, any> {
map: any;
constructor(props: any) {
super(props);

    this.state = {
      a: {
        latitude: LATITUDE + SPACE,
        longitude: LONGITUDE + SPACE,
      },
      b: {
        latitude: LATITUDE - SPACE,
        longitude: LONGITUDE - SPACE,
      },
      c: {
        latitude: LATITUDE - SPACE * 2,
        longitude: LONGITUDE - SPACE * 2,
      },
      d: {
        latitude: LATITUDE - SPACE * 3,
        longitude: LONGITUDE - SPACE * 3,
      },
      e: {
        latitude: LATITUDE - SPACE * 4,
        longitude: LONGITUDE - SPACE * 4,
      },
    };

}

componentDidMount() {
animationTimeout = setTimeout(() => {
this.focus1();
}, timeout);
}

componentWillUnmount() {
if (animationTimeout) {
clearTimeout(animationTimeout);
}
}

focusMap(markers: any, animated: any) {
console.log(`Markers received to populate map: ${markers}`);
this.map.fitToSuppliedMarkers(markers, animated);
}

focus1() {
animationTimeout = setTimeout(() => {
this.focusMap([markerIDs[1], markerIDs[4]], true);

      this.focus2();
    }, timeout);

}

focus2() {
animationTimeout = setTimeout(() => {
this.focusMap([markerIDs[2], markerIDs[3]], false);

      this.focus3();
    }, timeout);

}

focus3() {
animationTimeout = setTimeout(() => {
this.focusMap([markerIDs[1], markerIDs[2]], false);

      this.focus4();
    }, timeout);

}

focus4() {
animationTimeout = setTimeout(() => {
this.focusMap([markerIDs[0], markerIDs[3]], true);

      this.focus1();
    }, timeout);

}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
ref={ref => {
this.map = ref;
}}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}>
<Marker identifier="Marker1" coordinate={this.state.a} />
<Marker identifier="Marker2" coordinate={this.state.b} />
<Marker identifier="Marker3" coordinate={this.state.c} />
<Marker identifier="Marker4" coordinate={this.state.d} />
<Marker identifier="Marker5" coordinate={this.state.e} />
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
});

export default FocusOnMarkers;
</file>

<file path="example/src/examples/Geojson.tsx">
import React from 'react';
import MapView, {Geojson} from 'react-native-maps';
import {StyleSheet} from 'react-native';
const myPlace: any = {
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Point',
        coordinates: [64.165329, 48.844287],
      },
    },
  ],
};

const GeojsonMap = () => (
<MapView style={{...StyleSheet.absoluteFillObject}}>
<Geojson geojson={myPlace} />
</MapView>
);

export default GeojsonMap;
</file>

<file path="example/src/examples/GradientPolylines.tsx">
import React from 'react';
import {StyleSheet, Dimensions} from 'react-native';

import MapView, {Polyline} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

const COORDINATES = [
{latitude: 37.8025259, longitude: -122.4351431},
{latitude: 37.7896386, longitude: -122.421646},
{latitude: 37.7665248, longitude: -122.4161628},
{latitude: 37.7734153, longitude: -122.4577787},
{latitude: 37.7948605, longitude: -122.4596065},
{latitude: 37.8025259, longitude: -122.4351431},
];

const COLORS = [
'#7F0000',
'#00000000', // no color, creates a "long" gradient between the previous and next coordinate
'#B24112',
'#E5845C',
'#238C23',
'#7F0000',
];

class GradientPolylines extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      coordinates: [],
    };
    this.setState({coordinates: COORDINATES});

}

render() {
return (
<MapView
googleRenderer={'LEGACY'}
provider={this.props.provider}
style={styles.container}
initialRegion={this.state.region}>
<Polyline
          coordinates={this.state.coordinates}
          strokeColor="#000"
          strokeColors={COLORS}
          strokeWidth={6}
        />
</MapView>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
},
});

export default GradientPolylines;
</file>

<file path="example/src/examples/GradientPolylinesFunctional.tsx">
import React, {useEffect, useState} from 'react';
import {StyleSheet, Dimensions} from 'react-native';

import MapView, {Polyline, LatLng, Provider} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

const COORDINATES = [
{latitude: 37.8025259, longitude: -122.4351431},
{latitude: 37.7896386, longitude: -122.421646},
{latitude: 37.7665248, longitude: -122.4161628},
{latitude: 37.7734153, longitude: -122.4577787},
{latitude: 37.7948605, longitude: -122.4596065},
{latitude: 37.8025259, longitude: -122.4351431},
];

const COLORS = [
'#7F0000',
'#00000000', // no color, creates a "long" gradient between the previous and next coordinate
'#B24112',
'#E5845C',
'#238C23',
'#7F0000',
];

export type GradientPolylinesFunctionalProps = {
provider: Provider;
};

const GradientPolylines = (props: GradientPolylinesFunctionalProps) => {
const [region] = useState({
latitude: LATITUDE,
longitude: LONGITUDE,
latitudeDelta: LATITUDE_DELTA,
longitudeDelta: LONGITUDE_DELTA,
});

const [polylineSteps, setPolylineSteps] = useState<LatLng[]>([]);

useEffect(() => setPolylineSteps(COORDINATES), []);

return (
<MapView
      provider={props.provider}
      style={styles.container}
      initialRegion={region}
      showsUserLocation>
<Polyline
        coordinates={polylineSteps}
        strokeColor="#000"
        strokeColors={COLORS}
        strokeWidth={6}
      />
</MapView>
);
};

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
},
});

export default GradientPolylines;
</file>

<file path="example/src/examples/ImageOverlayWithAssets.tsx">
import React, {Component} from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';

import MapView, {Overlay} from 'react-native-maps';
import flagPinkImg from './assets/flag-pink.png';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 35.679976;
const LONGITUDE = 139.768458;
const LATITUDE_DELTA = 0.01;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
// 116423, 51613, 17
const OVERLAY_TOP_LEFT_COORDINATE = [35.68184060244454, 139.76531982421875];
const OVERLAY_BOTTOM_RIGHT_COORDINATE = [35.679609609368576, 139.76806640625];
const IMAGE = flagPinkImg;

export default class ImageOverlayWithURL extends Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      overlay: {
        bounds: [OVERLAY_TOP_LEFT_COORDINATE, OVERLAY_BOTTOM_RIGHT_COORDINATE],
        image: IMAGE,
      },
    };

}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}>
<Overlay
            bounds={this.state.overlay.bounds}
            image={this.state.overlay.image}
          />
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});
</file>

<file path="example/src/examples/ImageOverlayWithBearing.tsx">
import React, {Component} from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';

import MapView, {Overlay} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 35.679976;
const LONGITUDE = 139.768458;
const LATITUDE_DELTA = 0.01;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
// 116423, 51613, 17
const OVERLAY_TOP_LEFT_COORDINATE1 = [35.679609609368576, 139.76531982421875];
const OVERLAY_BOTTOM_RIGHT_COORDINATE1 = [35.68184060244454, 139.76806640625];
const IMAGE_URL1 = 'https://maps.gsi.go.jp/xyz/std/17/116423/51613.png';
// 116423, 51615, 17
const OVERLAY_TOP_LEFT_COORDINATE2 = [35.67514743608467, 139.76531982421875];
const OVERLAY_BOTTOM_RIGHT_COORDINATE2 = [35.67737855391474, 139.76806640625];
const IMAGE_URL2 = 'https://maps.gsi.go.jp/xyz/std/17/116423/51615.png';

export default class ImageOverlayWithBearing extends Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      overlay1: {
        bounds: [
          OVERLAY_TOP_LEFT_COORDINATE1,
          OVERLAY_BOTTOM_RIGHT_COORDINATE1,
        ],
        image: IMAGE_URL1,
      },
      overlay2: {
        bounds: [
          OVERLAY_TOP_LEFT_COORDINATE2,
          OVERLAY_BOTTOM_RIGHT_COORDINATE2,
        ],
        image: IMAGE_URL2,
      },
    };

}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}>
<Overlay
            bounds={this.state.overlay1.bounds}
            bearing={30}
            image={this.state.overlay1.image}
          />
<Overlay
            bounds={this.state.overlay2.bounds}
            bearing={-30}
            image={this.state.overlay2.image}
          />
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});
</file>

<file path="example/src/examples/ImageOverlayWithURL.tsx">
import React, {Component} from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';

import MapView, {Overlay} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 35.679976;
const LONGITUDE = 139.768458;
const LATITUDE_DELTA = 0.01;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
// 116423, 51613, 17
const OVERLAY_TOP_LEFT_COORDINATE1 = [35.68184060244454, 139.76531982421875];
const OVERLAY_BOTTOM_RIGHT_COORDINATE1 = [35.679609609368576, 139.76806640625];
const IMAGE_URL1 = 'https://maps.gsi.go.jp/xyz/std/17/116423/51613.png';
// 116423, 51615, 17
const OVERLAY_TOP_LEFT_COORDINATE2 = [35.67737855391474, 139.76531982421875];
const OVERLAY_BOTTOM_RIGHT_COORDINATE2 = [35.67514743608467, 139.76806640625];
const IMAGE_URL2 = 'https://maps.gsi.go.jp/xyz/std/17/116423/51615.png';

export default class ImageOverlayWithURL extends Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      overlay1: {
        bounds: [
          OVERLAY_TOP_LEFT_COORDINATE1,
          OVERLAY_BOTTOM_RIGHT_COORDINATE1,
        ],
        image: IMAGE_URL1,
      },
      overlay2: {
        bounds: [
          OVERLAY_TOP_LEFT_COORDINATE2,
          OVERLAY_BOTTOM_RIGHT_COORDINATE2,
        ],
        image: IMAGE_URL2,
      },
    };

}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}>
<Overlay
            bounds={this.state.overlay1.bounds}
            image={this.state.overlay1.image}
          />
<Overlay
            bounds={this.state.overlay2.bounds}
            image={this.state.overlay2.image}
          />
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});
</file>

<file path="example/src/examples/IndoorMap.tsx">
import React from 'react';
import {StyleSheet, View, Dimensions, Button, Alert} from 'react-native';
import MapView from 'react-native-maps';

const {width, height} = Dimensions.get('window');
const ASPECT_RATIO = width / height;
const LATITUDE = 1.3039991;
const LONGITUDE = 103.8316911;
const LATITUDE_DELTA = 0.003;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

export default class IndoorMap extends React.Component<any, any> {
map: any;
constructor(props: any) {
super(props);
this.setIndoorLevel = this.setIndoorLevel.bind(this);
}

handleIndoorFocus(event: any) {
const {indoorBuilding} = event.nativeEvent;
const {defaultLevelIndex, levels} = indoorBuilding;
const levelNames = levels.map((lv: any) => lv.name || '');
const msg = `Default Level: ${defaultLevelIndex}\nLevels: ${levelNames.toString()}`;
Alert.alert('Indoor building focused', msg);
}

setIndoorLevel(level: any) {
this.map.setIndoorActiveLevelIndex(level);
}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}
showsIndoors
showsIndoorLevelPicker
onIndoorBuildingFocused={this.handleIndoorFocus}
ref={map => {
this.map = map;
}}
/>
<Button
title="go to level 5"
onPress={() => {
this.setIndoorLevel(5);
}}
/>
<Button
title="go to level 1"
onPress={() => {
this.setIndoorLevel(1);
}}
/>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
});
</file>

<file path="example/src/examples/LegalLabel.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Animated,
  Dimensions,
  TouchableOpacity,
} from 'react-native';

import MapView, {Marker} from 'react-native-maps';

const screen = Dimensions.get('window');

class LegalLabel extends React.Component<any, any> {
state = {
\_legalLabelPositionY: new Animated.Value(10),
legalLabelPositionY: 10,
};

componentDidMount() {
this.state.\_legalLabelPositionY.addListener(({value}) => {
this.setState({
legalLabelPositionY: value,
});
});
}

componentWillUnmount() {
this.state.\_legalLabelPositionY.removeAllListeners();
}

onPressAnimate = () => {
Animated.sequence([
Animated.spring(this.state._legalLabelPositionY, {
toValue: 100,
useNativeDriver: true,
}),
Animated.spring(this.state._legalLabelPositionY, {
toValue: 10,
useNativeDriver: true,
}),
]).start();
};

render() {
const latlng = {
latitude: 37.78825,
longitude: -122.4324,
};

    const ASPECT_RATIO = screen.width / screen.height;
    const LATITUDE_DELTA = 0.0922;
    const LONGITUDE_DELTA = LATITUDE_DELTA * ASPECT_RATIO;

    return (
      <View style={{...StyleSheet.absoluteFillObject}}>
        <MapView
          provider={this.props.provider}
          style={styles.map}
          legalLabelInsets={{
            top: 0,
            left: 0,
            bottom: this.state.legalLabelPositionY,
            right: 10,
          }}
          initialRegion={{
            ...latlng,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}>
          <Marker coordinate={latlng} />
        </MapView>

        <View style={styles.username}>
          <TouchableOpacity onPress={this.onPressAnimate}>
            <Text style={styles.usernameText}>Animate</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.bio}>
          <Text style={styles.bioText}>
            Bio description lorem ipsum Ullamco exercitation aliqua ullamco
            nostrud dolor et aliquip fugiat do aute fugiat velit in aliqua sit.
          </Text>
        </View>

        <View style={styles.photo}>
          <View style={styles.photoInner}>
            <Text style={styles.photoText}>Profile Photo</Text>
          </View>
        </View>
      </View>
    );

}
}

const padding = 10;
const photoSize = 80;
const mapHeight = screen.height - 130;
const styles = StyleSheet.create({
bio: {
marginHorizontal: padding,
marginBottom: 0,
paddingVertical: padding / 2,
},
bioText: {
fontSize: 16,
lineHeight: 16 \* 1.5,
},
username: {
paddingLeft: photoSize + padding + padding,
paddingTop: padding,
},
usernameText: {
fontSize: 36,
lineHeight: 36,
color: 'blue',
textDecorationLine: 'underline',
},
photo: {
padding: 2,
position: 'absolute',
top: mapHeight - photoSize / 2,
left: padding,
borderRadius: 5,
borderWidth: StyleSheet.hairlineWidth,
backgroundColor: '#ccc',
width: photoSize,
height: photoSize,
},
photoInner: {
alignItems: 'center',
justifyContent: 'center',
flex: 1,
},
photoText: {
fontSize: 9,
textAlign: 'center',
},
map: {
height: mapHeight,
},
});

export default LegalLabel;
</file>

<file path="example/src/examples/LiteMapView.tsx">
import React from 'react';
import {StyleSheet, Dimensions, ScrollView} from 'react-native';

import MapView from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

const SAMPLE_REGION = {
latitude: LATITUDE,
longitude: LONGITUDE,
latitudeDelta: LATITUDE_DELTA,
longitudeDelta: LONGITUDE_DELTA,
};

class LiteMapView extends React.Component {
render() {
const maps = [];
for (let i = 0; i < 10; i++) {
maps.push(
<MapView
liteMode
key={`map_${i}`}
style={styles.map}
initialRegion={SAMPLE_REGION}
/>,
);
}
return (
<ScrollView style={StyleSheet.absoluteFillObject}>{maps}</ScrollView>
);
}
}

const styles = StyleSheet.create({
map: {
height: 200,
marginVertical: 50,
},
});

export default LiteMapView;
</file>

<file path="example/src/examples/LoadingMap.tsx">
import React from 'react';
import {Text, View, Dimensions, StyleSheet} from 'react-native';

import MapView, {Marker, Callout} from 'react-native-maps';
import flagImg from './assets/flag-blue.png';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

class LoadingMap extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}
          loadingEnabled
          loadingIndicatorColor="#666666"
          loadingBackgroundColor="#eeeeee">
<Marker
coordinate={{
              latitude: LATITUDE + SPACE,
              longitude: LONGITUDE + SPACE,
            }}
centerOffset={{x: -18, y: -60}}
anchor={{x: 0.69, y: 1}}
image={flagImg}
/>
<Marker
coordinate={{
              latitude: LATITUDE - SPACE,
              longitude: LONGITUDE - SPACE,
            }}
centerOffset={{x: -42, y: -60}}
anchor={{x: 0.84, y: 1}}>
<Callout>
<View>
<Text>This is a plain view</Text>
</View>
</Callout>
</Marker>
</MapView>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text>Map with Loading</Text>
</View>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default LoadingMap;
</file>

<file path="example/src/examples/MapBoundaries.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';

import MapView from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class MapBoundaries extends React.Component<any, any> {
map: any;
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      mapBoundaries: null,
    };

}

async onRegionChangeComplete() {
this.setState({
mapBoundaries: await this.map.getMapBoundaries(),
});
}

render() {
return (
<View style={styles.container}>
<MapView
ref={ref => {
this.map = ref;
}}
provider={this.props.provider}
style={styles.map}
initialRegion={this.state.region}
onRegionChangeComplete={() => this.onRegionChangeComplete()}
/>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text>{JSON.stringify(this.state.mapBoundaries)}</Text>
</View>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default MapBoundaries;
</file>

<file path="example/src/examples/MapKml.tsx">
import React from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';
import MapView, {Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = -18.9193508;
const LONGITUDE = -48.2830592;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const KML_FILE = 'https://pastebin.com/raw/jAzGpq1F';

export default class MapKml extends React.Component<any, any> {
map: any;
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

    this.onKmlReady = this.onKmlReady.bind(this);

}

onKmlReady() {
this.map.fitToElements({animated: true});
}

render() {
return (
<View style={styles.container}>
<MapView
ref={ref => {
this.map = ref;
}}
provider={this.props.provider}
style={styles.map}
initialRegion={this.state.region}
kmlSrc={KML_FILE}
onKmlReady={this.onKmlReady}>
<Marker
            coordinate={this.state.region}
            title="Test"
            description="Test"
          />
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
justifyContent: 'flex-end',
alignItems: 'center',
},
scrollview: {
alignItems: 'center',
paddingVertical: 40,
},
map: {
width,
height,
},
});
</file>

<file path="example/src/examples/MapStyle.tsx">
import React from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';

import MapView from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

const customStyle = [
{
elementType: 'geometry',
stylers: [
{
color: '#242f3e',
},
],
},
{
elementType: 'labels.text.fill',
stylers: [
{
color: '#746855',
},
],
},
{
elementType: 'labels.text.stroke',
stylers: [
{
color: '#242f3e',
},
],
},
{
featureType: 'administrative.locality',
elementType: 'labels.text.fill',
stylers: [
{
color: '#d59563',
},
],
},
{
featureType: 'poi',
elementType: 'labels.text.fill',
stylers: [
{
color: '#d59563',
},
],
},
{
featureType: 'poi.park',
elementType: 'geometry',
stylers: [
{
color: '#263c3f',
},
],
},
{
featureType: 'poi.park',
elementType: 'labels.text.fill',
stylers: [
{
color: '#6b9a76',
},
],
},
{
featureType: 'road',
elementType: 'geometry',
stylers: [
{
color: '#38414e',
},
],
},
{
featureType: 'road',
elementType: 'geometry.stroke',
stylers: [
{
color: '#212a37',
},
],
},
{
featureType: 'road',
elementType: 'labels.text.fill',
stylers: [
{
color: '#9ca5b3',
},
],
},
{
featureType: 'road.highway',
elementType: 'geometry',
stylers: [
{
color: '#746855',
},
],
},
{
featureType: 'road.highway',
elementType: 'geometry.stroke',
stylers: [
{
color: '#1f2835',
},
],
},
{
featureType: 'road.highway',
elementType: 'labels.text.fill',
stylers: [
{
color: '#f3d19c',
},
],
},
{
featureType: 'transit',
elementType: 'geometry',
stylers: [
{
color: '#2f3948',
},
],
},
{
featureType: 'transit.station',
elementType: 'labels.text.fill',
stylers: [
{
color: '#d59563',
},
],
},
{
featureType: 'water',
elementType: 'geometry',
stylers: [
{
color: '#17263c',
},
],
},
{
featureType: 'water',
elementType: 'labels.text.fill',
stylers: [
{
color: '#515c6d',
},
],
},
{
featureType: 'water',
elementType: 'labels.text.stroke',
stylers: [
{
color: '#17263c',
},
],
},
];

class MapStyle extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {};

}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}
customMapStyle={customStyle}
/>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
});

export default MapStyle;
</file>

<file path="example/src/examples/MarkerTypes.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';
import MapView, {Marker} from 'react-native-maps';
import flagBlueImg from './assets/flag-blue.png';
import flagPinkImg from './assets/flag-pink.png';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

class MarkerTypes extends React.Component<any, any> {
constructor(props: any) {
super(props);
this.state = {
marker1: true,
marker2: false,
};
}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}>
<Marker
onPress={() => this.setState({marker1: !this.state.marker1})}
coordinate={{
              latitude: LATITUDE + SPACE,
              longitude: LONGITUDE + SPACE,
            }}
centerOffset={{x: -18, y: -60}}
anchor={{x: 0.69, y: 1}}
image={this.state.marker1 ? flagBlueImg : flagPinkImg}>
<Text style={styles.marker}>X</Text>
</Marker>
<Marker
onPress={() => this.setState({marker2: !this.state.marker2})}
coordinate={{
              latitude: LATITUDE - SPACE,
              longitude: LONGITUDE - SPACE,
            }}
centerOffset={{x: -42, y: -60}}
anchor={{x: 0.84, y: 1}}
image={this.state.marker2 ? flagBlueImg : flagPinkImg}
/>
<Marker
onPress={() => this.setState({marker2: !this.state.marker2})}
coordinate={{
              latitude: LATITUDE + SPACE,
              longitude: LONGITUDE - SPACE,
            }}
centerOffset={{x: -42, y: -60}}
anchor={{x: 0.84, y: 1}}
opacity={0.6}
image={this.state.marker2 ? flagBlueImg : flagPinkImg}
/>
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
marker: {
marginLeft: 46,
marginTop: 33,
fontWeight: 'bold',
},
});

export default MarkerTypes;
</file>

<file path="example/src/examples/MassiveCustomMarkers.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';

import MapView, {Marker} from 'react-native-maps';
import flagPinkImg from './assets/flag-pink.png';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
let id = 0;

class MassiveCustomMarkers extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      markers: [],
    };

    this.onMapPress = this.onMapPress.bind(this);

}

generateMarkers(fromCoordinate: any) {
const result = [];
const {latitude, longitude} = fromCoordinate;
for (let i = 0; i < 100; i++) {
const newMarker = {
coordinate: {
latitude: latitude + 0.001 _ i,
longitude: longitude + 0.001 _ i,
},
key: `foo${id++}`,
};
result.push(newMarker);
}
return result;
}

onMapPress(e: any) {
this.setState({
markers: [
...this.state.markers,
...this.generateMarkers(e.nativeEvent.coordinate),
],
});
}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}
          onPress={this.onMapPress}>
{this.state.markers.map((marker: any) => (
<Marker
              title={marker.key}
              image={flagPinkImg}
              key={marker.key}
              coordinate={marker.coordinate}
            />
))}
</MapView>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.setState({markers: []})}
style={styles.bubble}>
<Text>Tap map to create 100 markers</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default MassiveCustomMarkers;
</file>

<file path="example/src/examples/MyLocationMapMarker.tsx">
import React from 'react';
import {Text} from 'react-native';

export default function MyLocationMapMarker() {
return <Text>Implement</Text>;
}

// import React from 'react';
// import PropTypes from 'prop-types';

// import {
// StyleSheet,
// Text,
// View,
// PermissionsAndroid,
// Platform,
// } from 'react-native';
// import {Marker} from 'react-native-maps';
// import isEqual from 'lodash/isEqual';

// const GEOLOCATION_OPTIONS = {
// enableHighAccuracy: true,
// timeout: 20000,
// maximumAge: 1000,
// };
// const ANCHOR = {x: 0.5, y: 0.5};

// const colorOfmyLocationMapMarker = 'blue';

// const propTypes = {
// ...Marker.propTypes,
// // override this prop to make it optional
// coordinate: PropTypes.shape({
// latitude: PropTypes.number.isRequired,
// longitude: PropTypes.number.isRequired,
// }),
// children: PropTypes.node,
// geolocationOptions: PropTypes.shape({
// enableHighAccuracy: PropTypes.bool,
// timeout: PropTypes.number,
// maximumAge: PropTypes.number,
// }),
// heading: PropTypes.number,
// enableHack: PropTypes.bool,
// };

// const defaultProps = {
// enableHack: false,
// geolocationOptions: GEOLOCATION_OPTIONS,
// };

// export default class MyLocationMapMarker extends React.PureComponent {
// constructor(props) {
// super(props);
// this.mounted = false;
// this.state = {
// myPosition: null,
// };
// }
// componentDidMount() {
// this.mounted = true;
// // If you supply a coordinate prop, we won't try to track location automatically
// if (this.props.coordinate) {
// return;
// }

// if (Platform.OS === 'android') {
// PermissionsAndroid.requestPermission(
// PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
// ).then(granted => {
// if (granted && this.mounted) {
// this.watchLocation();
// }
// });
// } else {
// this.watchLocation();
// }
// }
// watchLocation() {
// this.watchID = navigator.geolocation.watchPosition(
// position => {
// const myLastPosition = this.state.myPosition;
// const myPosition = position.coords;
// if (!isEqual(myPosition, myLastPosition)) {
// this.setState({myPosition});
// }
// },
// null,
// this.props.geolocationOptions,
// );
// }
// componentWillUnmount() {
// this.mounted = false;
// if (this.watchID) {
// navigator.geolocation.clearWatch(this.watchID);
// }
// }
// render() {
// let {heading, coordinate} = this.props;
// if (!coordinate) {
// const {myPosition} = this.state;
// if (!myPosition) {
// return null;
// }
// coordinate = myPosition;
// heading = myPosition.heading;
// }

// const rotate =
// typeof heading === 'number' && heading >= 0 ? `${heading}deg` : null;

// return (
// <Marker
// anchor={ANCHOR}
// style={styles.mapMarker}
// {...this.props}
// coordinate={coordinate}>
// <View style={styles.container}>
// <View style={styles.markerHalo} />
// {rotate && (
// <View style={[styles.heading, {transform: [{rotate}]}]}>
// <View style={styles.headingPointer} />
// </View>
// )}
// <View style={styles.marker}>
// <Text style={styles.markerText}>
// {this.props.enableHack && rotate}
// </Text>
// </View>
// </View>
// {this.props.children}
// </Marker>
// );
// }
// }

// const SIZE = 35;
// const HALO_RADIUS = 6;
// const ARROW_SIZE = 7;
// const ARROW_DISTANCE = 6;
// const HALO_SIZE = SIZE + HALO_RADIUS;
// const HEADING_BOX_SIZE = HALO_SIZE + ARROW_SIZE + ARROW_DISTANCE;

// const styles = StyleSheet.create({
// mapMarker: {
// zIndex: 1000,
// },
// // The container is necessary to protect the markerHalo shadow from clipping
// container: {
// width: HEADING_BOX_SIZE,
// height: HEADING_BOX_SIZE,
// },
// heading: {
// position: 'absolute',
// top: 0,
// left: 0,
// width: HEADING_BOX_SIZE,
// height: HEADING_BOX_SIZE,
// alignItems: 'center',
// },
// headingPointer: {
// width: 0,
// height: 0,
// backgroundColor: 'transparent',
// borderStyle: 'solid',
// borderTopWidth: 0,
// borderRightWidth: ARROW_SIZE _ 0.75,
// borderBottomWidth: ARROW_SIZE,
// borderLeftWidth: ARROW_SIZE _ 0.75,
// borderTopColor: 'transparent',
// borderRightColor: 'transparent',
// borderBottomColor: colorOfmyLocationMapMarker,
// borderLeftColor: 'transparent',
// },
// markerHalo: {
// position: 'absolute',
// backgroundColor: 'white',
// top: 0,
// left: 0,
// width: HALO_SIZE,
// height: HALO_SIZE,
// borderRadius: Math.ceil(HALO_SIZE / 2),
// margin: (HEADING_BOX_SIZE - HALO_SIZE) / 2,
// shadowColor: 'black',
// shadowOpacity: 0.25,
// shadowRadius: 2,
// shadowOffset: {
// height: 0,
// width: 0,
// },
// },
// marker: {
// justifyContent: 'center',
// backgroundColor: colorOfmyLocationMapMarker,
// width: SIZE,
// height: SIZE,
// borderRadius: Math.ceil(SIZE / 2),
// margin: (HEADING_BOX_SIZE - SIZE) / 2,
// },
// markerText: {width: 0, height: 0},
// });

// MyLocationMapMarker.propTypes = propTypes;
// MyLocationMapMarker.defaultProps = defaultProps;
</file>

<file path="example/src/examples/OnPoiClick.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';

import MapView, {Callout, Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class OnPoiClick extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      poi: null,
    };

    this.onPoiClick = this.onPoiClick.bind(this);

}

onPoiClick(e: any) {
const poi = e.nativeEvent;

    this.setState({
      poi,
    });

}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}
          onPoiClick={this.onPoiClick}>
{this.state.poi && (
<Marker coordinate={this.state.poi.coordinate}>
<Callout>
<View>
<Text>Place Id: {this.state.poi.placeId}</Text>
<Text>Name: {this.state.poi.name}</Text>
</View>
</Callout>
</Marker>
)}
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
});

export default OnPoiClick;
</file>

<file path="example/src/examples/Overlays.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';

import MapView, {Circle, Polygon, Polyline} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

class Overlays extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      circle: {
        center: {
          latitude: LATITUDE + SPACE,
          longitude: LONGITUDE + SPACE,
        },
        radius: 700,
      },
      polygon: [
        {
          latitude: LATITUDE + SPACE,
          longitude: LONGITUDE + SPACE,
        },
        {
          latitude: LATITUDE - SPACE,
          longitude: LONGITUDE - SPACE,
        },
        {
          latitude: LATITUDE - SPACE,
          longitude: LONGITUDE + SPACE,
        },
      ],
      polyline: [
        {
          latitude: LATITUDE + SPACE,
          longitude: LONGITUDE - SPACE,
        },
        {
          latitude: LATITUDE - 2 * SPACE,
          longitude: LONGITUDE + 2 * SPACE,
        },
        {
          latitude: LATITUDE - SPACE,
          longitude: LONGITUDE - SPACE,
        },
        {
          latitude: LATITUDE - 2 * SPACE,
          longitude: LONGITUDE - SPACE,
        },
      ],
    };

}

render() {
const {region, circle, polygon, polyline} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={region}>
<Circle
            center={circle.center}
            radius={circle.radius}
            fillColor="rgba(255, 255, 255, 1)"
            strokeColor="rgba(0,0,0,0.5)"
            zIndex={2}
            strokeWidth={2}
          />
<Polygon
            coordinates={polygon}
            fillColor="rgba(0, 200, 0, 0.5)"
            strokeColor="rgba(0,0,0,0.5)"
            strokeWidth={2}
          />
<Polyline
coordinates={polyline}
strokeColor="rgba(0,0,200,0.5)"
strokeWidth={3}
lineDashPattern={[5, 2, 3, 2]}
/>
</MapView>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text>Render circles, polygons, and polylines</Text>
</View>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default Overlays;
</file>

<file path="example/src/examples/PanController.tsx">
import React from 'react';

import {View, Animated, PanResponder} from 'react-native';

class PanController extends React.Component<any, any> {
\_responder: any = null;
\_listener: any = null;
\_direction: any = null;
deceleration;

constructor(props: any) {
super(props);

    this.deceleration = 0.997;
    if (
      props.momentumDecayConfig &&
      this.props.momentumDecayConfig.deceleration
    ) {
      this.deceleration = this.props.momentumDecayConfig.deceleration;
    }
    this._responder = PanResponder.create({
      onStartShouldSetPanResponder: this.props.onStartShouldSetPanResponder,
      onMoveShouldSetPanResponder: this.props.onMoveShouldSetPanResponder,
      onPanResponderGrant: (...args) => {
        if (this.props.onPanResponderGrant) {
          this.props.onPanResponderGrant(...args);
        }
        let {panX, panY, horizontal, vertical, xMode, yMode} = this.props;

        this.handleResponderGrant(panX, xMode);
        this.handleResponderGrant(panY, yMode);

        this._direction =
          horizontal && !vertical ? 'x' : vertical && !horizontal ? 'y' : null;
      },

      onPanResponderMove: (_, {dx, dy, x0, y0}) => {
        let {
          panX,
          panY,
          xBounds,
          yBounds,
          overshootX,
          overshootY,
          horizontal,
          vertical,
          lockDirection,
          directionLockDistance,
        } = this.props;

        if (!this._direction) {
          const dx2 = dx * dx;
          const dy2 = dy * dy;
          if (dx2 + dy2 > directionLockDistance) {
            this._direction = dx2 > dy2 ? 'x' : 'y';
            if (this.props.onDirectionChange) {
              this.props.onDirectionChange(this._direction, {dx, dy, x0, y0});
            }
          }
        }

        const dir = this._direction;

        if (this.props.onPanResponderMove) {
          this.props.onPanResponderMove(_, {dx, dy, x0, y0});
        }

        if (horizontal && (!lockDirection || dir === 'x')) {
          let [xMin, xMax] = xBounds;

          this.handleResponderMove(panX, dx, xMin, xMax, overshootX);
        }

        if (vertical && (!lockDirection || dir === 'y')) {
          let [yMin, yMax] = yBounds;

          this.handleResponderMove(panY, dy, yMin, yMax, overshootY);
        }
      },

      onPanResponderRelease: (_, {vx, vy, dx, dy}) => {
        let {
          panX,
          panY,
          xBounds,
          yBounds,
          overshootX,
          overshootY,
          horizontal,
          vertical,
          lockDirection,
          xMode,
          yMode,
          snapSpacingX,
          snapSpacingY,
        } = this.props;

        let cancel = false;

        const dir = this._direction;

        if (this.props.onRelease) {
          cancel = this.props.onRelease({vx, vy, dx, dy}) === false;
        }

        if (!cancel && horizontal && (!lockDirection || dir === 'x')) {
          let [xMin, xMax] = xBounds;
          if (this.props.onReleaseX) {
            cancel = this.props.onReleaseX({vx, vy, dx, dy}) === false;
          }
          !cancel &&
            this.handleResponderRelease(
              panX,
              xMin,
              xMax,
              vx,
              overshootX,
              xMode,
              snapSpacingX,
            );
        }

        if (!cancel && vertical && (!lockDirection || dir === 'y')) {
          let [yMin, yMax] = yBounds;
          if (this.props.onReleaseY) {
            cancel = this.props.onReleaseY({vx, vy, dx, dy}) === false;
          }
          !cancel &&
            this.handleResponderRelease(
              panY,
              yMin,
              yMax,
              vy,
              overshootY,
              yMode,
              snapSpacingY,
            );
        }

        this._direction =
          horizontal && !vertical ? 'x' : vertical && !horizontal ? 'y' : null;
      },
    });

}

handleResponderMove(
anim: any,
delta: any,
min: any,
max: any,
overshoot: any,
) {
let val = anim.\_offset + delta;

    if (val > max) {
      switch (overshoot) {
        case 'spring':
          val = max + (val - max) / this.props.overshootReductionFactor;
          break;
        case 'clamp':
          val = max;
          break;
      }
    }
    if (val < min) {
      switch (overshoot) {
        case 'spring':
          val = min - (min - val) / this.props.overshootReductionFactor;
          break;
        case 'clamp':
          val = min;
          break;
      }
    }
    val = val - anim._offset;
    anim.setValue(val);

}

handleResponderRelease(
anim: any,
min: any,
max: any,
velocity: any,
overshoot: any,
mode: any,
snapSpacing: any,
) {
anim.flattenOffset();

    if (anim._value < min) {
      if (this.props.onOvershoot) {
        this.props.onOvershoot(); // TODO: what args should we pass to this
      }
      switch (overshoot) {
        case 'spring':
          Animated.spring(anim, {
            ...this.props.overshootSpringConfig,
            toValue: min,
            velocity,
          }).start();
          break;
        case 'clamp':
          anim.setValue(min);
          break;
      }
    } else if (anim._value > max) {
      if (this.props.onOvershoot) {
        this.props.onOvershoot(); // TODO: what args should we pass to this
      }
      switch (overshoot) {
        case 'spring':
          Animated.spring(anim, {
            ...this.props.overshootSpringConfig,
            toValue: max,
            velocity,
          }).start();
          break;
        case 'clamp':
          anim.setValue(min);
          break;
      }
    } else {
      switch (mode) {
        case 'snap':
          this.handleSnappedScroll(anim, min, max, velocity, snapSpacing);
          break;

        case 'decay':
          this.handleMomentumScroll(anim, min, max, velocity, overshoot);
          break;

        case 'spring-origin':
          Animated.spring(anim, {
            ...this.props.springOriginConfig,
            toValue: 0,
            velocity,
          }).start();
          break;
      }
    }

}

handleResponderGrant(anim: any, mode: any) {
switch (mode) {
case 'spring-origin':
anim.setValue(0);
break;
case 'snap':
case 'decay':
anim.setOffset(anim.\_value + anim.\_offset);
anim.setValue(0);
break;
}
}

handleMomentumScroll(
anim: any,
min: any,
max: any,
velocity: any,
overshoot: any,
) {
Animated.decay(anim, {
...this.props.momentumDecayConfig,
velocity,
}).start(() => {
anim.removeListener(this.\_listener);
});

    this._listener = anim.addListener(({value}: any) => {
      if (value < min) {
        anim.removeListener(this._listener);
        if (this.props.onOvershoot) {
          this.props.onOvershoot(); // TODO: what args should we pass to this
        }
        switch (overshoot) {
          case 'spring':
            Animated.spring(anim, {
              ...this.props.overshootSpringConfig,
              toValue: min,
              velocity,
            }).start();
            break;
          case 'clamp':
            anim.setValue(min);
            break;
        }
      } else if (value > max) {
        anim.removeListener(this._listener);
        if (this.props.onOvershoot) {
          this.props.onOvershoot(); // TODO: what args should we pass to this
        }
        switch (overshoot) {
          case 'spring':
            Animated.spring(anim, {
              ...this.props.overshootSpringConfig,
              toValue: max,
              velocity,
            }).start();
            break;
          case 'clamp':
            anim.setValue(min);
            break;
        }
      }
    });

}

handleSnappedScroll(
anim: any,
min: any,
max: any,
velocity: any,
spacing: any,
) {
let endX = this.momentumCenter(anim.\_value, velocity, spacing);
endX = Math.max(endX, min);
endX = Math.min(endX, max);
const bounds = [endX - spacing / 2, endX + spacing / 2];
const endV = this.velocityAtBounds(anim.\_value, velocity, bounds);

    this._listener = anim.addListener(({value}: any) => {
      if (value > bounds[0] && value < bounds[1]) {
        Animated.spring(anim, {
          toValue: endX,
          velocity: endV,
          useNativeDriver: false,
        }).start();
      }
    });

    Animated.decay(anim, {
      ...this.props.momentumDecayConfig,
      velocity,
    }).start(() => {
      anim.removeListener(this._listener);
    });

}

closestCenter(x: any, spacing: any) {
const plus = x % spacing < spacing / 2 ? 0 : spacing;
return Math.round(x / spacing) \* spacing + plus;
}

momentumCenter(x0: any, vx: any, spacing: any) {
let t = 0;
let x1 = x0;
let x = x1;

    while (true) {
      t += 16;
      x =
        x0 +
        (vx / (1 - this.deceleration)) *
          (1 - Math.exp(-(1 - this.deceleration) * t));
      if (Math.abs(x - x1) < 0.1) {
        x1 = x;
        break;
      }
      x1 = x;
    }
    return this.closestCenter(x1, spacing);

}

velocityAtBounds(x0: any, vx: any, bounds: any) {
let t = 0;
let x1 = x0;
let x = x1;
let vf;
while (true) {
t += 16;
x =
x0 +
(vx / (1 - this.deceleration)) _
(1 - Math.exp(-(1 - this.deceleration) _ t));
vf = (x - x1) / 16;
if (x > bounds[0] && x < bounds[1]) {
break;
}
if (Math.abs(vf) < 0.1) {
break;
}
x1 = x;
}
return vf;
}

render() {
return <View {...this.props} {...this.\_responder.panHandlers} />;
}
}

export default PanController;
</file>

<file path="example/src/examples/PolygonCreator.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';

import MapView, {MAP_TYPES, Polygon} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
let id = 0;

class PolygonCreator extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      polygons: [],
      editing: null,
      creatingHole: false,
    };

}

finish() {
const {polygons, editing} = this.state;
this.setState({
polygons: [...polygons, editing],
editing: null,
creatingHole: false,
});
}

createHole() {
const {editing, creatingHole} = this.state;
if (!creatingHole) {
this.setState({
creatingHole: true,
editing: {
...editing,
holes: [...editing.holes, []],
},
});
} else {
const holes = [...editing.holes];
if (holes[holes.length - 1].length === 0) {
holes.pop();
this.setState({
editing: {
...editing,
holes,
},
});
}
this.setState({creatingHole: false});
}
}

onPress(e: any) {
const {editing, creatingHole} = this.state;
if (!editing) {
this.setState({
editing: {
id: id++,
coordinates: [e.nativeEvent.coordinate],
holes: [],
},
});
} else if (!creatingHole) {
this.setState({
editing: {
...editing,
coordinates: [...editing.coordinates, e.nativeEvent.coordinate],
},
});
} else {
const holes = [...editing.holes];
holes[holes.length - 1] = [
...holes[holes.length - 1],
e.nativeEvent.coordinate,
];
this.setState({
editing: {
...editing,
id: id++, // keep incrementing id to trigger display refresh
coordinates: [...editing.coordinates],
holes,
},
});
}
}

render() {
const mapOptions: any = {
scrollEnabled: true,
};

    if (this.state.editing) {
      mapOptions.scrollEnabled = false;
      mapOptions.onPanDrag = (e: any) => this.onPress(e);
    }

    return (
      <View style={styles.container}>
        <MapView
          provider={this.props.provider}
          style={styles.map}
          mapType={MAP_TYPES.HYBRID}
          initialRegion={this.state.region}
          onPress={e => this.onPress(e)}
          {...mapOptions}>
          {this.state.polygons.map((polygon: any) => (
            <Polygon
              key={polygon.id}
              coordinates={polygon.coordinates}
              holes={polygon.holes}
              strokeColor="#F00"
              fillColor="rgba(255,0,0,0.5)"
              strokeWidth={1}
            />
          ))}
          {this.state.editing && (
            <Polygon
              key={this.state.editing.id}
              coordinates={this.state.editing.coordinates}
              holes={this.state.editing.holes}
              strokeColor="#000"
              fillColor="rgba(255,0,0,0.5)"
              strokeWidth={1}
            />
          )}
        </MapView>
        <View style={styles.buttonContainer}>
          {this.state.editing && (
            <TouchableOpacity
              onPress={() => this.createHole()}
              style={[styles.bubble, styles.button]}>
              <Text>
                {this.state.creatingHole ? 'Finish Hole' : 'Create Hole'}
              </Text>
            </TouchableOpacity>
          )}
          {this.state.editing && (
            <TouchableOpacity
              onPress={() => this.finish()}
              style={[styles.bubble, styles.button]}>
              <Text>Finish</Text>
            </TouchableOpacity>
          )}
        </View>
      </View>
    );

}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default PolygonCreator;
</file>

<file path="example/src/examples/PolylineCreator.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';

import MapView, {Polyline} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
let id = 0;

class PolylineCreator extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      polylines: [],
      editing: null,
    };

}

finish() {
const {polylines, editing} = this.state;
this.setState({
polylines: [...polylines, editing],
editing: null,
});
}

onPanDrag(e: any) {
const {editing} = this.state;
if (!editing) {
this.setState({
editing: {
id: id++,
coordinates: [e.nativeEvent.coordinate],
},
});
} else {
this.setState({
editing: {
...editing,
coordinates: [...editing.coordinates, e.nativeEvent.coordinate],
},
});
}
}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={this.state.region}
scrollEnabled={false}
onPanDrag={e => this.onPanDrag(e)}>
{this.state.polylines.map((polyline: any) => (
<Polyline
              key={polyline.id}
              coordinates={polyline.coordinates}
              strokeColor="#000"
              fillColor="rgba(255,0,0,0.5)"
              strokeWidth={1}
            />
))}
{this.state.editing && (
<Polyline
              key="editingPolyline"
              coordinates={this.state.editing.coordinates}
              strokeColor="#F00"
              fillColor="rgba(255,0,0,0.5)"
              strokeWidth={1}
            />
)}
</MapView>
<View style={styles.buttonContainer}>
{this.state.editing && (
<TouchableOpacity
onPress={() => this.finish()}
style={[styles.bubble, styles.button]}>
<Text>Finish</Text>
</TouchableOpacity>
)}
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default PolylineCreator;
</file>

<file path="example/src/examples/PriceMarker.tsx">
import React from 'react';
import {StyleSheet, View, Text} from 'react-native';

class PriceMarker extends React.Component<any, any> {
render() {
const {fontSize, amount} = this.props;
return (
<View style={styles.container}>
<View style={styles.bubble}>
<Text style={styles.dollar}>$</Text>
<Text style={[styles.amount, {fontSize}]}>{amount}</Text>
</View>
<View style={styles.arrowBorder} />
<View style={styles.arrow} />
</View>
);
}
}

const styles = StyleSheet.create({
container: {
flexDirection: 'column',
alignSelf: 'flex-start',
},
bubble: {
flex: 0,
flexDirection: 'row',
alignSelf: 'flex-start',
backgroundColor: '#FF5A5F',
padding: 2,
borderRadius: 3,
borderColor: '#D23F44',
borderWidth: 0.5,
},
dollar: {
color: '#FFFFFF',
fontSize: 10,
},
amount: {
color: '#FFFFFF',
fontSize: 13,
},
arrow: {
backgroundColor: 'transparent',
borderWidth: 4,
borderColor: 'transparent',
borderTopColor: '#FF5A5F',
alignSelf: 'center',
marginTop: -9,
},
arrowBorder: {
backgroundColor: 'transparent',
borderWidth: 4,
borderColor: 'transparent',
borderTopColor: '#D23F44',
alignSelf: 'center',
marginTop: -0.5,
},
});

export default PriceMarker;
</file>

<file path="example/src/examples/SetNativePropsOverlays.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  Dimensions,
} from 'react-native';

import MapView, {Circle, Polygon, Polyline} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

class SetNativePropsOverlays extends React.Component<any, any> {
circle: any;
polygon: any;
polyline: any;
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      circle: {
        center: {
          latitude: LATITUDE + SPACE,
          longitude: LONGITUDE + SPACE,
        },
        radius: 700,
      },
      polygon: [
        {
          latitude: LATITUDE + SPACE,
          longitude: LONGITUDE + SPACE,
        },
        {
          latitude: LATITUDE - SPACE,
          longitude: LONGITUDE - SPACE,
        },
        {
          latitude: LATITUDE - SPACE,
          longitude: LONGITUDE + SPACE,
        },
      ],
      polyline: [
        {
          latitude: LATITUDE + SPACE,
          longitude: LONGITUDE - SPACE,
        },
        {
          latitude: LATITUDE - 2 * SPACE,
          longitude: LONGITUDE + 2 * SPACE,
        },
        {
          latitude: LATITUDE - SPACE,
          longitude: LONGITUDE - SPACE,
        },
        {
          latitude: LATITUDE - 2 * SPACE,
          longitude: LONGITUDE - SPACE,
        },
      ],
    };

}

handleColorChange(color: any) {
const props = {strokeColor: color};
this.circle.setNativeProps(props);
this.polygon.setNativeProps(props);
this.polyline.setNativeProps(props);
}

render() {
const {region, circle, polygon, polyline} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={region}>
<Circle
ref={ref => {
this.circle = ref;
}}
center={circle.center}
radius={circle.radius}
fillColor="rgba(255, 255, 255, 0.6)"
strokeColor="green"
zIndex={3}
strokeWidth={3}
/>
<Polygon
ref={ref => {
this.polygon = ref;
}}
coordinates={polygon}
fillColor="rgba(255, 255, 255, 0.6)"
strokeColor="green"
strokeWidth={2}
/>
<Polyline
ref={ref => {
this.polyline = ref;
}}
coordinates={polyline}
strokeColor="green"
strokeWidth={3}
/>
</MapView>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => {
this.handleColorChange('green');
}}>
<View style={styles.bubble}>
<Text>Green</Text>
</View>
</TouchableOpacity>
<TouchableOpacity
onPress={() => {
this.handleColorChange('black');
}}>
<View style={styles.bubble}>
<Text>Black</Text>
</View>
</TouchableOpacity>
<TouchableOpacity
onPress={() => {
this.handleColorChange('red');
}}>
<View style={styles.bubble}>
<Text>Red</Text>
</View>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default SetNativePropsOverlays;
</file>

<file path="example/src/examples/StaticMap.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions, ScrollView} from 'react-native';
import MapView, {Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class StaticMap extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

}

render() {
return (
<View style={styles.container}>
<ScrollView
          style={StyleSheet.absoluteFill}
          contentContainerStyle={styles.scrollview}>
<Text>Clicking</Text>
<Text>and</Text>
<Text>dragging</Text>
<Text>the</Text>
<Text>map</Text>
<Text>will</Text>
<Text>cause</Text>
<Text>the</Text>
<MapView
            provider={this.props.provider}
            style={styles.map}
            scrollEnabled={false}
            zoomEnabled={false}
            pitchEnabled={false}
            rotateEnabled={false}
            initialRegion={this.state.region}>
<Marker
              title="This is a title"
              description="This is a description"
              coordinate={this.state.region}
            />
</MapView>
<Text>parent</Text>
<Text>ScrollView</Text>
<Text>to</Text>
<Text>scroll.</Text>
<Text>When</Text>
<Text>using</Text>
<Text>a Google</Text>
<Text>Map</Text>
<Text>this only</Text>
<Text>works</Text>
<Text>if you</Text>
<Text>disable:</Text>
<Text>scroll,</Text>
<Text>zoom,</Text>
<Text>pitch,</Text>
<Text>rotate.</Text>
<Text>...</Text>
<Text>It</Text>
<Text>would</Text>
<Text>be</Text>
<Text>nice</Text>
<Text>to</Text>
<Text>have</Text>
<Text>an</Text>
<Text>option</Text>
<Text>that</Text>
<Text>still</Text>
<Text>allows</Text>
<Text>zooming.</Text>
</ScrollView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
scrollview: {
alignItems: 'center',
paddingVertical: 40,
},
map: {
width: 250,
height: 250,
},
});

export default StaticMap;
</file>

<file path="example/src/examples/TakeSnapshot.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
  Image,
} from 'react-native';

import MapView, {Marker} from 'react-native-maps';
import flagBlueImg from './assets/flag-blue.png';
import flagPinkImg from './assets/flag-pink.png';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

class MarkerTypes extends React.Component<any, any> {
map: any;
constructor(props: any) {
super(props);
this.state = {
mapSnapshot: null,
};
}

takeSnapshot() {
this.map.takeSnapshot(
300,
300,
{
latitude: LATITUDE - SPACE,
longitude: LONGITUDE - SPACE,
latitudeDelta: 0.01,
longitudeDelta: 0.01 \* ASPECT_RATIO,
},
(err: any, data: any) => {
if (err) {
console.log(err);
}
this.setState({mapSnapshot: data});
},
);
}

render() {
return (
<View style={styles.container}>
<MapView
provider={this.props.provider}
ref={ref => {
this.map = ref;
}}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}>
<Marker
coordinate={{
              latitude: LATITUDE + SPACE,
              longitude: LONGITUDE + SPACE,
            }}
centerOffset={{x: -18, y: -60}}
anchor={{x: 0.69, y: 1}}
image={flagBlueImg}
/>
<Marker
coordinate={{
              latitude: LATITUDE - SPACE,
              longitude: LONGITUDE - SPACE,
            }}
centerOffset={{x: -42, y: -60}}
anchor={{x: 0.84, y: 1}}
image={flagPinkImg}
/>
</MapView>

        <View style={styles.buttonContainer}>
          <TouchableOpacity
            onPress={() => this.takeSnapshot()}
            style={[styles.bubble, styles.button]}>
            <Text>Take snapshot</Text>
          </TouchableOpacity>
        </View>
        {this.state.mapSnapshot && (
          <TouchableOpacity
            style={[styles.container, styles.overlay]}
            onPress={() => this.setState({mapSnapshot: null})}>
            <Image
              source={{uri: this.state.mapSnapshot.uri}}
              style={styles.mapSnapshot}
            />
          </TouchableOpacity>
        )}
      </View>
    );

}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
button: {
width: 140,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
overlay: {
backgroundColor: 'rgba(0,0,0,0.5)',
justifyContent: 'center',
},
mapSnapshot: {width: 300, height: 300},
});

export default MarkerTypes;
</file>

<file path="example/src/examples/TestIdMarkers.tsx">
import React from 'react';
import {StyleSheet, View, Dimensions} from 'react-native';

import MapView, {Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;
const SPACE = 0.01;

function log(eventName: any, e: any) {
console.log(eventName, e.nativeEvent);
}

export default class MarkerTypes extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      a: {
        latitude: LATITUDE + SPACE,
        longitude: LONGITUDE + SPACE,
      },
    };

}

render() {
return (
<View style={styles.container} accessible>
<MapView
provider={this.props.provider}
style={styles.map}
initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: LATITUDE_DELTA,
            longitudeDelta: LONGITUDE_DELTA,
          }}>
<Marker
testID="marker"
coordinate={this.state.a}
onSelect={e => log('onSelect', e)}
onDrag={e => log('onDrag', e)}
onDragStart={e => log('onDragStart', e)}
onDragEnd={e => log('onDragEnd', e)}
onPress={e => log('onPress', e)}
draggable
/>
</MapView>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
});
</file>

<file path="example/src/examples/ThemeMap.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions, ScrollView} from 'react-native';
import MapView, {Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class ThemeMap extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
    };

}

render() {
return (
<View style={styles.container}>
<ScrollView contentContainerStyle={styles.scrollview}>
<Text>MAPKIT ONLY{'\n'}</Text>
<Text>System</Text>
<MapView
            provider={this.props.provider}
            style={styles.map}
            scrollEnabled={false}
            zoomEnabled={false}
            pitchEnabled={false}
            rotateEnabled={false}
            initialRegion={this.state.region}>
<Marker
              title="This is a title"
              description="This is a description"
              coordinate={this.state.region}
            />
</MapView>

          <Text>{'\n'}Light</Text>
          <MapView
            provider={this.props.provider}
            style={styles.map}
            scrollEnabled={false}
            zoomEnabled={false}
            pitchEnabled={false}
            rotateEnabled={false}
            initialRegion={this.state.region}
            userInterfaceStyle="light">
            <Marker
              title="This is a title"
              description="This is a description"
              coordinate={this.state.region}
            />
          </MapView>
          <Text>{'\n'}Dark</Text>
          <MapView
            provider={this.props.provider}
            style={styles.map}
            scrollEnabled={false}
            zoomEnabled={false}
            pitchEnabled={false}
            rotateEnabled={false}
            initialRegion={this.state.region}
            userInterfaceStyle="dark">
            <Marker
              title="This is a title"
              description="This is a description"
              coordinate={this.state.region}
            />
          </MapView>
        </ScrollView>
      </View>
    );

}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
scrollview: {
alignItems: 'center',
paddingVertical: 70,
},
map: {
width: 200,
height: 200,
},
});

export default ThemeMap;
</file>

<file path="example/src/examples/ViewsAsMarkers.tsx">
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';
import MapView, {Marker} from 'react-native-maps';
import PriceMarker from './PriceMarker';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.78825;
const LONGITUDE = -122.4324;
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class ViewsAsMarkers extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      coordinate: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
      },
      amount: 99,
    };

}

increment() {
this.setState({amount: this.state.amount + 1});
}

decrement() {
this.setState({amount: this.state.amount - 1});
}

render() {
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          style={styles.map}
          initialRegion={this.state.region}>
<Marker coordinate={this.state.coordinate}>
<PriceMarker amount={this.state.amount} />
</Marker>
</MapView>
<View style={styles.buttonContainer}>
<TouchableOpacity
onPress={() => this.decrement()}
style={[styles.bubble, styles.button]}>
<Text style={styles.ammountButton}>-</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => this.increment()}
style={[styles.bubble, styles.button]}>
<Text style={styles.ammountButton}>+</Text>
</TouchableOpacity>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
bubble: {
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
ammountButton: {fontSize: 20, fontWeight: 'bold'},
});

export default ViewsAsMarkers;
</file>

<file path="example/src/examples/WMSTiles.tsx">
import React from 'react';
import {StyleSheet, View, Text, Dimensions} from 'react-native';

import MapView, {MAP_TYPES, WMSTile} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 63.5;
const LONGITUDE = 23.5;
const LATITUDE_DELTA = 0.152;
const LONGITUDE_DELTA = LATITUDE_DELTA \* ASPECT_RATIO;

class WMSTiles extends React.Component<any, any> {
constructor(props: any, context: any) {
super(props, context);

    this.state = {
      region: {
        latitude: LATITUDE,
        longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
        longitudeDelta: LONGITUDE_DELTA,
      },
      isWMSTilesActive: false,
    };

}

toggleWMSTiles() {
this.setState({isWMSTilesActive: !this.state.isWMSTilesActive});
}

render() {
const {region} = this.state;
return (
<View style={styles.container}>
<MapView
          provider={this.props.provider}
          mapType={MAP_TYPES.SATELLITE}
          style={styles.map}
          initialRegion={region}>
{this.state.isWMSTilesActive && (
<WMSTile
              urlTemplate="https://julkinen.vayla.fi/inspirepalvelu/wms?service=WMS&version=1.1.1&request=GetMap&layers=avoin:TL137&format=image/png&transparent=true&styles=&bbox={minX},{minY},{maxX},{maxY}&width={width}&height={height}&srs=EPSG:3857"
              zIndex={1}
              opacity={0.5}
              tileSize={512}
            />
)}
</MapView>
<View style={styles.buttonContainer}>
<View style={styles.bubble}>
<Text onPress={() => this.toggleWMSTiles()}>
WMS Tiles: {this.state.isWMSTilesActive ? 'on' : 'off'} (click to
toggle)
</Text>
</View>
</View>
</View>
);
}
}

const styles = StyleSheet.create({
container: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0,
},
bubble: {
flex: 1,
backgroundColor: 'rgba(255,255,255,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
latlng: {
width: 200,
alignItems: 'stretch',
},
button: {
width: 80,
paddingHorizontal: 12,
alignItems: 'center',
marginHorizontal: 10,
},
buttonContainer: {
flexDirection: 'row',
marginVertical: 20,
backgroundColor: 'transparent',
},
});

export default WMSTiles;
</file>

<file path="example/src/examples/ZIndexMarkers.tsx">
import React from 'react';
import {Dimensions, StyleSheet, Text, View} from 'react-native';

import MapView, {Marker} from 'react-native-maps';

const {width, height} = Dimensions.get('window');

const ASPECT_RATIO = width / height;
const LATITUDE = 37.733858;
const LONGITUDE = -122.446549;
const MARKERS_LATITUDE_DELTA = 0.03;
const MARKERS_LONGITUDE_DELTA = MARKERS_LATITUDE_DELTA _ ASPECT_RATIO;
const MAP_LATITUDE_DELTA = 0.3;
const MAP_LONGITUDE_DELTA = MAP_LATITUDE_DELTA _ ASPECT_RATIO;
const NUM_MARKERS = 100;
const PERCENT_SPECIAL_MARKERS = 0.1;

class ZIndexMarkers extends React.Component<any, any> {
map: any;
constructor(props: any) {
super(props);

    const markerInfo = [];
    for (let i = 1; i < NUM_MARKERS; i++) {
      markerInfo.push({
        latitude: (Math.random() * 2 - 1) * MARKERS_LATITUDE_DELTA + LATITUDE,
        longitude:
          (Math.random() * 2 - 1) * MARKERS_LONGITUDE_DELTA + LONGITUDE,
        isSpecial: Math.random() < PERCENT_SPECIAL_MARKERS,
        id: i,
      });
    }

    this.state = {
      markerInfo,
    };

}

render() {
const markers = this.state.markerInfo.map((markerInfo: any) => (
<Marker
coordinate={markerInfo}
key={markerInfo.id}
pinColor={markerInfo.isSpecial ? '#c5a620' : undefined}
style={markerInfo.isSpecial ? styles.specialMarker : null}
/>
));

    return (
      <View style={styles.container}>
        <MapView
          provider={this.props.provider}
          ref={ref => {
            this.map = ref;
          }}
          style={styles.map}
          initialRegion={{
            latitude: LATITUDE,
            longitude: LONGITUDE,
            latitudeDelta: MAP_LATITUDE_DELTA,
            longitudeDelta: MAP_LONGITUDE_DELTA,
          }}>
          {markers}
        </MapView>
        <View style={styles.textContainer}>
          <Text>
            The yellow markers have a higher zIndex and appear above other
            markers.
          </Text>
        </View>
      </View>
    );

}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
map: {
...StyleSheet.absoluteFillObject,
},
textContainer: {
backgroundColor: 'white',
borderRadius: 4,
marginHorizontal: 40,
marginVertical: 20,
padding: 10,
},
specialMarker: {
zIndex: 1,
},
});

export default ZIndexMarkers;
</file>

<file path="example/src/App.tsx">
import React from 'react';
import {
  Platform,
  View,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Text,
  Switch,
} from 'react-native';
import {PROVIDER_GOOGLE, PROVIDER_DEFAULT} from 'react-native-maps';
import DisplayLatLng from './examples/DisplayLatLng';
import ViewsAsMarkers from './examples/ViewsAsMarkers';
import EventListener from './examples/EventListener';
import MarkerTypes from './examples/MarkerTypes';
import DraggableMarkers from './examples/DraggableMarkers';
import PolygonCreator from './examples/PolygonCreator';
import PolylineCreator from './examples/PolylineCreator';
import GradientPolylines from './examples/GradientPolylines';
import GradientPolylinesFunctional from './examples/GradientPolylinesFunctional';
import AnimatedViews from './examples/AnimatedViews';
import AnimatedMarkers from './examples/AnimatedMarkers';
import Callouts from './examples/Callouts';
import Overlays from './examples/Overlays';
import DefaultMarkers from './examples/DefaultMarkers';
import CustomMarkers from './examples/CustomMarkers';
import CachedMap from './examples/CachedMap';
import LoadingMap from './examples/LoadingMap';
import MapBoundaries from './examples/MapBoundaries';
import TakeSnapshot from './examples/TakeSnapshot';
import FitToSuppliedMarkers from './examples/FitToSuppliedMarkers';
import FitToCoordinates from './examples/FitToCoordinates';
import LiteMapView from './examples/LiteMapView';
import CustomTiles from './examples/CustomTiles';
import WMSTiles from './examples/WMSTiles';
import ZIndexMarkers from './examples/ZIndexMarkers';
import StaticMap from './examples/StaticMap';
import ThemeMap from './examples/ThemeMap';
import MapStyle from './examples/MapStyle';
import LegalLabel from './examples/LegalLabel';
import SetNativePropsOverlays from './examples/SetNativePropsOverlays';
import CustomOverlay from './examples/CustomOverlay';
import MapKml from './examples/MapKml';
import BugMarkerWontUpdate from './examples/BugMarkerWontUpdate';
import ImageOverlayWithAssets from './examples/ImageOverlayWithAssets';
import ImageOverlayWithURL from './examples/ImageOverlayWithURL';
import ImageOverlayWithBearing from './examples/ImageOverlayWithBearing';
import AnimatedNavigation from './examples/AnimatedNavigation';
import OnPoiClick from './examples/OnPoiClick';
import TestIdMarkers from './examples/TestIdMarkers';
import IndoorMap from './examples/IndoorMap';
import CameraControl from './examples/CameraControl';
import MassiveCustomMarkers from './examples/MassiveCustomMarkers';
import GeojsonMap from './examples/Geojson';
import CacheURLTiles from './examples/CacheURLTiles';
import CacheWMSTiles from './examples/CacheWMSTiles';

const IOS = Platform.OS === 'ios';
const ANDROID = Platform.OS === 'android';

function makeExampleMapper(useGoogleMaps: boolean) {
if (useGoogleMaps) {
return (example: any) => [
example[0],
[example[1], example[3]].filter(Boolean).join(' '),
];
}
return (example: any) => example;
}

export default class App extends React.Component<any, any> {
constructor(props: any) {
super(props);

    this.state = {
      Component: null,
      useGoogleMaps: ANDROID,
    };

}

renderExample([Component, title]: any) {
return (
<TouchableOpacity
key={title}
style={styles.button}
onPress={() => this.setState({Component})}>
<Text>{title}</Text>
</TouchableOpacity>
);
}

renderBackButton() {
return (
<TouchableOpacity
style={styles.back}
onPress={() => this.setState({Component: null})}>
<Text style={styles.backButton}>&larr;</Text>
</TouchableOpacity>
);
}

renderGoogleSwitch() {
return (
<View>
<Text>Use GoogleMaps?</Text>
<Switch
onValueChange={value => this.setState({useGoogleMaps: value})}
style={styles.googleSwitch}
value={this.state.useGoogleMaps}
/>
</View>
);
}

renderExamples(examples: any) {
const {Component, useGoogleMaps} = this.state;

    return (
      <View style={styles.container}>
        {Component && (
          <Component
            provider={useGoogleMaps ? PROVIDER_GOOGLE : PROVIDER_DEFAULT}
          />
        )}
        {Component && this.renderBackButton()}
        {!Component && (
          <ScrollView
            style={StyleSheet.absoluteFill}
            contentContainerStyle={styles.scrollview}
            showsVerticalScrollIndicator={false}>
            {IOS && this.renderGoogleSwitch()}
            {examples.map((example: any) => this.renderExample(example))}
          </ScrollView>
        )}
      </View>
    );

}

render() {
return this.renderExamples(
[
// [<component>, <component description>, <Google compatible>, <Google add'l description>]
[StaticMap, 'StaticMap', true],
[ThemeMap, 'ThemeMap', true],
[DisplayLatLng, 'Tracking Position', true, '(incomplete)'],
[ViewsAsMarkers, 'Arbitrary Views as Markers', true],
[EventListener, 'Events', true, '(incomplete)'],
[MarkerTypes, 'Image Based Markers', true],
[DraggableMarkers, 'Draggable Markers', true],
[PolygonCreator, 'Polygon Creator', true],
[PolylineCreator, 'Polyline Creator', true],
[GradientPolylines, 'Gradient Polylines', true],
[GradientPolylinesFunctional, 'Gradient Polylines Functional', true],
[AnimatedViews, 'Animating with MapViews'],
[AnimatedMarkers, 'Animated Marker Position'],
[Callouts, 'Custom Callouts', true],
[Overlays, 'Circles, Polygons, and Polylines', true],
[DefaultMarkers, 'Default Markers', true],
[CustomMarkers, 'Custom Markers', true],
[TakeSnapshot, 'Take Snapshot', true, '(incomplete)'],
[CachedMap, 'Cached Map'],
[LoadingMap, 'Map with loading', true],
[MapBoundaries, 'Get visible map boundaries', true],
[FitToSuppliedMarkers, 'Focus Map On Markers', true],
[FitToCoordinates, 'Fit Map To Coordinates', true],
[LiteMapView, 'Android Lite MapView'],
[CustomTiles, 'Custom Tiles', true],
[WMSTiles, 'WMS Tiles', true],
[ZIndexMarkers, 'Position Markers with Z-index', true],
[MapStyle, 'Customize the style of the map', true],
[LegalLabel, 'Reposition the legal label', true],
[SetNativePropsOverlays, 'Update native props', true],
[CustomOverlay, 'Custom Overlay Component', true],
[TestIdMarkers, 'Test ID for Automation', true],
[MapKml, 'Load Map with KML', true],
[BugMarkerWontUpdate, "BUG: Marker Won't Update (Android)", true],
[ImageOverlayWithAssets, 'Image Overlay Component with Assets', true],
[ImageOverlayWithURL, 'Image Overlay Component with URL', true],
[ImageOverlayWithBearing, 'Image Overlay with Bearing', true],
[AnimatedNavigation, 'Animated Map Navigation', true],
[OnPoiClick, 'On Poi Click', true],
[IndoorMap, 'Indoor Map', true],
[CameraControl, 'CameraControl', true],
[MassiveCustomMarkers, 'MassiveCustomMarkers', true],
[GeojsonMap, 'Geojson', true],
[CacheURLTiles, 'CacheURLTiles', true],
[CacheWMSTiles, 'CacheWMSTiles', true],
]
// Filter out examples that are not yet supported for Google Maps on iOS.
.filter(
example =>
ANDROID || (IOS && (example[2] || !this.state.useGoogleMaps)),
)
.map(makeExampleMapper(IOS && this.state.useGoogleMaps)),
);
}
}

const styles = StyleSheet.create({
container: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
alignItems: 'center',
},
scrollview: {
alignItems: 'center',
paddingVertical: 40,
},
button: {
flex: 1,
marginTop: 10,
backgroundColor: 'rgba(220,220,220,0.7)',
paddingHorizontal: 18,
paddingVertical: 12,
borderRadius: 20,
},
back: {
position: 'absolute',
top: 20,
left: 12,
backgroundColor: 'rgba(255,255,255,0.4)',
padding: 12,
borderRadius: 20,
width: 80,
alignItems: 'center',
justifyContent: 'center',
},
backButton: {fontWeight: 'bold', fontSize: 30},
googleSwitch: {marginBottom: 10},
});
</file>

<file path="example/src/declaration.d.ts">
declare module '*.jpg';
declare module '*.png';
</file>

<file path="example/.node-version">
16
</file>

<file path="example/.watchmanconfig">
{}
</file>

<file path="example/app.json">
{
  "name": "rnmshowcase",
  "displayName": "rnmshowcase"
}
</file>

<file path="example/babel.config.js">
const path = require('path');
const pak = require('../package.json');

module.exports = {
presets: [
['module:@react-native/babel-preset'],
['@babel/preset-typescript', {allowDeclareFields: true}], // to allow use of declare context
],
plugins: [
[
'module-resolver',
{
extensions: ['.tsx', '.ts', '.js', '.json'],
alias: {
[pak.name]: path.join(\_\_dirname, '..', pak.source),
},
},
],
],
};
</file>

<file path="example/Gemfile">
source 'https://rubygems.org'

# You may use http://rbenv.org/ or https://rvm.io/ to install and use this version

ruby ">= 2.6.10"

# Exclude problematic versions of cocoapods and activesupport that causes build failures.

gem 'cocoapods', '>= 1.13', '!= 1.15.0', '!= 1.15.1'
gem 'activesupport', '>= 6.1.7.5', '!= 7.1.0'
gem 'xcodeproj', '< 1.26.0'
</file>

<file path="example/index.js">
/**
 * @format
 */

import {AppRegistry} from 'react-native';
import App from './src/App';
import {name as appName} from './app.json';

AppRegistry.registerComponent(appName, () => App);
</file>

<file path="example/metro.config.js">
const path = require('path');
const escape = require('escape-string-regexp');
const exclusionList = require('metro-config/src/defaults/exclusionList');
const pak = require('../package.json');

const root = path.resolve(\_\_dirname, '..');

const modules = Object.keys({
...pak.peerDependencies,
});

const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');

/\*\*

- Metro configuration
- https://reactnative.dev/docs/metro
-
- @type {import('metro-config').MetroConfig}
  \*/
  const config = {
  watchFolders: [root],

// We need to make sure that only one version is loaded for peerDependencies
// So we block them at the root, and alias them to the versions in example's node_modules
resolver: {
blacklistRE: exclusionList(
modules.map(
m => new RegExp(`^${escape(path.join(root, 'node_modules', m))}\\/.*$`),
),
),

    extraNodeModules: modules.reduce((acc, name) => {
      acc[name] = path.join(__dirname, 'node_modules', name);
      return acc;
    }, {}),

},
};

module.exports = mergeConfig(getDefaultConfig(\_\_dirname), config);
</file>

<file path="example/package.json">
{
  "name": "rnmshowcase",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "android": "react-native run-android",
    "ios": "react-native run-ios",
    "start": "react-native start",
    "test": "jest",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx"
  },
  "dependencies": {
    "react": "18.3.1",
    "react-native": "0.76.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/preset-env": "^7.25.3",
    "@babel/runtime": "^7.25.0",
    "@react-native-community/cli": "15.0.0",
    "@react-native-community/cli-platform-android": "15.0.0",
    "@react-native-community/cli-platform-ios": "15.0.0",
    "@react-native/babel-preset": "0.76.1",
    "@react-native/eslint-config": "0.76.1",
    "@react-native/metro-config": "0.76.1",
    "@react-native/typescript-config": "0.76.1",
    "@types/react": "^18.2.6",
    "@types/react-test-renderer": "^18.0.0",
    "babel-plugin-module-resolver": "5.0.0",
    "react-test-renderer": "18.3.1"
  }
}
</file>

<file path="example/react-native.config.js">
const path = require('path');
const pak = require('../package.json');

module.exports = {
dependencies: {
[pak.name]: {
root: path.join(\_\_dirname, '..'),
},
},
};
</file>

<file path="ios/AirGoogleMaps/Resources/GoogleMapsPrivacy.bundle/PrivacyInfo.xcprivacy">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSPrivacyTracking</key>
	<false/>
	<key>NSPrivacyTrackingDomains</key>
	<array>
	</array>
	<key>NSPrivacyCollectedDataTypes</key>
	<array>
		<dict>
			<key>NSPrivacyCollectedDataType</key>
			<string>NSPrivacyCollectedDataTypeCrashData</string>
			<key>NSPrivacyCollectedDataTypeLinked</key>
			<false/>
			<key>NSPrivacyCollectedDataTypeTracking</key>
			<false/>
			<key>NSPrivacyCollectedDataTypePurposes</key>
			<array>
				<string>NSPrivacyCollectedDataTypePurposeAnalytics</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyCollectedDataType</key>
			<string>NSPrivacyCollectedDataTypeDeviceID</string>
			<key>NSPrivacyCollectedDataTypeLinked</key>
			<false/>
			<key>NSPrivacyCollectedDataTypeTracking</key>
			<false/>
			<key>NSPrivacyCollectedDataTypePurposes</key>
			<array>
				<string>NSPrivacyCollectedDataTypePurposeAnalytics</string>
				<string>NSPrivacyCollectedDataTypePurposeAppFunctionality</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyCollectedDataType</key>
			<string>NSPrivacyCollectedDataTypePerformanceData</string>
			<key>NSPrivacyCollectedDataTypeLinked</key>
			<false/>
			<key>NSPrivacyCollectedDataTypeTracking</key>
			<false/>
			<key>NSPrivacyCollectedDataTypePurposes</key>
			<array>
				<string>NSPrivacyCollectedDataTypePurposeAnalytics</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyCollectedDataType</key>
			<string>NSPrivacyCollectedDataTypeProductInteraction</string>
			<key>NSPrivacyCollectedDataTypeLinked</key>
			<false/>
			<key>NSPrivacyCollectedDataTypeTracking</key>
			<false/>
			<key>NSPrivacyCollectedDataTypePurposes</key>
			<array>
				<string>NSPrivacyCollectedDataTypePurposeAnalytics</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyCollectedDataType</key>
			<string>NSPrivacyCollectedDataTypeUserID</string>
			<key>NSPrivacyCollectedDataTypeLinked</key>
			<true/>
			<key>NSPrivacyCollectedDataTypeTracking</key>
			<false/>
			<key>NSPrivacyCollectedDataTypePurposes</key>
			<array>
				<string>NSPrivacyCollectedDataTypePurposeAnalytics</string>
			</array>
		</dict>
	</array>
	<key>NSPrivacyAccessedAPITypes</key>
	<array>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategoryDiskSpace</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>85F4.1</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategoryFileTimestamp</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>C617.1</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategorySystemBootTime</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>35F9.1</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategoryUserDefaults</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>1C8F.1</string>
			</array>
		</dict>
	</array>
</dict>
</plist>
</file>

<file path="ios/AirGoogleMaps/AIRDummyView.h">
//
//  AIRDummyView.h
//  AirMapsExplorer
//
//  Created by Gil Birman on 10/4/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <UIKit/UIKit.h>

@interface AIRDummyView : UIView
@property (nonatomic, weak) UIView \*view;

- (instancetype)initWithView:(UIView\*)view;
  @end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRDummyView.m">
//
//  AIRDummyView.m
//  AirMapsExplorer
//
//  Created by Gil Birman on 10/4/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <Foundation/Foundation.h>
#import "AIRDummyView.h"

@implementation AIRDummyView

- (instancetype)initWithView:(UIView\*)view
  {
  if ((self = [super init])) {
  self.view = view;
  }
  return self;
  }
  @end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGMSMarker.h">
//
//  AIRGMSMarker.h
//  AirMaps
//
//  Created by Gil Birman on 9/5/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <GoogleMaps/GoogleMaps.h>
#import <React/UIView+React.h>

@class AIRGoogleMapMarker;

@interface AIRGMSMarker : GMSMarker
@property (nonatomic, strong) NSString *identifier;
@property (nonatomic, weak) AIRGoogleMapMarker *fakeMarker;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@property (nonatomic, copy) RCTDirectEventBlock onSelect;
@property (nonatomic, copy) RCTDirectEventBlock onDeselect;
@end

@protocol AIRGMSMarkerDelegate <NSObject>
@required
-(void)didTapMarker;
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGMSMarker.m">
//
//  AIRGMSMarker.m
//  AirMaps
//
//  Created by Gil Birman on 9/5/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGMSMarker.h"

@implementation AIRGMSMarker

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGMSPolygon.h">
//
//  AIRGMSPolygon.h
//  AirMaps
//
//  Created by Gerardo Pacheco 02/05/2017.
//

#ifdef HAVE_GOOGLE_MAPS

#import <GoogleMaps/GoogleMaps.h>
#import <React/UIView+React.h>

@class AIRGoogleMapPolygon;

@interface AIRGMSPolygon : GMSPolygon
@property (nonatomic, strong) NSString \*identifier;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGMSPolygon.m">
//
//  AIRGMSPolygon.m
//  AirMaps
//
//  Created by Gerardo Pacheco 02/05/2017.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGMSPolygon.h"

@implementation AIRGMSPolygon

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGMSPolyline.h">
//
//  AIRGMSPolyline.h
//  AirMaps
//
//  Created by Guilherme Pontes 04/05/2017.
//

#ifdef HAVE_GOOGLE_MAPS

#import <GoogleMaps/GoogleMaps.h>
#import <React/UIView+React.h>

@class AIRGoogleMapPolyline;

@interface AIRGMSPolyline : GMSPolyline
@property (nonatomic, strong) NSString \*identifier;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGMSPolyline.m">
//
//  AIRGMSPolyline.m
//  AirMaps
//
//  Created by Guilherme Pontes 04/05/2017.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGMSPolyline.h"

@implementation AIRGMSPolyline
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMap.h">
//
//  AIRGoogleMap.h
//  AirMaps
//
//  Created by Gil Birman on 9/1/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <UIKit/UIKit.h>
#import <React/RCTComponent.h>
#import <React/RCTBridge.h>
#import <GoogleMaps/GoogleMaps.h>
#import <MapKit/MapKit.h>
#import "AIRGMSMarker.h"
#import "RCTConvert+AirMap.h"

@interface AIRGoogleMap : GMSMapView

// TODO: don't use MK region?
@property (nonatomic, weak) RCTBridge *bridge;
@property (nonatomic, assign) MKCoordinateRegion initialRegion;
@property (nonatomic, assign) MKCoordinateRegion region;
@property (nonatomic, assign) GMSCameraPosition *cameraProp; // Because the base class already has a "camera" prop.
@property (nonatomic, strong) GMSCameraPosition *initialCamera;
@property (nonatomic, assign) NSString *customMapStyleString;
@property (nonatomic, assign) UIEdgeInsets mapPadding;
@property (nonatomic, assign) NSString *paddingAdjustmentBehaviorString;
@property (nonatomic, copy) RCTBubblingEventBlock onMapReady;
@property (nonatomic, copy) RCTBubblingEventBlock onMapLoaded;
@property (nonatomic, copy) RCTBubblingEventBlock onKmlReady;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@property (nonatomic, copy) RCTBubblingEventBlock onLongPress;
@property (nonatomic, copy) RCTBubblingEventBlock onPanDrag;
@property (nonatomic, copy) RCTBubblingEventBlock onUserLocationChange;
@property (nonatomic, copy) RCTBubblingEventBlock onMarkerPress;
@property (nonatomic, copy) RCTBubblingEventBlock onMarkerSelect;
@property (nonatomic, copy) RCTBubblingEventBlock onMarkerDeselect;
@property (nonatomic, copy) RCTBubblingEventBlock onChange;
@property (nonatomic, copy) RCTBubblingEventBlock onPoiClick;
@property (nonatomic, copy) RCTDirectEventBlock onRegionChangeStart;
@property (nonatomic, copy) RCTDirectEventBlock onRegionChange;
@property (nonatomic, copy) RCTDirectEventBlock onRegionChangeComplete;
@property (nonatomic, copy) RCTDirectEventBlock onIndoorLevelActivated;
@property (nonatomic, copy) RCTDirectEventBlock onIndoorBuildingFocused;
@property (nonatomic, strong) NSMutableArray *markers;
@property (nonatomic, strong) NSMutableArray *polygons;
@property (nonatomic, strong) NSMutableArray *polylines;
@property (nonatomic, strong) NSMutableArray *circles;
@property (nonatomic, strong) NSMutableArray *heatmaps;
@property (nonatomic, strong) NSMutableArray *tiles;
@property (nonatomic, strong) NSMutableArray *overlays;

@property (nonatomic, assign) BOOL showsBuildings;
@property (nonatomic, assign) BOOL showsTraffic;
@property (nonatomic, assign) BOOL showsCompass;
@property (nonatomic, assign) BOOL scrollEnabled;
@property (nonatomic, assign) BOOL zoomEnabled;
@property (nonatomic, assign) BOOL rotateEnabled;
@property (nonatomic, assign) BOOL scrollDuringRotateOrZoomEnabled;
@property (nonatomic, assign) BOOL pitchEnabled;
@property (nonatomic, assign) BOOL zoomTapEnabled;
@property (nonatomic, assign) BOOL showsUserLocation;
@property (nonatomic, assign) BOOL showsMyLocationButton;
@property (nonatomic, assign) BOOL showsIndoors;
@property (nonatomic, assign) BOOL showsIndoorLevelPicker;
@property (nonatomic, assign) NSString \*kmlSrc;

- (void)didPrepareMap;
- (void)mapViewDidFinishTileRendering;
- (BOOL)didTapMarker:(GMSMarker \*)marker;
- (void)didTapPolyline:(GMSPolyline \*)polyline;
- (void)didTapPolygon:(GMSPolygon \*)polygon;
- (void)didTapAtCoordinate:(CLLocationCoordinate2D)coordinate;
- (void)didLongPressAtCoordinate:(CLLocationCoordinate2D)coordinate;
- (void)willMove:(BOOL)gesture;
- (void)didChangeCameraPosition:(GMSCameraPosition \*)position isGesture:(BOOL)isGesture;
- (void)idleAtCameraPosition:(GMSCameraPosition \*)position isGesture:(BOOL)isGesture;
- (void)didTapPOIWithPlaceID:(NSString _)placeID name:(NSString _) name location:(CLLocationCoordinate2D) location;
- (NSArray \*)getMapBoundaries;

* (MKCoordinateRegion)makeGMSCameraPositionFromMap:(GMSMapView _)map andGMSCameraPosition:(GMSCameraPosition _)position;
* (GMSCameraPosition*)makeGMSCameraPositionFromMap:(GMSMapView *)map andMKCoordinateRegion:(MKCoordinateRegion)region;

- (NSDictionary\*) getMarkersFramesWithOnlyVisible:(BOOL)onlyVisible;
- (instancetype)initWithMapId:(NSString _)mapId initialCamera:(GMSCameraPosition_) camera backgroundColor:(UIColor \*) backgroundColor andZoomTapEnabled:(BOOL)zoomTapEnabled;
  @end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMap.m">
//
//  AIRGoogleMap.m
//  AirMaps
//
//  Created by Gil Birman on 9/1/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMap.h"
#import "AIRGoogleMapMarker.h"
#import "AIRGoogleMapMarkerManager.h"
#import "AIRGoogleMapPolygon.h"
#import "AIRGoogleMapPolyline.h"
#import "AIRGoogleMapCircle.h"
#import "AIRGoogleMapHeatmap.h"
#import "AIRGoogleMapUrlTile.h"
#import "AIRGoogleMapWMSTile.h"
#import "AIRGoogleMapOverlay.h"
#import <GoogleMaps/GoogleMaps.h>
#import <MapKit/MapKit.h>
#import <React/UIView+React.h>
#import <React/RCTBridge.h>
#import "RCTConvert+AirMap.h"
#import <objc/runtime.h>

#ifdef HAVE_GOOGLE_MAPS_UTILS
#import "GMUKMLParser.h"
#import "GMUPlacemark.h"
#import "GMUPoint.h"
#import "GMUGeometryRenderer.h"
#define REQUIRES_GOOGLE_MAPS_UTILS(feature) do {} while (0)
#else
#define GMUKMLParser void
#define GMUPlacemark void
#define REQUIRES_GOOGLE_MAPS_UTILS(feature) do { \
 [NSException raise:@"ReactNativeMapsDependencyMissing" \
 format:@"Use of " feature "requires Google-Maps-iOS-Utils, you must install via CocoaPods to use this feature"]; \
} while (0)
#endif

id regionAsJSON(MKCoordinateRegion region) {
return @{
@"latitude": [NSNumber numberWithDouble:region.center.latitude],
@"longitude": [NSNumber numberWithDouble:region.center.longitude],
@"latitudeDelta": [NSNumber numberWithDouble:region.span.latitudeDelta],
@"longitudeDelta": [NSNumber numberWithDouble:region.span.longitudeDelta],
};
}

@interface AIRGoogleMap () <GMSIndoorDisplayDelegate>

- (id)eventFromCoordinate:(CLLocationCoordinate2D)coordinate;

@property (nonatomic, strong) NSMutableDictionary<NSNumber _, NSDictionary_> \*origGestureRecognizersMeta;

@end

@implementation AIRGoogleMap
{
NSMutableArray<UIView _> _\_reactSubviews;
MKCoordinateRegion \_initialRegion;
MKCoordinateRegion \_region;
BOOL \_initialRegionSet;
BOOL \_initialCameraSet;
BOOL \_didLayoutSubviews;
BOOL \_didPrepareMap;
BOOL \_didCallOnMapReady;
BOOL \_zoomTapEnabled;
NSString\* \_googleMapId;
}

- (instancetype)initWithMapId:(NSString _)mapId initialCamera:(GMSCameraPosition_) camera backgroundColor:(UIColor _) backgroundColor andZoomTapEnabled:(BOOL)zoomTapEnabled
  {
  GMSMapViewOptions_ options = [[GMSMapViewOptions alloc] init];

      if (mapId){
          GMSMapID *mapID = [GMSMapID mapIDWithIdentifier:mapId];
          [options setMapID:mapID];
      }
      if (backgroundColor){
          [options setBackgroundColor:backgroundColor];
      }
      if (camera){
          [options setCamera:camera];
      }
      self = [super initWithOptions:options];

      if (self) {
      _reactSubviews = [NSMutableArray new];
      _markers = [NSMutableArray array];
      _polygons = [NSMutableArray array];
      _polylines = [NSMutableArray array];
      _circles = [NSMutableArray array];
      _heatmaps = [NSMutableArray array];
      _tiles = [NSMutableArray array];
      _overlays = [NSMutableArray array];
      _initialCamera = nil;
      _initialRegion = MKCoordinateRegionMake(CLLocationCoordinate2DMake(0.0, 0.0), MKCoordinateSpanMake(0.0, 0.0));
      _region = MKCoordinateRegionMake(CLLocationCoordinate2DMake(0.0, 0.0), MKCoordinateSpanMake(0.0, 0.0));
      _initialRegionSet = false;
      _initialCameraSet = false;
      _didLayoutSubviews = false;
      _didPrepareMap = false;
      _didCallOnMapReady = false;
      _zoomTapEnabled = zoomTapEnabled;

      // Listen to the myLocation property of GMSMapView.
      [self addObserver:self
             forKeyPath:@"myLocation"
                options:NSKeyValueObservingOptionNew
                context:NULL];

      self.origGestureRecognizersMeta = [[NSMutableDictionary alloc] init];

      self.indoorDisplay.delegate = self;

  }
  return self;
  }

- (instancetype) init {
  return [self initWithMapId:nil initialCamera:nil backgroundColor:nil andZoomTapEnabled:YES];
  }

- (void)dealloc {
  [self removeObserver:self
  forKeyPath:@"myLocation"
  context:NULL];
  }

- (id)eventFromCoordinate:(CLLocationCoordinate2D)coordinate {

  CGPoint touchPoint = [self.projection pointForCoordinate:coordinate];

  return @{
  @"coordinate": @{
  @"latitude": @(coordinate.latitude),
  @"longitude": @(coordinate.longitude),
  },
  @"position": @{
  @"x": @(touchPoint.x),
  @"y": @(touchPoint.y),
  },
  };
  }

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-missing-super-calls"

- (void)insertReactSubview:(id<RCTComponent>)subview atIndex:(NSInteger)atIndex {
  // Our desired API is to pass up markers/overlays as children to the mapview component.
  // This is where we intercept them and do the appropriate underlying mapview action.
  if ([subview isKindOfClass:[AIRGoogleMapMarker class]]) {
  AIRGoogleMapMarker _marker = (AIRGoogleMapMarker_)subview;
  marker.realMarker.map = self;
  [self.markers addObject:marker];
  } else if ([subview isKindOfClass:[AIRGoogleMapPolygon class]]) {
  AIRGoogleMapPolygon _polygon = (AIRGoogleMapPolygon_)subview;
  polygon.polygon.map = self;
  [self.polygons addObject:polygon];
  } else if ([subview isKindOfClass:[AIRGoogleMapPolyline class]]) {
  AIRGoogleMapPolyline _polyline = (AIRGoogleMapPolyline_)subview;
  polyline.polyline.map = self;
  [self.polylines addObject:polyline];
  } else if ([subview isKindOfClass:[AIRGoogleMapCircle class]]) {
  AIRGoogleMapCircle _circle = (AIRGoogleMapCircle_)subview;
  circle.circle.map = self;
  [self.circles addObject:circle];
  } else if ([subview isKindOfClass:[AIRGoogleMapUrlTile class]]) {
  AIRGoogleMapUrlTile _tile = (AIRGoogleMapUrlTile_)subview;
  tile.tileLayer.map = self;
  [self.tiles addObject:tile];
  } else if ([subview isKindOfClass:[AIRGoogleMapWMSTile class]]) {
  AIRGoogleMapWMSTile _tile = (AIRGoogleMapWMSTile_)subview;
  tile.tileLayer.map = self;
  [self.tiles addObject:tile];
  } else if ([subview isKindOfClass:[AIRGoogleMapOverlay class]]) {
  AIRGoogleMapOverlay _overlay = (AIRGoogleMapOverlay_)subview;
  overlay.overlay.map = self;
  [self.overlays addObject:overlay];
  } else if ([subview isKindOfClass:[AIRGoogleMapHeatmap class]]){
  AIRGoogleMapHeatmap _heatmap = (AIRGoogleMapHeatmap_)subview;
  heatmap.heatmap.map = self;
  [self.heatmaps addObject:heatmap];
  } else {
  NSArray<id<RCTComponent>> _childSubviews = [subview reactSubviews];
  for (int i = 0; i < childSubviews.count; i++) {
  [self insertReactSubview:(UIView _)childSubviews[i] atIndex:atIndex];
  }
  }
  [_reactSubviews insertObject:(UIView *)subview atIndex:(NSUInteger) atIndex];
  }
  #pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-missing-super-calls"

- (void)removeReactSubview:(id<RCTComponent>)subview {
  // similarly, when the children are being removed we have to do the appropriate
  // underlying mapview action here.
  if ([subview isKindOfClass:[AIRGoogleMapMarker class]]) {
  AIRGoogleMapMarker _marker = (AIRGoogleMapMarker_)subview;
  marker.realMarker.map = nil;
  [self.markers removeObject:marker];
  } else if ([subview isKindOfClass:[AIRGoogleMapPolygon class]]) {
  AIRGoogleMapPolygon _polygon = (AIRGoogleMapPolygon_)subview;
  polygon.polygon.map = nil;
  [self.polygons removeObject:polygon];
  } else if ([subview isKindOfClass:[AIRGoogleMapPolyline class]]) {
  AIRGoogleMapPolyline _polyline = (AIRGoogleMapPolyline_)subview;
  polyline.polyline.map = nil;
  [self.polylines removeObject:polyline];
  } else if ([subview isKindOfClass:[AIRGoogleMapCircle class]]) {
  AIRGoogleMapCircle _circle = (AIRGoogleMapCircle_)subview;
  circle.circle.map = nil;
  [self.circles removeObject:circle];
  } else if ([subview isKindOfClass:[AIRGoogleMapUrlTile class]]) {
  AIRGoogleMapUrlTile _tile = (AIRGoogleMapUrlTile_)subview;
  tile.tileLayer.map = nil;
  [self.tiles removeObject:tile];
  } else if ([subview isKindOfClass:[AIRGoogleMapWMSTile class]]) {
  AIRGoogleMapWMSTile _tile = (AIRGoogleMapWMSTile_)subview;
  tile.tileLayer.map = nil;
  [self.tiles removeObject:tile];
  } else if ([subview isKindOfClass:[AIRGoogleMapOverlay class]]) {
  AIRGoogleMapOverlay _overlay = (AIRGoogleMapOverlay_)subview;
  overlay.overlay.map = nil;
  [self.overlays removeObject:overlay];
  } else if ([subview isKindOfClass:[AIRGoogleMapHeatmap class]]){
  AIRGoogleMapHeatmap _heatmap = (AIRGoogleMapHeatmap_)subview;
  heatmap.heatmap.map = nil;
  [self.heatmaps removeObject:heatmap];
  } else {
  NSArray<id<RCTComponent>> _childSubviews = [subview reactSubviews];
  for (int i = 0; i < childSubviews.count; i++) {
  [self removeReactSubview:(UIView _)childSubviews[i]];
  }
  }
  [_reactSubviews removeObject:(UIView *)subview];
  }
  #pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-missing-super-calls"

- (NSArray<id<RCTComponent>> \*)reactSubviews {
  return \_reactSubviews;
  }
  #pragma clang diagnostic pop

- (NSArray *)getMapBoundaries
  {
  GMSVisibleRegion visibleRegion = self.projection.visibleRegion;
  GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] initWithRegion:visibleRegion];

      CLLocationCoordinate2D northEast = bounds.northEast;
      CLLocationCoordinate2D southWest = bounds.southWest;

      return @[
          @[
              [NSNumber numberWithDouble:northEast.longitude],
              [NSNumber numberWithDouble:northEast.latitude]
          ],
          @[
              [NSNumber numberWithDouble:southWest.longitude],
              [NSNumber numberWithDouble:southWest.latitude]
          ]
      ];

  }

- (void)layoutSubviews {
  [super layoutSubviews];
  if(\_didLayoutSubviews) return;
  \_didLayoutSubviews = true;

  if (\_initialCamera != nil) {
  self.camera = \_initialCamera;
  \_initialCameraSet = true;
  }
  else if (\_initialRegion.span.latitudeDelta != 0.0 &&
  \_initialRegion.span.longitudeDelta != 0.0) {
  self.camera = [AIRGoogleMap makeGMSCameraPositionFromMap:self andMKCoordinateRegion:_initialRegion];
  \_initialRegionSet = true;
  } else if (\_region.span.latitudeDelta != 0.0 &&
  \_region.span.longitudeDelta != 0.0) {
  self.camera = [AIRGoogleMap makeGMSCameraPositionFromMap:self andMKCoordinateRegion:_region];
  }
  }

- (void)setInitialRegion:(MKCoordinateRegion)initialRegion {
  \_initialRegion = initialRegion;
  if(!\_initialRegionSet && \_didLayoutSubviews){
  self.camera = [AIRGoogleMap makeGMSCameraPositionFromMap:self andMKCoordinateRegion:initialRegion];
  \_initialRegionSet = true;
  }
  }

- (void)setInitialCamera:(GMSCameraPosition\*)initialCamera {
  \_initialCamera = initialCamera;
  if(!\_initialCameraSet && \_didLayoutSubviews){
  self.camera = initialCamera;
  \_initialCameraSet = true;
  }
  }

- (void)setRegion:(MKCoordinateRegion)region {
  // TODO: The JS component is repeatedly setting region unnecessarily. We might want to deal with that in here.
  \_region = region;
  if(\_didLayoutSubviews) {
  self.camera = [AIRGoogleMap makeGMSCameraPositionFromMap:self andMKCoordinateRegion:region];
  }
  }

- (void) setGoogleMapId:(NSString \*) googleMapId {
  \_googleMapId = googleMapId;
  }

- (GMSCameraPosition \*)cameraProp {
  if(\_didLayoutSubviews) {
  return self.camera;
  } else {
  return \_initialCamera;
  }
  }

- (void)setCameraProp:(GMSCameraPosition\*)camera {
  \_initialCamera = camera;
  if(\_didLayoutSubviews) {
  self.camera = camera;
  }
  }

- (void)setOnMapReady:(RCTBubblingEventBlock)onMapReady {
  \_onMapReady = onMapReady;
  if(!\_didCallOnMapReady && \_didPrepareMap) {
  self.onMapReady(@{});
  \_didCallOnMapReady = true;
  }
  }

- (void)didPrepareMap {
  if (!\_didPrepareMap){
  [self overrideGestureRecognizersForView];
  }

  if (!\_didCallOnMapReady && self.onMapReady) {
  self.onMapReady(@{});
  \_didCallOnMapReady = true;
  }
  \_didPrepareMap = true;
  }

- (void)mapViewDidFinishTileRendering {
  if (self.onMapLoaded) self.onMapLoaded(@{});
  }

- (BOOL)didTapMarker:(GMSMarker *)marker {
  AIRGMSMarker *airMarker = (AIRGMSMarker \*)marker;

  id event = @{@"action": @"marker-press",
  @"id": airMarker.identifier ?: @"unknown",
  @"coordinate": @{
  @"latitude": @(airMarker.position.latitude),
  @"longitude": @(airMarker.position.longitude)
  }
  };

  if (airMarker.onPress) airMarker.onPress(event);
  if (self.onMarkerPress) self.onMarkerPress(event);

  // TODO: not sure why this is necessary
  [self setSelectedMarker:marker];

  return NO;
  }

- (void)didTapPolyline:(GMSOverlay *)polyline {
  AIRGMSPolyline *airPolyline = (AIRGMSPolyline \*)polyline;

  id event = @{@"action": @"polyline-press",
  @"id": airPolyline.identifier ?: @"unknown",
  };

  if (airPolyline.onPress) airPolyline.onPress(event);
  }

- (void)didTapPolygon:(GMSOverlay *)polygon {
  AIRGMSPolygon *airPolygon = (AIRGMSPolygon \*)polygon;

      id event = @{@"action": @"polygon-press",
                   @"id": airPolygon.identifier ?: @"unknown",
                   };

      if (airPolygon.onPress) airPolygon.onPress(event);

  }

- (void)didTapAtCoordinate:(CLLocationCoordinate2D)coordinate {
  if (!self.onPress) return;
  self.onPress([self eventFromCoordinate:coordinate]);
  }

- (void)didLongPressAtCoordinate:(CLLocationCoordinate2D)coordinate {
  if (!self.onLongPress) return;
  self.onLongPress([self eventFromCoordinate:coordinate]);
  }

- (void)willMove:(BOOL)gesture {
  id event = @{@"isGesture": [NSNumber numberWithBool:gesture]};
  if (self.onRegionChangeStart) self.onRegionChangeStart(event);
  }

- (void)didChangeCameraPosition:(GMSCameraPosition \*)position isGesture:(BOOL)isGesture{
  id event = @{@"continuous": @YES,
  @"region": regionAsJSON([AIRGoogleMap makeGMSCameraPositionFromMap:self andGMSCameraPosition:position]),
  @"isGesture": [NSNumber numberWithBool:isGesture],
  };

  if (self.onChange) self.onChange(event);
  }

- (void)didTapPOIWithPlaceID:(NSString _)placeID
  name:(NSString _)name
  location:(CLLocationCoordinate2D)location {
  id event = @{@"placeId": placeID,
  @"name": name,
  @"coordinate": @{
  @"latitude": @(location.latitude),
  @"longitude": @(location.longitude)
  }
  };

  if (self.onPoiClick) self.onPoiClick(event);
  }

- (void)idleAtCameraPosition:(GMSCameraPosition \*)position isGesture:(BOOL)isGesture{
  id event = @{@"continuous": @NO,
  @"region": regionAsJSON([AIRGoogleMap makeGMSCameraPositionFromMap:self andGMSCameraPosition:position]),
  @"isGesture": [NSNumber numberWithBool:isGesture],
  };
  if (self.onChange) self.onChange(event); // complete
  }

- (void)setMapPadding:(UIEdgeInsets)mapPadding {
  self.padding = mapPadding;
  }

- (UIEdgeInsets)mapPadding {
  return self.padding;
  }

- (void)setPaddingAdjustmentBehaviorString:(NSString \*)str
  {
  if ([str isEqualToString:@"never"])
  {
  self.paddingAdjustmentBehavior = kGMSMapViewPaddingAdjustmentBehaviorNever;
  }
  else if ([str isEqualToString:@"automatic"])
  {
  self.paddingAdjustmentBehavior = kGMSMapViewPaddingAdjustmentBehaviorAutomatic;
  }
  else //if ([str isEqualToString:@"always"]) <-- default
  {
  self.paddingAdjustmentBehavior = kGMSMapViewPaddingAdjustmentBehaviorAlways;
  }
  }

- (NSString \*)paddingAdjustmentBehaviorString
  {
  switch (self.paddingAdjustmentBehavior)
  {
  case kGMSMapViewPaddingAdjustmentBehaviorNever:
  return @"never";
  case kGMSMapViewPaddingAdjustmentBehaviorAutomatic:
  return @"automatic";
  case kGMSMapViewPaddingAdjustmentBehaviorAlways:
  return @"always";

      default:
        return @"unknown";

  }
  }

- (void)setScrollEnabled:(BOOL)scrollEnabled {
  self.settings.scrollGestures = scrollEnabled;
  }

- (BOOL)scrollEnabled {
  return self.settings.scrollGestures;
  }

- (void)setZoomEnabled:(BOOL)zoomEnabled {
  self.settings.zoomGestures = zoomEnabled;
  }

- (BOOL)zoomEnabled {
  return self.settings.zoomGestures;
  }

- (void)setScrollDuringRotateOrZoomEnabled:(BOOL)enableScrollGesturesDuringRotateOrZoom {
  self.settings.allowScrollGesturesDuringRotateOrZoom = enableScrollGesturesDuringRotateOrZoom;
  }

- (BOOL)scrollDuringRotateOrZoomEnabled {
  return self.settings.allowScrollGesturesDuringRotateOrZoom;
  }

- (void)setZoomTapEnabled:(BOOL)zoomTapEnabled {
  \_zoomTapEnabled = zoomTapEnabled;
  }

- (BOOL)zoomTapEnabled {
  return \_zoomTapEnabled;
  }

- (void)setRotateEnabled:(BOOL)rotateEnabled {
  self.settings.rotateGestures = rotateEnabled;
  }

- (BOOL)rotateEnabled {
  return self.settings.rotateGestures;
  }

- (void)setPitchEnabled:(BOOL)pitchEnabled {
  self.settings.tiltGestures = pitchEnabled;
  }

- (BOOL)pitchEnabled {
  return self.settings.tiltGestures;
  }

- (void)setShowsTraffic:(BOOL)showsTraffic {
  self.trafficEnabled = showsTraffic;
  }

- (BOOL)showsTraffic {
  return self.trafficEnabled;
  }

- (void)setShowsBuildings:(BOOL)showsBuildings {
  self.buildingsEnabled = showsBuildings;
  }

- (BOOL)showsBuildings {
  return self.buildingsEnabled;
  }

- (void)setShowsCompass:(BOOL)showsCompass {
  self.settings.compassButton = showsCompass;
  }

- (void)setCustomMapStyleString:(NSString *)customMapStyleString {
  NSError *error;

  GMSMapStyle \*style = [GMSMapStyle styleWithJSONString:customMapStyleString error:&error];

  if (!style) {
  NSLog(@"The style definition could not be loaded: %@", error);
  }

  self.mapStyle = style;
  }

- (BOOL)showsCompass {
  return self.settings.compassButton;
  }

- (void)setShowsUserLocation:(BOOL)showsUserLocation {
  self.myLocationEnabled = showsUserLocation;
  }

- (BOOL)showsUserLocation {
  return self.myLocationEnabled;
  }

- (void)setShowsMyLocationButton:(BOOL)showsMyLocationButton {
  self.settings.myLocationButton = showsMyLocationButton;
  }

- (BOOL)showsMyLocationButton {
  return self.settings.myLocationButton;
  }

- (void)setMinZoomLevel:(CGFloat)minZoomLevel {
  [self setMinZoom:minZoomLevel maxZoom:self.maxZoom ];
  }

- (void)setMaxZoomLevel:(CGFloat)maxZoomLevel {
  [self setMinZoom:self.minZoom maxZoom:maxZoomLevel ];
  }

- (void)setShowsIndoors:(BOOL)showsIndoors {
  self.indoorEnabled = showsIndoors;
  }

- (BOOL)showsIndoors {
  return self.indoorEnabled;
  }

- (void)setShowsIndoorLevelPicker:(BOOL)showsIndoorLevelPicker {
  self.settings.indoorPicker = showsIndoorLevelPicker;
  }

- (BOOL)showsIndoorLevelPicker {
  return self.settings.indoorPicker;
  }

-(void)setSelectedMarker:(AIRGMSMarker *)selectedMarker {
if (selectedMarker == self.selectedMarker) {
return;
}
AIRGMSMarker *airMarker = (AIRGMSMarker *) self.selectedMarker;
AIRGoogleMapMarker *fakeAirMarker = (AIRGoogleMapMarker *) airMarker.fakeMarker;
AIRGoogleMapMarker *fakeSelectedMarker = (AIRGoogleMapMarker \*) selectedMarker.fakeMarker;

    if (airMarker && airMarker.onDeselect) {
        airMarker.onDeselect([fakeAirMarker makeEventData:@"marker-deselect"]);
    }

    if (airMarker && self.onMarkerDeselect) {
        self.onMarkerDeselect([fakeAirMarker makeEventData:@"marker-deselect"]);
    }

    if (selectedMarker && selectedMarker.onSelect) {
        selectedMarker.onSelect([fakeSelectedMarker makeEventData:@"marker-select"]);
    }

    if (selectedMarker && self.onMarkerSelect) {
        self.onMarkerSelect([fakeSelectedMarker makeEventData:@"marker-select"]);
    }

[super setSelectedMarker:selectedMarker];
}

- (MKCoordinateRegion) makeGMSCameraPositionFromMap:(GMSMapView _)map andGMSCameraPosition:(GMSCameraPosition _)position {
  // solution from here: http://stackoverflow.com/a/16587735/1102215
  GMSVisibleRegion visibleRegion = map.projection.visibleRegion;
  GMSCoordinateBounds \*bounds = [[GMSCoordinateBounds alloc] initWithRegion: visibleRegion];
  CLLocationCoordinate2D center;
  CLLocationDegrees longitudeDelta;
  CLLocationDegrees latitudeDelta = bounds.northEast.latitude - bounds.southWest.latitude;

  if(bounds.northEast.longitude >= bounds.southWest.longitude) {
  //Standard case
  center = CLLocationCoordinate2DMake((bounds.southWest.latitude + bounds.northEast.latitude) / 2,
  (bounds.southWest.longitude + bounds.northEast.longitude) / 2);
  longitudeDelta = bounds.northEast.longitude - bounds.southWest.longitude;
  } else {
  //Region spans the international dateline
  center = CLLocationCoordinate2DMake((bounds.southWest.latitude + bounds.northEast.latitude) / 2,
  (bounds.southWest.longitude + bounds.northEast.longitude + 360) / 2);
  longitudeDelta = bounds.northEast.longitude + 360 - bounds.southWest.longitude;
  }
  MKCoordinateSpan span = MKCoordinateSpanMake(latitudeDelta, longitudeDelta);
  return MKCoordinateRegionMake(center, span);
  }

- (GMSCameraPosition*) makeGMSCameraPositionFromMap:(GMSMapView *)map andMKCoordinateRegion:(MKCoordinateRegion)region {
  float latitudeDelta = region.span.latitudeDelta _ 0.5;
  float longitudeDelta = region.span.longitudeDelta _ 0.5;

  CLLocationCoordinate2D a = CLLocationCoordinate2DMake(region.center.latitude + latitudeDelta,
  region.center.longitude + longitudeDelta);
  CLLocationCoordinate2D b = CLLocationCoordinate2DMake(region.center.latitude - latitudeDelta,
  region.center.longitude - longitudeDelta);
  GMSCoordinateBounds \*bounds = [[GMSCoordinateBounds alloc] initWithCoordinate:a coordinate:b];
  return [map cameraForBounds:bounds insets:UIEdgeInsetsZero];
  }

#pragma mark - Utils

- (CGRect) frameForMarker:(AIRGoogleMapMarker*) mrkView {
  CGPoint mrkAnchor = mrkView.realMarker.groundAnchor;
  CGPoint mrkPoint = [self.projection pointForCoordinate:mrkView.coordinate];
  CGSize mrkSize = mrkView.realMarker.iconView ? mrkView.realMarker.iconView.bounds.size : CGSizeMake(20, 30);
  CGRect mrkFrame = CGRectMake(mrkPoint.x, mrkPoint.y, mrkSize.width, mrkSize.height);
  mrkFrame.origin.y -= mrkAnchor.y * mrkSize.height;
  mrkFrame.origin.x -= mrkAnchor.x \* mrkSize.width;
  return mrkFrame;
  }

- (NSDictionary*) getMarkersFramesWithOnlyVisible:(BOOL)onlyVisible {
  NSMutableDictionary* markersFrames = [NSMutableDictionary new];
  for (AIRGoogleMapMarker* mrkView in self.markers) {
  CGRect frame = [self frameForMarker:mrkView];
  CGPoint point = [self.projection pointForCoordinate:mrkView.coordinate];
  NSDictionary* frameDict = @{
  @"x": @(frame.origin.x),
  @"y": @(frame.origin.y),
  @"width": @(frame.size.width),
  @"height": @(frame.size.height)
  };
  NSDictionary* pointDict = @{
  @"x": @(point.x),
  @"y": @(point.y)
  };
  NSString* k = mrkView.identifier;
  BOOL isVisible = CGRectIntersectsRect(self.bounds, frame);
  if (k != nil && (!onlyVisible || isVisible)) {
  [markersFrames setObject:@{ @"frame": frameDict, @"point": pointDict } forKey:k];
  }
  }
  return markersFrames;
  }

- (AIRGoogleMapMarker*) markerAtPoint:(CGPoint)point {
  AIRGoogleMapMarker* mrk = nil;
  for (AIRGoogleMapMarker\* mrkView in self.markers) {
  CGRect frame = [self frameForMarker:mrkView];
  if (CGRectContainsPoint(frame, point)) {
  mrk = mrkView;
  break;
  }
  }
  return mrk;
  }

-(SEL)getActionForTarget:(NSObject*)target {
SEL action = nil;
uint32_t ivarCount;
Ivar *ivars = class_copyIvarList([target class], &ivarCount);
if (ivars) {
for (uint32_t i = 0 ; i < ivarCount ; i++) {
Ivar ivar = ivars[i];
const char* type = ivar_getTypeEncoding(ivar);
const char* ivarName = ivar_getName(ivar);
NSString* name = [NSString stringWithCString: ivarName encoding: NSASCIIStringEncoding];
if (type[0] == ':' && [name isEqualToString:@"_action"]) {
SEL sel = ((SEL (*)(id, Ivar))object_getIvar)(target, ivar);
action = sel;
break;
}
}
}
free(ivars);
return action;
}

#pragma mark - Overrides for Callout behavior

-(void)overrideGestureRecognizersForView {
NSArray* grs = self.gestureRecognizers;
for (UIGestureRecognizer* gestureRecognizer in grs) {
NSNumber\* grHash = [NSNumber numberWithUnsignedInteger:gestureRecognizer.hash];
if([self.origGestureRecognizersMeta objectForKey:grHash] != nil)
continue; //already patched

        //get original handlers
        NSArray* origTargets = [gestureRecognizer valueForKey:@"targets"];
        NSMutableArray* origTargetsActions = [[NSMutableArray alloc] init];
        BOOL isZoomTapGesture = NO;
        for (NSObject* trg in origTargets) {
            NSObject* target = [trg valueForKey:@"target"];
            SEL action = [self getActionForTarget:trg];
            isZoomTapGesture = [NSStringFromSelector(action) isEqualToString:@"handleZoomTapGesture:"];
            [origTargetsActions addObject:@{
                                            @"target": [NSValue valueWithNonretainedObject:target],
                                            @"action": NSStringFromSelector(action)
                                            }];
        }
        if (isZoomTapGesture && self.zoomTapEnabled == NO) {
            [self removeGestureRecognizer:gestureRecognizer];
            continue;
        }

        //replace with extendedMapGestureHandler
        for (NSDictionary* origTargetAction in origTargetsActions) {
            NSValue* targetValue = [origTargetAction objectForKey:@"target"];
            NSObject* target = [targetValue nonretainedObjectValue];
            NSString* actionString = [origTargetAction objectForKey:@"action"];
            SEL action = NSSelectorFromString(actionString);
            [gestureRecognizer removeTarget:target action:action];
        }
        [gestureRecognizer addTarget:self action:@selector(extendedMapGestureHandler:)];

        [self.origGestureRecognizersMeta setObject:@{@"targets": origTargetsActions}
                                            forKey:grHash];
    }

}

- (id)extendedMapGestureHandler:(UIGestureRecognizer*)gestureRecognizer {
  NSNumber* grHash = [NSNumber numberWithUnsignedInteger:gestureRecognizer.hash];
  UIWindow* win = [[[UIApplication sharedApplication] windows] firstObject];
  NSObject* bubbleProvider = [self valueForKey:@"bubbleProvider"]; //GMSbubbleEntityProvider
  CGRect bubbleAbsoluteFrame = [bubbleProvider accessibilityFrame];
  CGRect bubbleFrame = [win convertRect:bubbleAbsoluteFrame toView:self];
  UIView\* bubbleView = [bubbleProvider valueForKey:@"view"];

      BOOL performOriginalActions = YES;
      BOOL isTap = [gestureRecognizer isKindOfClass:[UITapGestureRecognizer class]] || [gestureRecognizer isMemberOfClass:[UITapGestureRecognizer class]];
      if (isTap) {
          BOOL isTapInsideBubble = NO;
          CGPoint tapPoint = CGPointZero;
          CGPoint tapPointInBubble = CGPointZero;

          NSArray* touches = [gestureRecognizer valueForKey:@"touches"];
          UITouch* oneTouch = [touches firstObject];
          NSArray* delayedTouches = [gestureRecognizer valueForKey:@"delayedTouches"];
          NSObject* delayedTouch = [delayedTouches firstObject]; //UIGestureDeleayedTouch
          UITouch* tapTouch = [delayedTouch valueForKey:@"stateWhenDelayed"];

          if (!tapTouch) {
              tapTouch = oneTouch;
          };

          tapPoint = [tapTouch locationInView:self];
          isTapInsideBubble = tapTouch != nil && CGRectContainsPoint(bubbleFrame, tapPoint);
          if (isTapInsideBubble) {
              tapPointInBubble = CGPointMake(tapPoint.x - bubbleFrame.origin.x, tapPoint.y - bubbleFrame.origin.y);
          }
          if (isTapInsideBubble) {
              //find bubble's marker
              AIRGoogleMapMarker* markerView = nil;
              AIRGMSMarker* marker = nil;
              for (AIRGoogleMapMarker* mrk in self.markers) {
                  if ([mrk.calloutView isEqual:bubbleView]) {
                      markerView = mrk;
                      marker = markerView.realMarker;
                      break;
                  }
              }

              //find real tap target subview
              UIView* realSubview = [(RCTView*)bubbleView hitTest:tapPointInBubble withEvent:nil];
              AIRGoogleMapCalloutSubview* realPressableSubview = nil;
              if (realSubview) {
                  UIView* tmp = realSubview;
                  while (tmp && tmp != win && tmp != bubbleView) {
                      if ([tmp respondsToSelector:@selector(onPress)]) {
                          realPressableSubview = (AIRGoogleMapCalloutSubview*) tmp;
                          break;
                      }
                      tmp = tmp.superview;
                  }
              }

              if (markerView) {
                  BOOL isInsideCallout = [markerView.calloutView isPointInside:tapPointInBubble];
                  if (isInsideCallout) {
                      [markerView didTapInfoWindowOfMarker:marker subview:realPressableSubview point:tapPointInBubble frame:bubbleFrame];
                  } else {
                      AIRGoogleMapMarker* markerAtTapPoint = [self markerAtPoint:tapPoint];
                      if (markerAtTapPoint != nil) {
                          [self didTapMarker:markerAtTapPoint.realMarker];
                      } else {
                          CLLocationCoordinate2D coord = [self.projection coordinateForPoint:tapPoint];
                          [markerView hideCalloutView];
                          [self didTapAtCoordinate:coord];
                      }
                  }

                  performOriginalActions = NO;
              }
          }
      }

      if (performOriginalActions) {
          NSDictionary* origMeta = [self.origGestureRecognizersMeta objectForKey:grHash];
          NSDictionary* origTargets = [origMeta objectForKey:@"targets"];
          for (NSDictionary* origTarget in origTargets) {
              NSValue* targetValue = [origTarget objectForKey:@"target"];
              NSObject* target = [targetValue nonretainedObjectValue];
              NSString* actionString = [origTarget objectForKey:@"action"];
              SEL action = NSSelectorFromString(actionString);

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
  [target performSelector:action withObject:gestureRecognizer];
  #pragma clang diagnostic pop
  }
  }

      return nil;

  }

#pragma mark - KVO updates

- (void)observeValueForKeyPath:(NSString _)keyPath
  ofObject:(id)object
  change:(NSDictionary _)change
  context:(void *)context {
  if ([keyPath isEqualToString:@"myLocation"]){
  CLLocation *location = [object myLocation];

      id event = @{@"coordinate": @{
                      @"latitude": @(location.coordinate.latitude),
                      @"longitude": @(location.coordinate.longitude),
                      @"altitude": @(location.altitude),
                      @"timestamp": @(location.timestamp.timeIntervalSince1970 * 1000),
                      @"accuracy": @(location.horizontalAccuracy),
                      @"altitudeAccuracy": @(location.verticalAccuracy),
                      @"speed": @(location.speed),
                      @"heading": @(location.course),
                      }
                  };

  if (self.onUserLocationChange) self.onUserLocationChange(event);
  } else {
  // This message is not for me; pass it on to super.
  [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
  }
  }

* (NSString _)GetIconUrl:(GMUPlacemark _) marker parser:(GMUKMLParser *) parser {
  #ifdef HAVE_GOOGLE_MAPS_UTILS
  if (marker.style.styleID != nil) {
  for (GMUStyle *style in parser.styles) {
  if (style.styleID == marker.style.styleID) {
  return style.iconUrl;
  }
  }
  }

  return marker.style.iconUrl;
  #else
  REQUIRES_GOOGLE_MAPS_UTILS("GetIconUrl:parser:"); return @"";
  #endif
  }

- (NSString \*)KmlSrc {
  return \_kmlSrc;
  }

- (void)setKmlSrc:(NSString \*)kmlUrl {
  #ifdef HAVE_GOOGLE_MAPS_UTILS

  \_kmlSrc = kmlUrl;

  NSURL *url = [NSURL URLWithString:kmlUrl];
  NSData *urlData = nil;

  if ([url isFileURL]) {
  urlData = [NSData dataWithContentsOfURL:url];
  } else {
  urlData = [[NSFileManager defaultManager] contentsAtPath:kmlUrl];
  }

  GMUKMLParser \*parser = [[GMUKMLParser alloc] initWithData:urlData];
  [parser parse];

  NSUInteger index = 0;
  NSMutableArray \*markers = [[NSMutableArray alloc]init];

  for (GMUPlacemark \*place in parser.placemarks) {

      CLLocationCoordinate2D location =((GMUPoint *) place.geometry).coordinate;

      AIRGoogleMapMarker *marker = (AIRGoogleMapMarker *)[[AIRGoogleMapMarkerManager alloc] view];
      if (!marker.bridge) {
        marker.bridge = _bridge;
      }
      marker.identifier = place.title;
      marker.coordinate = location;
      marker.title = place.title;
      marker.subtitle = place.snippet;
      marker.pinColor = place.style.fillColor;
      marker.imageSrc = [AIRGoogleMap GetIconUrl:place parser:parser];
      marker.layer.backgroundColor = [UIColor clearColor].CGColor;
      marker.layer.position = CGPointZero;

      [self insertReactSubview:(UIView *) marker atIndex:index];

      [markers addObject:@{@"id": marker.identifier,
                           @"title": marker.title,
                           @"description": marker.subtitle,
                           @"coordinate": @{
                               @"latitude": @(location.latitude),
                               @"longitude": @(location.longitude)
                               }
                           }];

      index++;

  }

  id event = @{@"markers": markers};
  if (self.onKmlReady) self.onKmlReady(event);
  #else
  REQUIRES_GOOGLE_MAPS_UTILS();
  #endif
  }

- (void) didChangeActiveBuilding: (nullable GMSIndoorBuilding *) building {
  if (!building) {
  if (!self.onIndoorBuildingFocused) {
  return;
  }
  self.onIndoorBuildingFocused(@{
  @"IndoorBuilding": @{
  @"activeLevelIndex": @0,
  @"underground": @false,
  @"levels": [[NSMutableArray alloc]init]
  }
  });
  }
  NSInteger i = 0;
  NSMutableArray *arrayLevels = [[NSMutableArray alloc]init];
  for (GMSIndoorLevel \*level in building.levels) {
  [arrayLevels addObject: @{
  @"index": @(i),
  @"name" : level.name,
  @"shortName" : level.shortName,
  }];
  i++;
  }
  if (!self.onIndoorBuildingFocused) {
  return;
  }
  self.onIndoorBuildingFocused(@{
  @"IndoorBuilding": @{
  @"activeLevelIndex": @(building.defaultLevelIndex),
  @"underground": @(building.underground),
  @"levels": arrayLevels
  }
  });
  }

- (void) didChangeActiveLevel: (nullable GMSIndoorLevel *) level {
  if (!self.onIndoorLevelActivated || !self.indoorDisplay || !level) {
  return;
  }
  NSInteger i = 0;
  for (GMSIndoorLevel *buildingLevel in self.indoorDisplay.activeBuilding.levels) {
  if (buildingLevel.name == level.name && buildingLevel.shortName == level.shortName) {
  break;
  }
  i++;
  }
  self.onIndoorLevelActivated(@{
  @"IndoorLevel": @{
  @"activeLevelIndex": @(i),
  @"name": level.name,
  @"shortName": level.shortName
  }
  });
  }
  // do nothing, passed as options on initialization
- (void)setLoadingBackgroundColor:(UIColor \*)loadingBackgroundColor {

}

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCallout.h">
//
//  AIRGoogleMapCallout.h
//  AirMaps
//
//  Created by Gil Birman on 9/6/16.
//
//

#ifdef HAVE_GOOGLE_MAPS

#import <UIKit/UIKit.h>
#import <React/RCTView.h>

@interface AIRGoogleMapCallout : UIView
@property (nonatomic, assign) BOOL tooltip;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@property (nonatomic, assign) BOOL alphaHitTest;

- (BOOL) isPointInside:(CGPoint)pointInCallout;

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCallout.m">
//
//  AIRGoogleMapCallout.m
//  AirMaps
//
//  Created by Gil Birman on 9/6/16.
//
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapCallout.h"
#import <React/RCTUtils.h>
#import <React/RCTView.h>
#import <React/RCTBridge.h>

@implementation AIRGoogleMapCallout

- (BOOL) isPointInside:(CGPoint)pointInCallout {
  if (!self.alphaHitTest)
  return TRUE;
  CGFloat alpha = [self alphaOfPoint:pointInCallout];
  return alpha >= 0.01;
  }

- (CGFloat) alphaOfPoint:(CGPoint)point {
  unsigned char pixel[4] = {0};
  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
  CGContextRef context = CGBitmapContextCreate(pixel, 1, 1, 8, 4, colorSpace, kCGBitmapAlphaInfoMask & kCGImageAlphaPremultipliedLast);
  CGContextTranslateCTM(context, -point.x, -point.y);
  [self.layer renderInContext:context];
  CGContextRelease(context);
  CGColorSpaceRelease(colorSpace);
  return pixel[3]/255.0;
  }

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCalloutManager.h">
//
//  AIRGoogleMapCalloutManager.h
//  AirMaps
//
//  Created by Gil Birman on 9/6/16.
//
//

#ifdef HAVE_GOOGLE_MAPS

#import <React/RCTViewManager.h>

@interface AIRGoogleMapCalloutManager : RCTViewManager

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCalloutManager.m">
//
//  AIRGoogleMapCalloutManager.m
//  AirMaps
//
//  Created by Gil Birman on 9/6/16.
//
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapCalloutManager.h"
#import "AIRGoogleMapCallout.h"
#import <React/RCTView.h>

@implementation AIRGoogleMapCalloutManager
RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapCallout *callout = [AIRGoogleMapCallout new];
  return callout;
  }

RCT_EXPORT_VIEW_PROPERTY(tooltip, BOOL)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(alphaHitTest, BOOL)

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCalloutSubview.h">
//
//  AIRGoogleMapCalloutSubview.h
//  AirMaps
//
//  Created by Denis Oblogin on 10/8/18.
//
//

#ifdef HAVE_GOOGLE_MAPS

#import <UIKit/UIKit.h>
#import <React/RCTView.h>

@interface AIRGoogleMapCalloutSubview : UIView
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCalloutSubview.m">
//
//  AIRGoogleMapCalloutSubview.m
//  AirMaps
//
//  Created by Denis Oblogin on 10/8/18.
//
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapCalloutSubview.h"
#import <React/RCTUtils.h>
#import <React/RCTView.h>
#import <React/RCTBridge.h>

@implementation AIRGoogleMapCalloutSubview
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCalloutSubviewManager.h">
//
//  AIRGoogleMapCalloutSubviewManager.h
//  AirMaps
//
//  Created by Denis Oblogin on 10/8/18.
//
//

#ifdef HAVE_GOOGLE_MAPS

#import <React/RCTViewManager.h>

@interface AIRGoogleMapCalloutSubviewManager : RCTViewManager

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCalloutSubviewManager.m">
//
//  AIRGoogleMapCalloutSubviewManager.m
//  AirMaps
//
//  Created by Denis Oblogin on 10/8/18.
//
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapCalloutSubviewManager.h"
#import "AIRGoogleMapCalloutSubview.h"
#import <React/RCTView.h>

@implementation AIRGoogleMapCalloutSubviewManager
RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapCalloutSubview *calloutSubview = [AIRGoogleMapCalloutSubview new];
  return calloutSubview;
  }

RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCircle.h">
//
//  AIRGoogleMapsCircle.h
//
//  Created by Nick Italiano on 10/24/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <GoogleMaps/GoogleMaps.h>
#import "AIRMapCoordinate.h"

@interface AIRGoogleMapCircle : UIView

@property (nonatomic, strong) GMSCircle *circle;
@property (nonatomic, assign) double radius;
@property (nonatomic, assign) CLLocationCoordinate2D centerCoordinate;
@property (nonatomic, strong) UIColor *strokeColor;
@property (nonatomic, assign) double strokeWidth;
@property (nonatomic, strong) UIColor \*fillColor;
@property (nonatomic, assign) int zIndex;

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCircle.m">
//
//  AIRGoogleMapsCircle.m
//
//  Created by Nick Italiano on 10/24/16.
//

#ifdef HAVE_GOOGLE_MAPS
#import <UIKit/UIKit.h>
#import "AIRGoogleMapCircle.h"
#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTUtils.h>

@implementation AIRGoogleMapCircle
{
BOOL \_didMoveToWindow;
}

- (instancetype)init
  {
  if (self = [super init]) {
  \_didMoveToWindow = false;
  \_circle = [[GMSCircle alloc] init];
  \_circle.fillColor = \_fillColor;
  \_circle.strokeColor = \_strokeColor;
  }
  return self;
  }

- (void)didMoveToWindow {
  [super didMoveToWindow];
  if(\_didMoveToWindow) return;
  \_didMoveToWindow = true;
  if(\_fillColor) {
  \_circle.fillColor = \_fillColor;
  }
  if(\_strokeColor) {
  \_circle.strokeColor = \_strokeColor;
  }
  if(\_strokeWidth) {
  \_circle.strokeWidth = \_strokeWidth;
  }
  }

- (void)setRadius:(double)radius
  {
  \_radius = radius;
  \_circle.radius = radius;
  }

- (void)setCenterCoordinate:(CLLocationCoordinate2D)centerCoordinate
  {
  \_centerCoordinate = centerCoordinate;
  \_circle.position = centerCoordinate;
  }

-(void)setStrokeColor:(UIColor \*)strokeColor
{
\_strokeColor = strokeColor;
if(\_didMoveToWindow) {
\_circle.strokeColor = strokeColor;
}
}

-(void)setStrokeWidth:(double)strokeWidth
{
\_strokeWidth = strokeWidth;
if(\_didMoveToWindow) {
\_circle.strokeWidth = strokeWidth;
}
}

-(void)setFillColor:(UIColor \*)fillColor
{
\_fillColor = fillColor;
if(\_didMoveToWindow) {
\_circle.fillColor = fillColor;
}
}

-(void)setZIndex:(int)zIndex
{
\_zIndex = zIndex;
\_circle.zIndex = zIndex;
}

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCircleManager.h">
//
//  AIRGoogleMapCircleManager.h
//
//  Created by Nick Italiano on 10/24/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <React/RCTViewManager.h>

@interface AIRGoogleMapCircleManager : RCTViewManager

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapCircleManager.m">
//
//  AIRGoogleMapCircleManager.m
//
//  Created by Nick Italiano on 10/24/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapCircleManager.h"
#import "AIRGoogleMapCircle.h"
#import <React/RCTBridge.h>
#import <React/UIView+React.h>

@interface AIRGoogleMapCircleManager()

@end

@implementation AIRGoogleMapCircleManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapCircle *circle = [AIRGoogleMapCircle new];
  return circle;
  }

RCT_EXPORT_VIEW_PROPERTY(radius, double)
RCT_REMAP_VIEW_PROPERTY(center, centerCoordinate, CLLocationCoordinate2D)
RCT_EXPORT_VIEW_PROPERTY(strokeColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeWidth, double)
RCT_EXPORT_VIEW_PROPERTY(fillColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(zIndex, int)

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapHeatmap.h">
//
//  AIRGoogleMapHeatmap.h
//
//  Created by David Cako on 29 April 2018.
//

#import "GMUHeatmapTileLayer.h"

@interface AIRGoogleMapHeatmap : UIView

@property (nonatomic, strong) GMUHeatmapTileLayer _heatmap;
@property (nonatomic, strong) NSMutableArray<GMUWeightedLatLng _> *points;
@property (nonatomic, assign) NSUInteger radius;
@property (nonatomic, assign) float opacity;
@property (nonatomic, assign) GMUGradient *gradient;

@end
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapHeatmap.m">
//
//  AIRGoogleMapHeatmap.m
//
//  Created by David Cako on 29 April 2018.
//
#import <UIKit/UIKit.h>
#import "AIRGoogleMapHeatmap.h"
#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>

@implementation AIRGoogleMapHeatmap

- (instancetype)init
  {
  if (self = [super init]) {
  \_heatmap = [[GMUHeatmapTileLayer alloc] init];
  }
  return self;
  }

- (void)setPoints:(NSArray<NSDictionary _> _)points
  {
  NSMutableArray<GMUWeightedLatLng *> *w = [NSMutableArray arrayWithCapacity:points.count];
  for (int i = 0; i < points.count; i++) {
  CLLocationCoordinate2D coord = [RCTConvert CLLocationCoordinate2D:points[i]];
  float intensity = 1.0;
  if (points[i][@"weight"] != nil) {
  intensity = [RCTConvert float:points[i][@"weight"]];
  }
  [w addObject:[[GMUWeightedLatLng alloc] initWithCoordinate:coord intensity:intensity]];
  }
  \_points = w;
  [self.heatmap setWeightedData:w];
  [self.heatmap clearTileCache];
  [self.heatmap setMap:self.heatmap.map];
  }

- (void)setRadius:(NSUInteger)radius
  {
  \_radius = radius;
  [self.heatmap setRadius:radius];
  }

- (void)setOpacity:(float)opacity
  {
  \_opacity = opacity;
  [self.heatmap setOpacity:opacity];
  }

- (void)setGradient:(NSDictionary _)gradient
  {
  NSArray<UIColor _> _colors = [RCTConvert UIColorArray:gradient[@"colors"]];
  NSArray<NSNumber _> \*colorStartPoints = [RCTConvert NSNumberArray:gradient[@"startPoints"]];
  NSUInteger colorMapSize = [RCTConvert NSUInteger:gradient[@"colorMapSize"]];
      GMUGradient *gmuGradient = [[GMUGradient alloc] initWithColors:colors
                                          startPoints:colorStartPoints
                                         colorMapSize:colorMapSize];
      _gradient = gmuGradient;
      [self.heatmap setGradient:gmuGradient];
  }

@end
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapHeatmapManager.h">
//
//  AIRGoogleMapHeatmapManager.h
//
//  Created by David Cako on 29 April 2018.
//

#import <React/RCTViewManager.h>

@interface AIRGoogleMapHeatmapManager : RCTViewManager

@end
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapHeatmapManager.m">
//
//  AIRGoogleMapHeatmapManager.m
//
//  Created by David Cako on 29 April 2018.
//

#import "AIRGoogleMapHeatmapManager.h"
#import "AIRGoogleMapHeatmap.h"
#import "AIRGoogleMap.h"
#import <React/RCTBridge.h>
#import <React/UIView+React.h>

@interface AIRGoogleMapHeatmapManager()

@end

@implementation AIRGoogleMapHeatmapManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapHeatmap *heatmap = [AIRGoogleMapHeatmap new];
  return heatmap;
  }

RCT_EXPORT_VIEW_PROPERTY(points, NSArray<NSDictionary _>)
RCT_EXPORT_VIEW_PROPERTY(radius, NSUInteger)
RCT_EXPORT_VIEW_PROPERTY(opacity, float)
RCT_EXPORT_VIEW_PROPERTY(gradient, NSDictionary _)

@end
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapManager.h">
//
//  AIRGoogleMapManager.h
//  AirMaps
//
//  Created by Gil Birman on 9/1/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <React/RCTViewManager.h>

@interface AIRGoogleMapManager : RCTViewManager

@property (nonatomic, strong) NSDictionary \*initialProps;

@property (nonatomic) BOOL isGesture;

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapManager.m">
//
//  AIRGoogleMapManager.m
//  AirMaps
//
//  Created by Gil Birman on 9/1/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapManager.h"
#import <React/RCTViewManager.h>
#import <React/RCTBridge.h>
#import <React/RCTUIManager.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/RCTConvert.h>
#import <React/UIView+React.h>
#import "RCTConvert+GMSMapViewType.h"
#import "AIRGoogleMap.h"
#import "AIRMapMarker.h"
#import "AIRMapPolyline.h"
#import "AIRMapPolygon.h"
#import "AIRMapCircle.h"
#import "SMCalloutView.h"
#import "AIRGoogleMapMarker.h"
#import "RCTConvert+AirMap.h"

#import <MapKit/MapKit.h>
#import <QuartzCore/QuartzCore.h>

static NSString \*const RCTMapViewKey = @"MapView";

@interface AIRGoogleMapManager() <GMSMapViewDelegate>
{
BOOL didCallOnMapReady;
}
@end

@implementation AIRGoogleMapManager

RCT_EXPORT_MODULE()

- (UIView _)view
  {
  NSString_ googleMapId = nil;
  BOOL zoomTapEnabled = YES;
  UIColor* backgroundColor = nil;
  GMSCameraPosition* camera = nil;

  if (self.initialProps){
  if (self.initialProps[@"googleMapId"]){
  googleMapId = self.initialProps[@"googleMapId"];
  }
  if (self.initialProps[@"zoomTapEnabled"]){
  zoomTapEnabled = self.initialProps[@"zoomTapEnabled"];
  }
  if (self.initialProps[@"loadingBackgroundColor"]){
  backgroundColor = [RCTConvert UIColor:self.initialProps[@"loadingBackgroundColor"]];
  }
  if (self.initialProps[@"initialCamera"]){
  camera = [RCTConvert GMSCameraPositionWithDefaults:self.initialProps[@"initialCamera"] existingCamera:nil];
  }
  }
  AIRGoogleMap \*map = [[AIRGoogleMap alloc] initWithMapId:googleMapId initialCamera:camera backgroundColor:backgroundColor andZoomTapEnabled:zoomTapEnabled];
  map.bridge = self.bridge;
  map.delegate = self;
  map.isAccessibilityElement = NO;
  map.accessibilityElementsHidden = NO;
  map.settings.consumesGesturesInView = NO;

  UIPanGestureRecognizer \*drag = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleMapDrag:)];
  [drag setMinimumNumberOfTouches:1];
  [drag setMaximumNumberOfTouches:1];
  [map addGestureRecognizer:drag];

  UIPinchGestureRecognizer \*pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(handleMapDrag:)];
  [map addGestureRecognizer:pinch];

  return map;
  }

RCT_EXPORT_VIEW_PROPERTY(isAccessibilityElement, BOOL)
RCT_REMAP_VIEW_PROPERTY(testID, accessibilityIdentifier, NSString)
RCT_EXPORT_VIEW_PROPERTY(googleMapId, NSString)
RCT_EXPORT_VIEW_PROPERTY(initialCamera, GMSCameraPosition)
RCT_REMAP_VIEW_PROPERTY(camera, cameraProp, GMSCameraPosition)
RCT_EXPORT_VIEW_PROPERTY(initialRegion, MKCoordinateRegion)
RCT_EXPORT_VIEW_PROPERTY(region, MKCoordinateRegion)
RCT_EXPORT_VIEW_PROPERTY(showsBuildings, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsCompass, BOOL)
//RCT_EXPORT_VIEW_PROPERTY(showsScale, BOOL) // Not supported by GoogleMaps
RCT_EXPORT_VIEW_PROPERTY(showsTraffic, BOOL)
RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(rotateEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(scrollEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(scrollDuringRotateOrZoomEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(pitchEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(zoomTapEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsMyLocationButton, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsIndoors, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsIndoorLevelPicker, BOOL)
RCT_EXPORT_VIEW_PROPERTY(customMapStyleString, NSString)
RCT_EXPORT_VIEW_PROPERTY(mapPadding, UIEdgeInsets)
RCT_REMAP_VIEW_PROPERTY(paddingAdjustmentBehavior, paddingAdjustmentBehaviorString, NSString)
RCT_EXPORT_VIEW_PROPERTY(onMapReady, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMapLoaded, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onKmlReady, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onLongPress, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onPanDrag, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onUserLocationChange, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onChange, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerPress, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerSelect, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerDeselect, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onRegionChangeStart, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onRegionChangeComplete, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onPoiClick, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onIndoorLevelActivated, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onIndoorBuildingFocused, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(mapType, GMSMapViewType)
RCT_EXPORT_VIEW_PROPERTY(minZoomLevel, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(maxZoomLevel, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(kmlSrc, NSString)
RCT_EXPORT_VIEW_PROPERTY(loadingBackgroundColor, UIColor)

RCT_EXPORT_METHOD(getCamera:(nonnull NSNumber *)reactTag
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
reject(@"Invalid argument", [NSString stringWithFormat:@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view], NULL);
} else {
AIRGoogleMap *mapView = (AIRGoogleMap \*)view;
resolve(@{
@"center": @{
@"latitude": @(mapView.camera.target.latitude),
@"longitude": @(mapView.camera.target.longitude),
},
@"pitch": @(mapView.camera.viewingAngle),
@"heading": @(mapView.camera.bearing),
@"zoom": @(mapView.camera.zoom),
});
}
}];
}

RCT_EXPORT_METHOD(setCamera:(nonnull NSNumber *)reactTag
camera:(id)json)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
AIRGoogleMap *mapView = (AIRGoogleMap *)view;
GMSCameraPosition *camera = [RCTConvert GMSCameraPositionWithDefaults:json existingCamera:[mapView cameraProp]];
[mapView setCameraProp:camera];
}
}];
}

RCT_EXPORT_METHOD(animateCamera:(nonnull NSNumber *)reactTag
withCamera:(id)json
withDuration:(CGFloat)duration)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
[CATransaction begin];
[CATransaction setAnimationDuration:duration/1000];
AIRGoogleMap *mapView = (AIRGoogleMap *)view;
GMSCameraPosition *camera = [RCTConvert GMSCameraPositionWithDefaults:json existingCamera:[mapView cameraProp]];
[mapView animateToCameraPosition:camera];
[CATransaction commit];
}
}];
}

RCT_EXPORT_METHOD(animateToRegion:(nonnull NSNumber *)reactTag
withRegion:(MKCoordinateRegion)region
withDuration:(CGFloat)duration)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
// Core Animation must be used to control the animation's duration
// See http://stackoverflow.com/a/15663039/171744
[CATransaction begin];
[CATransaction setAnimationDuration:duration/1000];
AIRGoogleMap *mapView = (AIRGoogleMap *)view;
GMSCameraPosition *camera = [AIRGoogleMap makeGMSCameraPositionFromMap:mapView andMKCoordinateRegion:region];
[mapView animateToCameraPosition:camera];
[CATransaction commit];
}
}];
}

RCT_EXPORT_METHOD(fitToElements:(nonnull NSNumber _)reactTag
edgePadding:(nonnull NSDictionary _)edgePadding
animated:(BOOL)animated)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
AIRGoogleMap _mapView = (AIRGoogleMap _)view;

      CLLocationCoordinate2D myLocation = ((AIRGoogleMapMarker *)(mapView.markers.firstObject)).realMarker.position;
      GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] initWithCoordinate:myLocation coordinate:myLocation];

      for (AIRGoogleMapMarker *marker in mapView.markers)
        bounds = [bounds includingCoordinate:marker.realMarker.position];

        GMSCameraUpdate* cameraUpdate;

        if ([edgePadding count] != 0) {
            // Set Map viewport
            CGFloat top = [RCTConvert CGFloat:edgePadding[@"top"]];
            CGFloat right = [RCTConvert CGFloat:edgePadding[@"right"]];
            CGFloat bottom = [RCTConvert CGFloat:edgePadding[@"bottom"]];
            CGFloat left = [RCTConvert CGFloat:edgePadding[@"left"]];

            cameraUpdate = [GMSCameraUpdate fitBounds:bounds withEdgeInsets:UIEdgeInsetsMake(top, left, bottom, right)];
        } else {
            cameraUpdate = [GMSCameraUpdate fitBounds:bounds withPadding:55.0f];
        }
      if (animated) {
        [mapView animateWithCameraUpdate: cameraUpdate];
      } else {
        [mapView moveCamera: cameraUpdate];
      }
    }

}];
}

RCT_EXPORT_METHOD(fitToSuppliedMarkers:(nonnull NSNumber _)reactTag
markers:(nonnull NSArray _)markers
edgePadding:(nonnull NSDictionary *)edgePadding
animated:(BOOL)animated)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
AIRGoogleMap *mapView = (AIRGoogleMap \*)view;

      NSPredicate *filterMarkers = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
        AIRGoogleMapMarker *marker = (AIRGoogleMapMarker *)evaluatedObject;
        return [marker isKindOfClass:[AIRGoogleMapMarker class]] && [markers containsObject:marker.identifier];
      }];

      NSArray *filteredMarkers = [mapView.markers filteredArrayUsingPredicate:filterMarkers];

      CLLocationCoordinate2D myLocation = ((AIRGoogleMapMarker *)(filteredMarkers.firstObject)).realMarker.position;
      GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] initWithCoordinate:myLocation coordinate:myLocation];

      for (AIRGoogleMapMarker *marker in filteredMarkers)
        bounds = [bounds includingCoordinate:marker.realMarker.position];

      // Set Map viewport
      CGFloat top = [RCTConvert CGFloat:edgePadding[@"top"]];
      CGFloat right = [RCTConvert CGFloat:edgePadding[@"right"]];
      CGFloat bottom = [RCTConvert CGFloat:edgePadding[@"bottom"]];
      CGFloat left = [RCTConvert CGFloat:edgePadding[@"left"]];

      GMSCameraUpdate* cameraUpdate = [GMSCameraUpdate fitBounds:bounds withEdgeInsets:UIEdgeInsetsMake(top, left, bottom, right)];
      if (animated) {
        [mapView animateWithCameraUpdate:cameraUpdate
         ];
      } else {
        [mapView moveCamera: cameraUpdate];
      }
    }

}];
}

RCT_EXPORT_METHOD(fitToCoordinates:(nonnull NSNumber _)reactTag
coordinates:(nonnull NSArray<AIRMapCoordinate _> _)coordinates
edgePadding:(nonnull NSDictionary _)edgePadding
animated:(BOOL)animated)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
AIRGoogleMap _mapView = (AIRGoogleMap _)view;

      CLLocationCoordinate2D myLocation = coordinates.firstObject.coordinate;
      GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] initWithCoordinate:myLocation coordinate:myLocation];

      for (AIRMapCoordinate *coordinate in coordinates)
        bounds = [bounds includingCoordinate:coordinate.coordinate];

      // Set Map viewport
      CGFloat top = [RCTConvert CGFloat:edgePadding[@"top"]];
      CGFloat right = [RCTConvert CGFloat:edgePadding[@"right"]];
      CGFloat bottom = [RCTConvert CGFloat:edgePadding[@"bottom"]];
      CGFloat left = [RCTConvert CGFloat:edgePadding[@"left"]];

      GMSCameraUpdate *cameraUpdate = [GMSCameraUpdate fitBounds:bounds withEdgeInsets:UIEdgeInsetsMake(top, left, bottom, right)];

      if (animated) {
        [mapView animateWithCameraUpdate: cameraUpdate];
      } else {
        [mapView moveCamera: cameraUpdate];
      }
    }

}];
}

RCT_EXPORT_METHOD(takeSnapshot:(nonnull NSNumber _)reactTag
withWidth:(nonnull NSNumber _)width
withHeight:(nonnull NSNumber _)height
withRegion:(MKCoordinateRegion)region
format:(nonnull NSString _)format
quality:(nonnull NSNumber _)quality
result:(nonnull NSString _)result
withCallback:(RCTResponseSenderBlock)callback)
{
NSTimeInterval timeStamp = [[NSDate date] timeIntervalSince1970];
NSString *pathComponent = [NSString stringWithFormat:@"Documents/snapshot-%.20lf.%@", timeStamp, format];
NSString *filePath = [NSHomeDirectory() stringByAppendingPathComponent: pathComponent];

[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRGoogleMap _mapView = (AIRGoogleMap _)view;

      // TODO: currently we are ignoring width, height, region

      UIGraphicsBeginImageContextWithOptions(mapView.frame.size, YES, 0.0f);
      [mapView.layer renderInContext:UIGraphicsGetCurrentContext()];
      UIImage *image = UIGraphicsGetImageFromCurrentImageContext();

      NSData *data;
      if ([format isEqualToString:@"png"]) {
          data = UIImagePNGRepresentation(image);

      }
      else if([format isEqualToString:@"jpg"]) {
            data = UIImageJPEGRepresentation(image, quality.floatValue);
      }

      if ([result isEqualToString:@"file"]) {
          [data writeToFile:filePath atomically:YES];
            callback(@[[NSNull null], filePath]);
        }
        else if ([result isEqualToString:@"base64"]) {
            callback(@[[NSNull null], [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithCarriageReturn]]);
        }
    }
    UIGraphicsEndImageContext();

}];
}

RCT_EXPORT_METHOD(pointForCoordinate:(nonnull NSNumber _)reactTag
coordinate:(NSDictionary _)coordinate
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
CLLocationCoordinate2D coord =
CLLocationCoordinate2DMake(
[coordinate[@"latitude"] doubleValue],
[coordinate[@"longitude"] doubleValue]
);

[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRGoogleMap _mapView = (AIRGoogleMap _)view;

      CGPoint touchPoint = [mapView.projection pointForCoordinate:coord];

      resolve(@{
                @"x": @(touchPoint.x),
                @"y": @(touchPoint.y),
                });
    }

}];
}

RCT_EXPORT_METHOD(coordinateForPoint:(nonnull NSNumber _)reactTag
point:(NSDictionary _)point
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
CGPoint pt = CGPointMake(
[point[@"x"] doubleValue],
[point[@"y"] doubleValue]
);

[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRGoogleMap _mapView = (AIRGoogleMap _)view;

      CLLocationCoordinate2D coordinate = [mapView.projection coordinateForPoint:pt];

      resolve(@{
                @"latitude": @(coordinate.latitude),
                @"longitude": @(coordinate.longitude),
                });
    }

}];
}

RCT_EXPORT_METHOD(getMarkersFrames:(nonnull NSNumber *)reactTag
onlyVisible:(BOOL)onlyVisible
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRGoogleMap *mapView = (AIRGoogleMap \*)view;
resolve([mapView getMarkersFramesWithOnlyVisible:onlyVisible]);
}
}];
}

RCT_EXPORT_METHOD(getMapBoundaries:(nonnull NSNumber *)reactTag
resolver:(RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
NSArray *boundingBox = [view getMapBoundaries];

        resolve(@{
          @"northEast" : @{
            @"longitude" : boundingBox[0][0],
            @"latitude" : boundingBox[0][1]
          },
          @"southWest" : @{
            @"longitude" : boundingBox[1][0],
            @"latitude" : boundingBox[1][1]
          }
        });
    }

}];
}

RCT_EXPORT_METHOD(setMapBoundaries:(nonnull NSNumber *)reactTag
northEast:(CLLocationCoordinate2D)northEast
southWest:(CLLocationCoordinate2D)southWest)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
AIRGoogleMap *mapView = (AIRGoogleMap \*)view;

      GMSCoordinateBounds *bounds = [[GMSCoordinateBounds alloc] initWithCoordinate:northEast coordinate:southWest];

      mapView.cameraTargetBounds = bounds;
    }

}];
}

RCT_EXPORT_METHOD(setIndoorActiveLevelIndex:(nonnull NSNumber *)reactTag
levelIndex:(NSInteger) levelIndex)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRGoogleMap, got: %@", view);
} else {
AIRGoogleMap *mapView = (AIRGoogleMap \*)view;
if (!mapView.indoorDisplay) {
return;
}
if ( levelIndex < [mapView.indoorDisplay.activeBuilding.levels count]) {
mapView.indoorDisplay.activeLevel = mapView.indoorDisplay.activeBuilding.levels[levelIndex];
}
}
}];
}

- (BOOL)requiresMainQueueSetup {
  return YES;
  }

* (NSDictionary \*)constantsToExport {
  return @{ @"legalNotice": [GMSServices openSourceLicenseInfo] };
  }

* (void)mapView:(GMSMapView *)mapView willMove:(BOOL)gesture {
  self.isGesture = gesture;
  AIRGoogleMap *googleMapView = (AIRGoogleMap \*)mapView;
  [googleMapView willMove:gesture];
  }

* (void)mapViewDidStartTileRendering:(GMSMapView *)mapView {
  AIRGoogleMap *googleMapView = (AIRGoogleMap \*)mapView;
  [googleMapView didPrepareMap];
  }

* (void)mapViewDidFinishTileRendering:(GMSMapView *)mapView {
  AIRGoogleMap *googleMapView = (AIRGoogleMap \*)mapView;
  [googleMapView mapViewDidFinishTileRendering];
  }

* (BOOL)mapView:(GMSMapView _)mapView didTapMarker:(GMSMarker _)marker {
  AIRGoogleMap _googleMapView = (AIRGoogleMap _)mapView;
  return [googleMapView didTapMarker:marker];
  }

* (void)mapView:(GMSMapView _)mapView didTapOverlay:(GMSPolygon _)polygon {
  AIRGoogleMap _googleMapView = (AIRGoogleMap _)mapView;
  [googleMapView didTapPolygon:polygon];
  }

* (void)mapView:(GMSMapView *)mapView didTapAtCoordinate:(CLLocationCoordinate2D)coordinate {
  AIRGoogleMap *googleMapView = (AIRGoogleMap \*)mapView;
  [googleMapView didTapAtCoordinate:coordinate];
  }

* (void)mapView:(GMSMapView *)mapView didLongPressAtCoordinate:(CLLocationCoordinate2D)coordinate {
  AIRGoogleMap *googleMapView = (AIRGoogleMap \*)mapView;
  [googleMapView didLongPressAtCoordinate:coordinate];
  }

* (void)mapView:(GMSMapView _)mapView didChangeCameraPosition:(GMSCameraPosition _)position {
  AIRGoogleMap _googleMapView = (AIRGoogleMap _)mapView;
  [googleMapView didChangeCameraPosition:position isGesture:self.isGesture];
  }

* (void)mapView:(GMSMapView _)mapView idleAtCameraPosition:(GMSCameraPosition _)position {
  AIRGoogleMap _googleMapView = (AIRGoogleMap _)mapView;
  [googleMapView idleAtCameraPosition:position isGesture:self.isGesture];
  }

* (UIView _)mapView:(GMSMapView _)mapView markerInfoWindow:(GMSMarker *)marker {
  AIRGMSMarker *aMarker = (AIRGMSMarker \*)marker;
  return [aMarker.fakeMarker markerInfoWindow];}

* (UIView _)mapView:(GMSMapView _)mapView markerInfoContents:(GMSMarker *)marker {
  AIRGMSMarker *aMarker = (AIRGMSMarker \*)marker;
  return [aMarker.fakeMarker markerInfoContents];
  }

* (void)mapView:(GMSMapView _)mapView didTapInfoWindowOfMarker:(GMSMarker _)marker {
  AIRGMSMarker _aMarker = (AIRGMSMarker _)marker;
  [aMarker.fakeMarker didTapInfoWindowOfMarker:aMarker];
  }

* (void)mapView:(GMSMapView _)mapView didBeginDraggingMarker:(GMSMarker _)marker {
  AIRGMSMarker _aMarker = (AIRGMSMarker _)marker;
  [aMarker.fakeMarker didBeginDraggingMarker:aMarker];
  }

* (void)mapView:(GMSMapView _)mapView didEndDraggingMarker:(GMSMarker _)marker {
  AIRGMSMarker _aMarker = (AIRGMSMarker _)marker;
  [aMarker.fakeMarker didEndDraggingMarker:aMarker];
  }

* (void)mapView:(GMSMapView _)mapView didDragMarker:(GMSMarker _)marker {
  AIRGMSMarker _aMarker = (AIRGMSMarker _)marker;
  [aMarker.fakeMarker didDragMarker:aMarker];
  }

* (void)mapView:(GMSMapView _)mapView
  didTapPOIWithPlaceID:(NSString _)placeID
  name:(NSString *)name
  location:(CLLocationCoordinate2D)location {
  AIRGoogleMap *googleMapView = (AIRGoogleMap \*)mapView;
  [googleMapView didTapPOIWithPlaceID:placeID name:name location:location];
  }

#pragma mark Gesture Recognizer Handlers

- (void)handleMapDrag:(UIPanGestureRecognizer*)recognizer {
  AIRGoogleMap *map = (AIRGoogleMap \*)recognizer.view;
  if (!map.onPanDrag) return;

  CGPoint touchPoint = [recognizer locationInView:map];
  CLLocationCoordinate2D coord = [map.projection coordinateForPoint:touchPoint];
  map.onPanDrag(@{
  @"coordinate": @{
  @"latitude": @(coord.latitude),
  @"longitude": @(coord.longitude),
  },
  @"position": @{
  @"x": @(touchPoint.x),
  @"y": @(touchPoint.y),
  },
  @"numberOfTouches": @(recognizer.numberOfTouches),
  });

}

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapMarker.h">
//
//  AIRGoogleMapMarker.h
//  AirMaps
//
//  Created by Gil Birman on 9/2/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTBridge.h>
#import "AIRGMSMarker.h"
#import "AIRGoogleMap.h"
#import "AIRGoogleMapCallout.h"
#import "AIRGoogleMapCalloutSubview.h"

@interface AIRGoogleMapMarker : UIView

@property (nonatomic, weak) RCTBridge *bridge;
@property (nonatomic, strong) AIRGoogleMapCallout *calloutView;
@property (nonatomic, strong) NSString _identifier;
@property (nonatomic, assign) CLLocationCoordinate2D coordinate;
@property (nonatomic, assign) CLLocationDegrees rotation;
@property (nonatomic, strong) AIRGMSMarker_ realMarker;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@property (nonatomic, copy) RCTDirectEventBlock onDragStart;
@property (nonatomic, copy) RCTDirectEventBlock onDrag;
@property (nonatomic, copy) RCTDirectEventBlock onDragEnd;
@property (nonatomic, copy) NSString *imageSrc;
@property (nonatomic, copy) NSString *iconSrc;
@property (nonatomic, copy) NSString *title;
@property (nonatomic, copy) NSString *subtitle;
@property (nonatomic, strong) UIColor \*pinColor;
@property (nonatomic, assign) CGPoint anchor;
@property (nonatomic, assign) CGPoint calloutAnchor;
@property (nonatomic, assign) NSInteger zIndex;
@property (nonatomic, assign) double opacity;
@property (nonatomic, assign) BOOL draggable;
@property (nonatomic, assign) BOOL tappable;
@property (nonatomic, assign) BOOL tracksViewChanges;
@property (nonatomic, assign) BOOL tracksInfoWindowChanges;

- (void)showCalloutView;
- (void)hideCalloutView;
- (void)redraw;
- (UIView \*)markerInfoContents;
- (UIView \*)markerInfoWindow;
- (void)didTapInfoWindowOfMarker:(AIRGMSMarker \*)marker;
- (void)didTapInfoWindowOfMarker:(AIRGMSMarker \*)marker point:(CGPoint)point frame:(CGRect)frame;
- (void)didTapInfoWindowOfMarker:(AIRGMSMarker _)marker subview:(AIRGoogleMapCalloutSubview_)subview point:(CGPoint)point frame:(CGRect)frame;
- (void)didBeginDraggingMarker:(AIRGMSMarker \*)marker;
- (void)didEndDraggingMarker:(AIRGMSMarker \*)marker;
- (void)didDragMarker:(AIRGMSMarker \*)marker;
- (id)makeEventData;
- (id)makeEventData:(NSString \*)action;
  @end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapMarker.m">
//
//  AIRGoogleMapMarker.m
//  AirMaps
//
//  Created by Gil Birman on 9/2/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapMarker.h"
#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTImageLoaderProtocol.h>
#import <React/RCTUtils.h>
#import "AIRGMSMarker.h"
#import "AIRGoogleMapCallout.h"
#import "AIRDummyView.h"

CGRect unionRect(CGRect a, CGRect b) {
return CGRectMake(
MIN(a.origin.x, b.origin.x),
MIN(a.origin.y, b.origin.y),
MAX(a.size.width, b.size.width),
MAX(a.size.height, b.size.height));
}

@interface AIRGoogleMapMarker ()
@end

@implementation AIRGoogleMapMarker {
RCTImageLoaderCancellationBlock \_reloadImageCancellationBlock;
\_\_weak UIImageView _\_iconImageView;
UIView _\_iconView;
}

- (instancetype)init
  {
  if ((self = [super init])) {
  \_realMarker = [[AIRGMSMarker alloc] init];
  \_realMarker.fakeMarker = self;
  \_realMarker.tracksViewChanges = true;
  \_realMarker.tracksInfoWindowChanges = false;
  }
  return self;
  }

- (void)layoutSubviews {
  float width = 0;
  float height = 0;

  for (UIView \*v in [_iconView subviews]) {

      float fw = v.frame.origin.x + v.frame.size.width;
      float fh = v.frame.origin.y + v.frame.size.height;

      width = MAX(fw, width);
      height = MAX(fh, height);

  }

  [_iconView setFrame:CGRectMake(0, 0, width, height)];
  }

- (void)iconViewInsertSubview:(UIView\*)subview atIndex:(NSInteger)atIndex {
  if (!\_realMarker.iconView) {
  \_iconView = [[UIView alloc] init];
  \_realMarker.iconView = \_iconView;
  }
  [_iconView insertSubview:subview atIndex:atIndex];
  }

- (void)insertReactSubview:(id<RCTComponent>)subview atIndex:(NSInteger)atIndex {
  if ([subview isKindOfClass:[AIRGoogleMapCallout class]]) {
  self.calloutView = (AIRGoogleMapCallout _)subview;
  } else { // a child view of the marker
  [self iconViewInsertSubview:(UIView_)subview atIndex:atIndex+1];
  }
  AIRDummyView _dummySubview = [[AIRDummyView alloc] initWithView:(UIView _)subview];
  [super insertReactSubview:(UIView*)dummySubview atIndex:atIndex];
  }

- (void)removeReactSubview:(id<RCTComponent>)dummySubview {
  UIView _subview = [dummySubview isKindOfClass:[AIRDummyView class]] ? ((AIRDummyView _)dummySubview).view : (UIView \*)dummySubview;

  if ([subview isKindOfClass:[AIRGoogleMapCallout class]]) {
  self.calloutView = nil;
  } else {
  [subview removeFromSuperview];
  }
  [super removeReactSubview:(UIView*)dummySubview];
  }

- (void)showCalloutView {
  [_realMarker.map setSelectedMarker:_realMarker];
  }

- (void)hideCalloutView {
  [_realMarker.map setSelectedMarker:Nil];
  }

- (void)redraw {
  if (!\_realMarker.iconView) return;

  BOOL oldValue = \_realMarker.tracksViewChanges;

  if (oldValue == YES)
  {
  // Immediate refresh, like right now. Not waiting for next frame.
  UIView \*view = \_realMarker.iconView;
  \_realMarker.iconView = nil;
  \_realMarker.iconView = view;
  }
  else
  {
  // Refresh according to docs
  \_realMarker.tracksViewChanges = YES;
  \_realMarker.tracksViewChanges = NO;
  }
  }

- (UIView \*)markerInfoContents {
  if (self.calloutView && !self.calloutView.tooltip) {
  return self.calloutView;
  }
  return nil;
  }

- (UIView \*)markerInfoWindow {
  if (self.calloutView && self.calloutView.tooltip) {
  return self.calloutView;
  }
  return nil;
  }

- (void)didTapInfoWindowOfMarker:(AIRGMSMarker \*)marker point:(CGPoint)point frame:(CGRect)frame {
  if (self.calloutView && self.calloutView.onPress) {
  //todo: why not 'callout-press' ?
  id event = @{
  @"action": @"marker-overlay-press",
  @"id": self.identifier ?: @"unknown",
  @"point": @{
  @"x": @(point.x),
  @"y": @(point.y),
  },
  @"frame": @{
  @"x": @(frame.origin.x),
  @"y": @(frame.origin.y),
  @"width": @(frame.size.width),
  @"height": @(frame.size.height),
  }
  };
  self.calloutView.onPress(event);
  }
  }

- (void)didTapInfoWindowOfMarker:(AIRGMSMarker \*)marker {
  [self didTapInfoWindowOfMarker:marker point:CGPointMake(-1, -1) frame:CGRectZero];
  }

- (void)didTapInfoWindowOfMarker:(AIRGMSMarker _)marker subview:(AIRGoogleMapCalloutSubview_)subview point:(CGPoint)point frame:(CGRect)frame {
  if (subview && subview.onPress) {
  //todo: why not 'callout-inside-press' ?
  id event = @{
  @"action": @"marker-inside-overlay-press",
  @"id": self.identifier ?: @"unknown",
  @"point": @{
  @"x": @(point.x),
  @"y": @(point.y),
  },
  @"frame": @{
  @"x": @(frame.origin.x),
  @"y": @(frame.origin.y),
  @"width": @(frame.size.width),
  @"height": @(frame.size.height),
  }
  };
  subview.onPress(event);
  } else {
  [self didTapInfoWindowOfMarker:marker point:point frame:frame];
  }
  }

- (void)didBeginDraggingMarker:(AIRGMSMarker \*)marker {
  if (!self.onDragStart) return;
  self.onDragStart([self makeEventData]);
  }

- (void)didEndDraggingMarker:(AIRGMSMarker \*)marker {
  if (!self.onDragEnd) return;
  self.onDragEnd([self makeEventData]);
  }

- (void)didDragMarker:(AIRGMSMarker \*)marker {
  if (!self.onDrag) return;
  self.onDrag([self makeEventData]);
  }

- (void)setCoordinate:(CLLocationCoordinate2D)coordinate {
  \_realMarker.position = coordinate;
  }

- (CLLocationCoordinate2D)coordinate {
  return \_realMarker.position;
  }

- (void)setRotation:(CLLocationDegrees)rotation {
  \_realMarker.rotation = rotation;
  }

- (CLLocationDegrees)rotation {
  return \_realMarker.rotation;
  }

- (void)setIdentifier:(NSString \*)identifier {
  \_realMarker.identifier = identifier;
  }

- (NSString \*)identifier {
  return \_realMarker.identifier;
  }

- (void)setOnPress:(RCTBubblingEventBlock)onPress {
  \_realMarker.onPress = onPress;
  }

- (RCTBubblingEventBlock)onPress {
  return \_realMarker.onPress;
  }

- (void)setOnSelect:(RCTDirectEventBlock)onSelect {
  \_realMarker.onSelect = onSelect;
  }

- (RCTDirectEventBlock)onSelect {
  return \_realMarker.onSelect;
  }

- (void)setOnDeselect:(RCTDirectEventBlock)onDeselect {
  \_realMarker.onDeselect = onDeselect;
  }

- (RCTDirectEventBlock)onDeselect {
  return \_realMarker.onDeselect;
  }

- (void)setOpacity:(double)opacity
  {
  \_realMarker.opacity = opacity;
  }

- (void)setImageSrc:(NSString \*)imageSrc
  {
  \_imageSrc = imageSrc;

  if (\_reloadImageCancellationBlock) {
  \_reloadImageCancellationBlock();
  \_reloadImageCancellationBlock = nil;
  }

  if (!\_imageSrc) {
  if (\_iconImageView) [_iconImageView removeFromSuperview];
  return;
  }

  if (!\_iconImageView) {
  // prevent glitch with marker (cf. https://github.com/react-native-maps/react-native-maps/issues/738)
  UIImageView \*empyImageView = [[UIImageView alloc] init];
  \_iconImageView = empyImageView;
  [self iconViewInsertSubview:_iconImageView atIndex:0];
  }

  \_reloadImageCancellationBlock = [[_bridge moduleForName:@"ImageLoader"] loadImageWithURLRequest:[RCTConvert NSURLRequest:_imageSrc]
  size:self.bounds.size
  scale:RCTScreenScale()
  clipped:YES
  resizeMode:RCTResizeModeCenter
  progressBlock:nil
  partialLoadBlock:nil
  completionBlock:^(NSError *error, UIImage *image) {
  if (error) {
  // TODO(lmr): do something with the error?
  NSLog(@"%@", error);
  }
  dispatch_async(dispatch_get_main_queue(), ^{

                                                                     // TODO(gil): This way allows different image sizes
                                                                     if (self->_iconImageView) [self->_iconImageView removeFromSuperview];

                                                                     // ... but this way is more efficient?

  // if (\_iconImageView) {
  // [_iconImageView setImage:image];
  // return;
  // }

                                                                     UIImageView *imageView = [[UIImageView alloc] initWithImage:image];

                                                                     // TODO: w,h or pixel density could be a prop.
                                                                     float density = 1;
                                                                     float w = image.size.width/density;
                                                                     float h = image.size.height/density;
                                                                     CGRect bounds = CGRectMake(0, 0, w, h);

                                                                     imageView.contentMode = UIViewContentModeScaleAspectFit;
                                                                     [imageView setFrame:bounds];

                                                                     // NOTE: sizeToFit doesn't work instead. Not sure why.
                                                                     // TODO: Doing it this way is not ideal because it causes things to reshuffle
                                                                     //       when the image loads IF the image is larger than the UIView.
                                                                     //       Shouldn't required images have size info automatically via RN?
                                                                     CGRect selfBounds = unionRect(bounds, self.bounds);
                                                                     [self setFrame:selfBounds];

                                                                     self->_iconImageView = imageView;
                                                                     [self iconViewInsertSubview:imageView atIndex:0];
                                                                   });
                                                                 }];

  }

- (void)setIconSrc:(NSString \*)iconSrc
  {
  \_iconSrc = iconSrc;

  if (\_reloadImageCancellationBlock) {
  \_reloadImageCancellationBlock();
  \_reloadImageCancellationBlock = nil;
  }

  if (!\_realMarker.icon) {
  // prevent glitch with marker (cf. https://github.com/react-native-maps/react-native-maps/issues/3657)
  UIImage \*emptyImage = [[UIImage alloc] init];
  \_realMarker.icon = emptyImage;
  }

  \_reloadImageCancellationBlock =
  [[_bridge moduleForName:@"ImageLoader"] loadImageWithURLRequest:[RCTConvert NSURLRequest:_iconSrc]
  size:self.bounds.size
  scale:RCTScreenScale()
  clipped:YES
  resizeMode:RCTResizeModeCenter
  progressBlock:nil
  partialLoadBlock:nil
  completionBlock:^(NSError *error, UIImage *image) {
  if (error) {
  // TODO(lmr): do something with the error?
  NSLog(@"%@", error);
  }
  dispatch_async(dispatch_get_main_queue(), ^{
  self->\_realMarker.icon = image;
  });
  }];
  }

- (void)setTitle:(NSString \*)title {
  \_realMarker.title = [title copy];
  }

- (NSString \*)title {
  return \_realMarker.title;
  }

- (void)setSubtitle:(NSString \*)subtitle {
  \_realMarker.snippet = subtitle;
  }

- (NSString \*)subtitle {
  return \_realMarker.snippet;
  }

- (void)setPinColor:(UIColor \*)pinColor {
  \_pinColor = pinColor;
  \_realMarker.icon = [GMSMarker markerImageWithColor:pinColor];
  }

- (void)setAnchor:(CGPoint)anchor {
  \_anchor = anchor;
  \_realMarker.groundAnchor = anchor;
  }

- (void)setCalloutAnchor:(CGPoint)calloutAnchor {
  \_calloutAnchor = calloutAnchor;
  \_realMarker.infoWindowAnchor = calloutAnchor;
  }

- (void)setZIndex:(NSInteger)zIndex
  {
  \_zIndex = zIndex;
  \_realMarker.zIndex = (int)zIndex;
  }

- (void)setDraggable:(BOOL)draggable {
  \_realMarker.draggable = draggable;
  }

- (BOOL)draggable {
  return \_realMarker.draggable;
  }

- (void)setTappable:(BOOL)tappable {
  \_realMarker.tappable = tappable;
  }

- (BOOL)tappable {
  return \_realMarker.tappable;
  }

- (void)setFlat:(BOOL)flat {
  \_realMarker.flat = flat;
  }

- (BOOL)flat {
  return \_realMarker.flat;
  }

- (void)setTracksViewChanges:(BOOL)tracksViewChanges {
  \_realMarker.tracksViewChanges = tracksViewChanges;
  }

- (BOOL)tracksViewChanges {
  return \_realMarker.tracksViewChanges;
  }

- (void)setTracksInfoWindowChanges:(BOOL)tracksInfoWindowChanges {
  \_realMarker.tracksInfoWindowChanges = tracksInfoWindowChanges;
  }

- (BOOL)tracksInfoWindowChanges {
  return \_realMarker.tracksInfoWindowChanges;
  }

- (id)makeEventData:(NSString \*)action {
  CLLocationCoordinate2D coordinate = self.realMarker.position;
  CGPoint position = [self.realMarker.map.projection pointForCoordinate:coordinate];

      return @{
              @"id": self.identifier ?: @"unknown",
              @"position": @{
                  @"x": @(position.x),
                  @"y": @(position.y),
                  },
              @"coordinate": @{
                  @"latitude": @(coordinate.latitude),
                  @"longitude": @(coordinate.longitude),
                  },
              @"action": action,
              };

  }

- (id)makeEventData {
  return [self makeEventData:@"unknown"];
  }

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapMarkerManager.h">
//
//  AIRGoogleMapMarkerManager.h
//  AirMaps
//
//  Created by Gil Birman on 9/2/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <React/RCTViewManager.h>

@interface AIRGoogleMapMarkerManager : RCTViewManager

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapMarkerManager.m">
//
//  AIRGoogleMapMarkerManager.m
//  AirMaps
//
//  Created by Gil Birman on 9/2/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapMarkerManager.h"
#import "AIRGoogleMapMarker.h"
#import <MapKit/MapKit.h>
#import <React/RCTUIManager.h>
#import "RCTConvert+AirMap.h"

@implementation AIRGoogleMapMarkerManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapMarker *marker = [AIRGoogleMapMarker new];
  // UITapGestureRecognizer \*tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(\_handleTap:)];
  // // setting this to NO allows the parent MapView to continue receiving marker selection events
  // tapGestureRecognizer.cancelsTouchesInView = NO;
  // [marker addGestureRecognizer:tapGestureRecognizer];
  marker.bridge = self.bridge;
  marker.isAccessibilityElement = YES;
  marker.accessibilityElementsHidden = NO;
  return marker;
  }

RCT_EXPORT_VIEW_PROPERTY(identifier, NSString)
RCT_EXPORT_VIEW_PROPERTY(coordinate, CLLocationCoordinate2D)
RCT_EXPORT_VIEW_PROPERTY(rotation, CLLocationDegrees)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)
RCT_REMAP_VIEW_PROPERTY(image, imageSrc, NSString)
RCT_REMAP_VIEW_PROPERTY(icon, iconSrc, NSString)
RCT_EXPORT_VIEW_PROPERTY(title, NSString)
RCT_REMAP_VIEW_PROPERTY(testID, accessibilityIdentifier, NSString)
RCT_REMAP_VIEW_PROPERTY(description, subtitle, NSString)
RCT_EXPORT_VIEW_PROPERTY(pinColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(anchor, CGPoint)
RCT_EXPORT_VIEW_PROPERTY(calloutAnchor, CGPoint)
RCT_EXPORT_VIEW_PROPERTY(zIndex, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(draggable, BOOL)
RCT_EXPORT_VIEW_PROPERTY(tappable, BOOL)
RCT_EXPORT_VIEW_PROPERTY(flat, BOOL)
RCT_EXPORT_VIEW_PROPERTY(tracksViewChanges, BOOL)
RCT_EXPORT_VIEW_PROPERTY(tracksInfoWindowChanges, BOOL)
RCT_EXPORT_VIEW_PROPERTY(opacity, double)
RCT_EXPORT_VIEW_PROPERTY(onDragStart, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onDrag, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onDragEnd, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onSelect, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onDeselect, RCTDirectEventBlock)

RCT_EXPORT_METHOD(showCallout:(nonnull NSNumber *)reactTag)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> _viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMapMarker class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
[(AIRGoogleMapMarker _) view showCalloutView];
}
}];
}

RCT_EXPORT_METHOD(hideCallout:(nonnull NSNumber *)reactTag)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> _viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMapMarker class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
[(AIRGoogleMapMarker _) view hideCalloutView];
}
}];
}

RCT_EXPORT_METHOD(redrawCallout:(nonnull NSNumber *)reactTag)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> _viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMapMarker class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRGoogleMapMarker_ marker = (AIRGoogleMapMarker \*) view;

            [NSTimer scheduledTimerWithTimeInterval:0.0
                                             target:[NSBlockOperation blockOperationWithBlock:^{
                [marker hideCalloutView];
                [marker showCalloutView];
            }]
                                           selector:@selector(main)
                                           userInfo:nil
                                            repeats:NO
             ];
        }
    }];

}

RCT_EXPORT_METHOD(redraw:(nonnull NSNumber *)reactTag)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> _viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRGoogleMapMarker class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
[(AIRGoogleMapMarker _) view redraw];
}
}];
}
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapOverlay.h">
//
//  AIRGoogleMapOverlay.h
//
//  Created by Taro Matsuzawa on 5/3/17.
//

#ifdef HAVE_GOOGLE_MAPS

#import <Foundation/Foundation.h>
#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTBridge.h>
#import "AIRMapCoordinate.h"
#import "AIRGoogleMap.h"

@interface AIRGoogleMapOverlay : UIView

@property (nonatomic, strong) GMSGroundOverlay *overlay;
@property (nonatomic, copy) NSString *imageSrc;
@property (nonatomic, strong, readonly) UIImage *overlayImage;
@property (nonatomic, copy) NSArray *boundsRect;
@property (nonatomic, assign) CGFloat opacity;
@property (nonatomic, readonly) GMSCoordinateBounds \*overlayBounds;
@property (nonatomic, readonly) double bearing;

@property (nonatomic, weak) RCTBridge \*bridge;

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapOverlay.m">
//
//  AIRGoogleMapOverlay.m
//  Created by Nick Italiano on 3/5/17.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapOverlay.h"

#import <React/RCTEventDispatcher.h>
#import <React/RCTImageLoaderProtocol.h>
#import <React/RCTUtils.h>
#import <React/UIView+React.h>

@interface AIRGoogleMapOverlay()
@property (nonatomic, strong, readwrite) UIImage *overlayImage;
@property (nonatomic, readwrite) GMSCoordinateBounds *overlayBounds;
@property (nonatomic) CLLocationDirection bearing;
@end

@implementation AIRGoogleMapOverlay {
RCTImageLoaderCancellationBlock \_reloadImageCancellationBlock;
CLLocationCoordinate2D \_southWest;
CLLocationCoordinate2D \_northEast;
}

- (instancetype)init
  {
  if ((self = [super init])) {
  \_overlay = [[GMSGroundOverlay alloc] init];
  }
  return self;
  }

- (void)setImageSrc:(NSString \*)imageSrc
  {
  NSLog(@">>> SET IMAGESRC: %@", imageSrc);
  \_imageSrc = imageSrc;

  if (\_reloadImageCancellationBlock) {
  \_reloadImageCancellationBlock();
  \_reloadImageCancellationBlock = nil;
  }

  \_\_weak typeof(self) weakSelf = self;
  \_reloadImageCancellationBlock = [[_bridge moduleForName:@"ImageLoader"] loadImageWithURLRequest:[RCTConvert NSURLRequest:_imageSrc]
  size:weakSelf.bounds.size
  scale:RCTScreenScale()
  clipped:YES
  resizeMode:RCTResizeModeCenter
  progressBlock:nil
  partialLoadBlock:nil
  completionBlock:^(NSError *error, UIImage *image) {
  if (error) {
  NSLog(@"%@", error);
  }
  dispatch_async(dispatch_get_main_queue(), ^{
  NSLog(@">>> IMAGE: %@", image);
  weakSelf.overlayImage = image;
  weakSelf.overlay.icon = image;
  });
  }];

}

- (void)setBoundsRect:(NSArray \*)boundsRect
  {
  \_boundsRect = boundsRect;

  \_southWest = CLLocationCoordinate2DMake([boundsRect[1][0] doubleValue], [boundsRect[0][1] doubleValue]);
  \_northEast = CLLocationCoordinate2DMake([boundsRect[0][0] doubleValue], [boundsRect[1][1] doubleValue]);

  \_overlayBounds = [[GMSCoordinateBounds alloc] initWithCoordinate:\_southWest
  coordinate:\_northEast];

  \_overlay.bounds = \_overlayBounds;
  }

- (void)setBearing:(double)bearing
  {
  \_bearing = (double)bearing;
  \_overlay.bearing = \_bearing;
  }

- (void)setOpacity:(CGFloat)opacity
  {
  \_overlay.opacity = opacity;
  }

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapOverlayManager.h">
//
//  AIRGoogleMapOverlayManager.h
//  Created by Taro Matsuzawa on 3/5/17.
//

#import <Foundation/Foundation.h>
#import <React/RCTViewManager.h>

@interface AIRGoogleMapOverlayManager : RCTViewManager
@end
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapOverlayManager.m">
#import "AIRGoogleMapOverlayManager.h"
#import "AIRGoogleMapOverlay.h"

@interface AIRGoogleMapOverlayManager()

@end

@implementation AIRGoogleMapOverlayManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapOverlay *overlay = [AIRGoogleMapOverlay new];
  overlay.bridge = self.bridge;
  return overlay;
  }

RCT_REMAP_VIEW_PROPERTY(bounds, boundsRect, NSArray)
RCT_REMAP_VIEW_PROPERTY(bearing, bearing, double)
RCT_REMAP_VIEW_PROPERTY(image, imageSrc, NSString)
RCT_REMAP_VIEW_PROPERTY(opacity, opacity, CGFloat)

@end
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapPolygon.h">
//
//  AIRGoogleMapPolygon.h
//
//  Created by Nick Italiano on 10/22/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTBridge.h>
#import "AIRGMSPolygon.h"
#import "AIRMapCoordinate.h"

@interface AIRGoogleMapPolygon : UIView

@property (nonatomic, weak) RCTBridge *bridge;
@property (nonatomic, strong) NSString *identifier;
@property (nonatomic, strong) AIRGMSPolygon _polygon;
@property (nonatomic, strong) NSArray<AIRMapCoordinate _> _coordinates;
@property (nonatomic, strong) NSArray<NSArray<AIRMapCoordinate _> *> *holes;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;

@property (nonatomic, strong) UIColor *fillColor;
@property (nonatomic, assign) double strokeWidth;
@property (nonatomic, strong) UIColor *strokeColor;
@property (nonatomic, assign) BOOL geodesic;
@property (nonatomic, assign) int zIndex;
@property (nonatomic, assign) BOOL tappable;

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapPolygon.m">
//
//  AIRGoogleMapPolygon.m
//
//  Created by Nick Italiano on 10/22/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapPolygon.h"
#import "AIRGMSPolygon.h"
#import <GoogleMaps/GoogleMaps.h>

@implementation AIRGoogleMapPolygon
{
BOOL \_didMoveToWindow;
}

- (instancetype)init
  {
  if (self = [super init]) {
  \_didMoveToWindow = false;
  \_polygon = [[AIRGMSPolygon alloc] init];
  \_polygon.fillColor = \_fillColor;
  \_polygon.strokeColor = \_strokeColor;
  }

  return self;
  }

- (void)didMoveToWindow {
  [super didMoveToWindow];
  if(\_didMoveToWindow) return;
  \_didMoveToWindow = true;
  if(\_fillColor) {
  \_polygon.fillColor = \_fillColor;
  }
  if(\_strokeColor) {
  \_polygon.strokeColor = \_strokeColor;
  }
  if(\_strokeWidth) {
  \_polygon.strokeWidth = \_strokeWidth;
  }
  }

- (void)setCoordinates:(NSArray<AIRMapCoordinate _> _)coordinates
  {
  \_coordinates = coordinates;

  GMSMutablePath \*path = [GMSMutablePath path];
  for(int i = 0; i < coordinates.count; i++)
  {
  [path addCoordinate:coordinates[i].coordinate];
  }

  \_polygon.path = path;
  }

- (void)setHoles:(NSArray<NSArray<AIRMapCoordinate _> _> \*)holes
  {
  \_holes = holes;

  if (holes.count)
  {
  NSMutableArray<GMSMutablePath *> *interiorPolygons = [NSMutableArray array];
  for(int h = 0; h < holes.count; h++)
  {
  GMSMutablePath \*path = [GMSMutablePath path];
  for(int i = 0; i < holes[h].count; i++)
  {
  [path addCoordinate:holes[h][i].coordinate];
  }
  [interiorPolygons addObject:path];
  }

      _polygon.holes = interiorPolygons;

  }
  }

-(void)setFillColor:(UIColor \*)fillColor
{
\_fillColor = fillColor;
if(\_didMoveToWindow) {
\_polygon.fillColor = fillColor;
}
}

-(void)setStrokeWidth:(double)strokeWidth
{
\_strokeWidth = strokeWidth;
if(\_didMoveToWindow) {
\_polygon.strokeWidth = strokeWidth;
}
}

-(void)setStrokeColor:(UIColor \*) strokeColor
{
\_strokeColor = strokeColor;
if(\_didMoveToWindow) {
\_polygon.strokeColor = strokeColor;
}
}

-(void)setGeodesic:(BOOL)geodesic
{
\_geodesic = geodesic;
\_polygon.geodesic = geodesic;
}

-(void)setZIndex:(int)zIndex
{
\_zIndex = zIndex;
\_polygon.zIndex = zIndex;
}

-(void)setTappable:(BOOL)tappable
{
\_tappable = tappable;
\_polygon.tappable = tappable;
}

- (void)setOnPress:(RCTBubblingEventBlock)onPress {
  \_polygon.onPress = onPress;
  }

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapPolygonManager.h">
//
//  AIRGoogleMapPolylgoneManager.h
//
//  Created by Nick Italiano on 10/22/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <React/RCTViewManager.h>

@interface AIRGoogleMapPolygonManager : RCTViewManager

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapPolygonManager.m">
//
//  AIRGoogleMapPolylgoneManager.m
//
//  Created by Nick Italiano on 10/22/16.
//

#ifdef HAVE_GOOGLE_MAPS
#import "AIRGoogleMapPolygonManager.h"

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "RCTConvert+AirMap.h"
#import "AIRGoogleMapPolygon.h"

@interface AIRGoogleMapPolygonManager()

@end

@implementation AIRGoogleMapPolygonManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapPolygon *polygon = [AIRGoogleMapPolygon new];
  polygon.bridge = self.bridge;
  return polygon;
  }

RCT_EXPORT_VIEW_PROPERTY(coordinates, AIRMapCoordinateArray)
RCT_EXPORT_VIEW_PROPERTY(holes, AIRMapCoordinateArrayArray)
RCT_EXPORT_VIEW_PROPERTY(fillColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeWidth, double)
RCT_EXPORT_VIEW_PROPERTY(strokeColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(geodesic, BOOL)
RCT_EXPORT_VIEW_PROPERTY(zIndex, int)
RCT_EXPORT_VIEW_PROPERTY(tappable, BOOL)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapPolyline.h">
//
//  AIRGoogleMapPolyline.h
//
//  Created by Nick Italiano on 10/22/16.
//

#ifdef HAVE_GOOGLE_MAPS
#import <UIKit/UIKit.h>
#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTBridge.h>
#import "AIRGMSPolyline.h"
#import "AIRMapCoordinate.h"
#import "AIRGoogleMapMarker.h"

@interface AIRGoogleMapPolyline : UIView

@property (nonatomic, weak) RCTBridge *bridge;
@property (nonatomic, strong) NSString *identifier;
@property (nonatomic, strong) AIRGMSPolyline _polyline;
@property (nonatomic, strong) NSArray<AIRMapCoordinate _> *coordinates;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@property (nonatomic, strong) GMSMapView *originalMap;

@property (nonatomic, strong) UIColor _strokeColor;
@property (nonatomic, strong) NSArray<UIColor _> *strokeColors;
@property (nonatomic, assign) double strokeWidth;
@property (nonatomic, assign) UIColor *fillColor;
@property (nonatomic, strong) NSArray<NSNumber *> *lineDashPattern;
@property (nonatomic, assign) BOOL geodesic;
@property (nonatomic, assign) NSString \*title;
@property (nonatomic, assign) int zIndex;
@property (nonatomic, assign) BOOL tappable;

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapPolyline.m">
//
//  AIRGoogleMapPolyline.m
//
//  Created by Nick Italiano on 10/22/16.
//

#ifdef HAVE_GOOGLE_MAPS
#import <UIKit/UIKit.h>
#import "AIRGoogleMapPolyline.h"
#import "AIRGMSPolyline.h"
#import "AIRMapCoordinate.h"
#import "AIRGoogleMapMarker.h"
#import "AIRGoogleMapMarkerManager.h"
#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTUtils.h>

@implementation AIRGoogleMapPolyline

- (instancetype)init
  {
  if (self = [super init]) {
  \_polyline = [[AIRGMSPolyline alloc] init];
    _polyline.spans = @[[GMSStyleSpan spanWithColor:_strokeColor]];
  \_polyline.strokeColor = \_strokeColor;
  }
  return self;
  }

-(void)setCoordinates:(NSArray<AIRMapCoordinate _> _)coordinates
{
\_coordinates = coordinates;

GMSMutablePath \*path = [GMSMutablePath path];

if (!coordinates || coordinates.count == 0)
{
[path removeAllCoordinates];
return;
}

for (int i = 0; i < coordinates.count; i++) {
[path addCoordinate:coordinates[i].coordinate];
}

\_polyline.path = path;

[self configureStyleSpansIfNeeded];
}

-(void)setStrokeColor:(UIColor \*)strokeColor
{
\_strokeColor = strokeColor;
\_polyline.strokeColor = strokeColor;
[self configureStyleSpansIfNeeded];
}

-(void)setStrokeColors:(NSArray<UIColor _> _)strokeColors
{
NSMutableArray *spans = [NSMutableArray arrayWithCapacity:[strokeColors count]];
for (int i = 0; i < [strokeColors count]; i++)
{
GMSStrokeStyle *stroke;

     if (i == 0) {
      stroke = [GMSStrokeStyle solidColor:strokeColors[i]];
    } else {
      stroke = [GMSStrokeStyle gradientFromColor:strokeColors[i-1] toColor:strokeColors[i]];
    }

     [spans addObject:[GMSStyleSpan spanWithStyle:stroke]];

}

\_strokeColors = strokeColors;
\_polyline.spans = spans;
}

-(void)setStrokeWidth:(double)strokeWidth
{
\_strokeWidth = strokeWidth;
\_polyline.strokeWidth = strokeWidth;
}

-(void)setFillColor:(UIColor \*)fillColor
{
\_fillColor = fillColor;
\_polyline.spans = @[[GMSStyleSpan spanWithColor:fillColor]];
}

- (void)setLineDashPattern:(NSArray<NSNumber _> _)lineDashPattern {
  \_lineDashPattern = lineDashPattern;
  [self configureStyleSpansIfNeeded];
  }

-(void)setGeodesic:(BOOL)geodesic
{
\_geodesic = geodesic;
\_polyline.geodesic = geodesic;
}

-(void)setTitle:(NSString \*)title
{
\_title = title;
\_polyline.title = \_title;
}

-(void) setZIndex:(int)zIndex
{
\_zIndex = zIndex;
\_polyline.zIndex = zIndex;
}

-(void)setTappable:(BOOL)tappable
{
\_tappable = tappable;
\_polyline.tappable = tappable;
}

- (void)setOnPress:(RCTBubblingEventBlock)onPress {
  \_polyline.onPress = onPress;
  }

- (void)configureStyleSpansIfNeeded {
  if (!\_strokeColor || !\_lineDashPattern || !\_polyline.path) {
  return;
  }

  BOOL isLine = YES;
  NSMutableArray \*styles = [[NSMutableArray alloc] init];
  for (NSInteger i = 0; i < _lineDashPattern.count; i++) {
    if (isLine) {
      [styles addObject:[GMSStrokeStyle solidColor:_strokeColor]];
  } else {
  [styles addObject:[GMSStrokeStyle solidColor:[UIColor clearColor]]];
  }
  isLine = !isLine;
  }

  \_polyline.spans = GMSStyleSpans(\_polyline.path, styles, \_lineDashPattern, kGMSLengthRhumb);
  }

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapPolylineManager.h">
//
//  AIRGoogleMapPolylineManager.h
//
//  Created by Nick Italiano on 10/22/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <React/RCTViewManager.h>

@interface AIRGoogleMapPolylineManager : RCTViewManager

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapPolylineManager.m">
//
//  AIRGoogleMapPolylineManager.m
//
//  Created by Nick Italiano on 10/22/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapPolylineManager.h"

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "RCTConvert+AirMap.h"
#import "AIRGoogleMapPolyline.h"

@interface AIRGoogleMapPolylineManager()

@end

@implementation AIRGoogleMapPolylineManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapPolyline *polyline = [AIRGoogleMapPolyline new];
  polyline.bridge = self.bridge;
  return polyline;
  }

RCT_EXPORT_VIEW_PROPERTY(coordinates, AIRMapCoordinateArray)
RCT_EXPORT_VIEW_PROPERTY(fillColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeColors, UIColorArray)
RCT_EXPORT_VIEW_PROPERTY(strokeWidth, double)
RCT_EXPORT_VIEW_PROPERTY(lineDashPattern, NSArray)
RCT_EXPORT_VIEW_PROPERTY(geodesic, BOOL)
RCT_EXPORT_VIEW_PROPERTY(zIndex, int)
RCT_EXPORT_VIEW_PROPERTY(tappable, BOOL)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapUrlTile.h">
//
//  AIRGoogleMapURLTile.h
//  Created by Nick Italiano on 11/5/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <Foundation/Foundation.h>
#import <GoogleMaps/GoogleMaps.h>

@interface AIRGoogleMapUrlTile : UIView

@property (nonatomic, strong) GMSURLTileLayer *tileLayer;
@property (nonatomic, assign) NSString *urlTemplate;
@property (nonatomic, assign) int zIndex;
@property NSInteger *maximumZ;
@property NSInteger *minimumZ;
@property BOOL flipY;

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapUrlTile.m">
//
//  AIRGoogleMapURLTile.m
//  Created by Nick Italiano on 11/5/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapUrlTile.h"

@implementation AIRGoogleMapUrlTile

- (void)setZIndex:(int)zIndex
  {
  \_zIndex = zIndex;
  \_tileLayer.zIndex = zIndex;
  }

- (void)setUrlTemplate:(NSString _)urlTemplate
  {
  \_urlTemplate = urlTemplate;
  \_tileLayer = [GMSURLTileLayer tileLayerWithURLConstructor:[self _getTileURLConstructor]];
  \_tileLayer.tileSize = [[UIScreen mainScreen] scale] _ 256;
  }

- (GMSTileURLConstructor)\_getTileURLConstructor
  {
  NSString *urlTemplate = self.urlTemplate;
  NSInteger *maximumZ = self.maximumZ;
  NSInteger _minimumZ = self.minimumZ;
  GMSTileURLConstructor urls = ^NSURL_ \_Nullable (NSUInteger x, NSUInteger y, NSUInteger zoom) {

      if (self.flipY == YES) {
        y = (1 << zoom) - y - 1;
      }

      NSString *url = urlTemplate;
      url = [url stringByReplacingOccurrencesOfString:@"{x}" withString:[NSString stringWithFormat: @"%ld", (long)x]];
      url = [url stringByReplacingOccurrencesOfString:@"{y}" withString:[NSString stringWithFormat: @"%ld", (long)y]];
      url = [url stringByReplacingOccurrencesOfString:@"{z}" withString:[NSString stringWithFormat: @"%ld", (long)zoom]];

  if(maximumZ && (long)zoom > (long)maximumZ) {
  return nil;
  }

      if(minimumZ && (long)zoom < (long)minimumZ) {
        return nil;
      }

      return [NSURL URLWithString:url];

  };
  return urls;
  }

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapUrlTileManager.h">
//
//  AIRGoogleMapURLTileManager.h
//  Created by Nick Italiano on 11/5/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <Foundation/Foundation.h>
#import <React/RCTViewManager.h>

@interface AIRGoogleMapUrlTileManager : RCTViewManager
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapURLTileManager.m">
//
//  AIRGoogleMapURLTileManager.m
//  Created by Nick Italiano on 11/5/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapUrlTileManager.h"
#import "AIRGoogleMapUrlTile.h"

@interface AIRGoogleMapUrlTileManager()

@end

@implementation AIRGoogleMapUrlTileManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapUrlTile *tileLayer = [AIRGoogleMapUrlTile new];
  return tileLayer;
  }

RCT_EXPORT_VIEW_PROPERTY(urlTemplate, NSString)
RCT_EXPORT_VIEW_PROPERTY(zIndex, int)
RCT_EXPORT_VIEW_PROPERTY(maximumZ, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(minimumZ, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(flipY, BOOL)

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapWMSTile.h">
//
//  AIRGoogleMapWMSTile.h
//  AirMaps
//
//  Created by nizam on 10/28/18.
//  Copyright  2018. All rights reserved.
//

#ifdef HAVE_GOOGLE_MAPS

#import <Foundation/Foundation.h>
#import <GoogleMaps/GoogleMaps.h>

@interface WMSTileOverlay : GMSSyncTileLayer
@property (nonatomic) double MapX,MapY,FULL;
@property (nonatomic, strong) NSString \*template;
@property (nonatomic, assign) NSInteger maximumZ;
@property (nonatomic, assign) NSInteger minimumZ;
@end

@interface AIRGoogleMapWMSTile : UIView
@property (nonatomic, strong) WMSTileOverlay *tileLayer;
@property (nonatomic, assign) NSString *urlTemplate;
@property (nonatomic, assign) int zIndex;
@property (nonatomic, assign) NSInteger maximumZ;
@property (nonatomic, assign) NSInteger minimumZ;
@property (nonatomic, assign) NSInteger tileSize;
@property (nonatomic, assign) float opacity;
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapWMSTile.m">
//
//  AIRGoogleMapWMSTile.m
//  AirMaps
//
//  Created by nizam on 10/28/18.
//  Copyright  2018. All rights reserved.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapWMSTile.h"

@implementation AIRGoogleMapWMSTile

-(id) init
{
self = [super init];
\_opacity = 1;
return self ;
}

- (void)setZIndex:(int)zIndex
  {
  \_zIndex = zIndex;
  \_tileLayer.zIndex = zIndex;
  }
- (void)setTileSize:(NSInteger)tileSize
  {
  \_tileSize = tileSize;
  if(self.tileLayer) {
  self.tileLayer.tileSize = tileSize;
  [self.tileLayer clearTileCache];
  }
  }
- (void)setMinimumZ:(NSInteger)minimumZ
  {
  \_minimumZ = minimumZ;
  if(self.tileLayer && \_minimumZ) {
  [self.tileLayer setMinimumZ: _minimumZ ];
  [self.tileLayer clearTileCache];
  }
  }

- (void)setMaximumZ:(NSInteger)maximumZ
  {
  \_maximumZ = maximumZ;
  if(self.tileLayer && maximumZ) {
  [self.tileLayer setMaximumZ: _maximumZ ];
  [self.tileLayer clearTileCache];
  }
  }
- (void)setOpacity:(float)opacity
  {
  \_opacity = opacity;
  if(self.tileLayer ) {
  [self.tileLayer setOpacity:opacity];
  [self.tileLayer clearTileCache];
  }
  }

- (void)setUrlTemplate:(NSString *)urlTemplate
  {
  \_urlTemplate = urlTemplate;
  WMSTileOverlay *tile = [[WMSTileOverlay alloc] init];
  [tile setTemplate:urlTemplate];
  [tile setMaximumZ: _maximumZ];
  [tile setMinimumZ: _minimumZ];
  [tile setOpacity: _opacity];
  [tile setTileSize: _tileSize];
  [tile setZIndex: _zIndex];
  \_tileLayer = tile;
  }
  @end

@implementation WMSTileOverlay
-(id) init
{
self = [super init];
\_MapX = -20037508.34789244;
\_MapY = 20037508.34789244;
\_FULL = 20037508.34789244 \* 2;
return self ;
}

-(NSArray *)getBoundBox:(NSInteger)x yAxis:(NSInteger)y zoom:(NSInteger)zoom
{
double tile = \_FULL / pow(2.0, (double)zoom);
NSArray *result =[[NSArray alloc] initWithObjects:
[NSNumber numberWithDouble:_MapX + (double)x * tile ],
[NSNumber numberWithDouble:_MapY - (double)(y+1) * tile ],
[NSNumber numberWithDouble:_MapX + (double)(x+1) * tile ],
[NSNumber numberWithDouble:_MapY - (double)y * tile ],
nil];

    return result;

}

- (UIImage *)tileForX:(NSUInteger)x y:(NSUInteger)y zoom:(NSUInteger)zoom
  {
  NSInteger maximumZ = self.maximumZ;
  NSInteger minimumZ = self.minimumZ;
  if(maximumZ && (long)zoom > (long)maximumZ) {
  return nil;
  }
  if(minimumZ && (long)zoom < (long)minimumZ) {
  return nil;
  }
  NSArray *bb = [self getBoundBox:x yAxis:y zoom:zoom];
  NSMutableString *url = [self.template mutableCopy];
  [url replaceOccurrencesOfString: @"{minX}" withString:[NSString stringWithFormat:@"%@", bb[0]] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{minY}" withString:[NSString stringWithFormat:@"%@", bb[1]] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{maxX}" withString:[NSString stringWithFormat:@"%@", bb[2]] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{maxY}" withString:[NSString stringWithFormat:@"%@", bb[3]] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{width}" withString:[NSString stringWithFormat:@"%d", (int)self.tileSize] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{height}" withString:[NSString stringWithFormat:@"%d", (int)self.tileSize] options:0 range:NSMakeRange(0, url.length)];
  NSURL *uri = [NSURL URLWithString:url];
  NSData *data = [NSData dataWithContentsOfURL:uri];
  UIImage *img = [[UIImage alloc] initWithData:data];
  return img;
  }

@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapWMSTileManager.h">
//
//  AIRGoogleMapWMSTileManager.h
//  AirMaps
//
//  Created by nizam on 10/28/18.
//  Copyright  2018. All rights reserved.
//

#ifdef HAVE_GOOGLE_MAPS

#import <Foundation/Foundation.h>
#import <React/RCTViewManager.h>

@interface AIRGoogleMapWMSTileManager : RCTViewManager
@end

#endif
</file>

<file path="ios/AirGoogleMaps/AIRGoogleMapWMSTileManager.m">
//
//  AIRGoogleMapWMSTileManager.m
//  AirMaps
//
//  Created by nizam on 10/28/18.
//  Copyright  2018. All rights reserved.
//

#ifdef HAVE_GOOGLE_MAPS

#import "AIRGoogleMapWMSTileManager.h"
#import "AIRGoogleMapWMSTile.h"

@interface AIRGoogleMapWMSTileManager()

@end

@implementation AIRGoogleMapWMSTileManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRGoogleMapWMSTile *tileLayer = [AIRGoogleMapWMSTile new];
  return tileLayer;
  }

RCT_EXPORT_VIEW_PROPERTY(urlTemplate, NSString)
RCT_EXPORT_VIEW_PROPERTY(zIndex, int)
RCT_EXPORT_VIEW_PROPERTY(maximumZ, int)
RCT_EXPORT_VIEW_PROPERTY(minimumZ, int)
RCT_EXPORT_VIEW_PROPERTY(tileSize, int)
RCT_EXPORT_VIEW_PROPERTY(opacity, float)

@end

#endif
</file>

<file path="ios/AirGoogleMaps/RCTConvert+GMSMapViewType.h">
//
//  RCTConvert+GMSMapViewType.h
//
//  Created by Nick Italiano on 10/23/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import <Foundation/Foundation.h>
#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTConvert.h>

@interface RCTConvert (GMSMapViewType)

- (GMSCameraPosition*)GMSCameraPositionWithDefaults:(id)json existingCamera:(GMSCameraPosition*)existingCamera;
  @end

#endif
</file>

<file path="ios/AirGoogleMaps/RCTConvert+GMSMapViewType.m">
//
//  RCTConvert+GMSMapViewType.m
//
//  Created by Nick Italiano on 10/23/16.
//

#ifdef HAVE_GOOGLE_MAPS

#import "RCTConvert+GMSMapViewType.h"
#import <GoogleMaps/GoogleMaps.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>

@implementation RCTConvert (GMSMapViewType)
RCT_ENUM_CONVERTER(GMSMapViewType,
(
@{
@"standard": @(kGMSTypeNormal),
@"satellite": @(kGMSTypeSatellite),
@"hybrid": @(kGMSTypeHybrid),
@"terrain": @(kGMSTypeTerrain),
@"none": @(kGMSTypeNone)
}
), kGMSTypeTerrain, intValue)

- (GMSCameraPosition\*)GMSCameraPosition:(id)json
  {
  json = [self NSDictionary:json];
  return [RCTConvert GMSCameraPositionWithDefaults:json existingCamera:nil];
  }

- (GMSCameraPosition*)GMSCameraPositionWithDefaults:(id)json existingCamera:(GMSCameraPosition*)existingCamera
  {
  CLLocationDegrees latitude = 0;
  CLLocationDegrees longitude = 0;
  double viewingAngle = 0;
  double zoom = 0;
  double bearing = 0;

      if (existingCamera != nil) {
          viewingAngle = existingCamera.viewingAngle;
          latitude = existingCamera.target.latitude;
          longitude = existingCamera.target.longitude;
          zoom = existingCamera.zoom;
          bearing = existingCamera.bearing;
      }

      if (json[@"center"]) {
          CLLocationCoordinate2D target = [self CLLocationCoordinate2D:json[@"center"]];
          latitude = target.latitude;
          longitude = target.longitude;
      }

      if (json[@"pitch"]) {
          viewingAngle = [self double:json[@"pitch"]];
      }

      // zoomAtCoordinate:forMeters:perPoints is offered by the SDK, which would allow
      // us to support the "altitude" property of the camera as an alternative to "zoom".
      // However, I am not clear on what the "perPoints" argument does...
      if (json[@"zoom"]) {
          zoom = [self double:json[@"zoom"]];
      }

      if (json[@"heading"]) {
          bearing = [self double:json[@"heading"]];
      }

      return [GMSCameraPosition cameraWithLatitude:latitude
                                         longitude:longitude
                                              zoom:zoom
                                           bearing:bearing
                                      viewingAngle:viewingAngle];

  }

@end

#endif
</file>

<file path="ios/AirMaps/Callout/SMCalloutView.h">
#import <UIKit/UIKit.h>
#import <QuartzCore/QuartzCore.h>

/\*

## SMCalloutView

Created by Nick Farina (nfarina@gmail.com)
Version 2.1.2

\*/

/// options for which directions the callout is allowed to "point" in.
typedef NS_OPTIONS(NSUInteger, SMCalloutArrowDirection) {
SMCalloutArrowDirectionUp = 1 << 0,
SMCalloutArrowDirectionDown = 1 << 1,
SMCalloutArrowDirectionAny = SMCalloutArrowDirectionUp | SMCalloutArrowDirectionDown
};

/// options for the callout present/dismiss animation
typedef NS_ENUM(NSInteger, SMCalloutAnimation) {
/// the "bounce" animation we all know and love from @c UIAlertView
SMCalloutAnimationBounce,
/// a simple fade in or out
SMCalloutAnimationFade,
/// grow or shrink linearly, like in the iPad Calendar app
SMCalloutAnimationStretch
};

NS_ASSUME_NONNULL_BEGIN

/// when delaying our popup in order to scroll content into view, you can use this amount to match the
/// animation duration of UIScrollView when using @c -setContentOffset:animated.
extern NSTimeInterval const kSMCalloutViewRepositionDelayForUIScrollView;

@protocol SMCalloutViewDelegate;
@class SMCalloutBackgroundView;

//
// Callout view.
//

#if \_\_IPHONE_OS_VERSION_MAX_ALLOWED < 100000
@interface SMCalloutView : UIView
#else
@interface SMCalloutView : UIView <CAAnimationDelegate>
#endif

@property (nonatomic, weak, nullable) id<SMCalloutViewDelegate> delegate;
/// title/titleView relationship mimics UINavigationBar.
@property (nonatomic, copy, nullable) NSString *title;
@property (nonatomic, copy, nullable) NSString *subtitle;

/// Left accessory view for the call out
@property (nonatomic, strong, nullable) UIView *leftAccessoryView;
/// Right accessoty view for the call out
@property (nonatomic, strong, nullable) UIView *rightAccessoryView;
/// Default @c SMCalloutArrowDirectionDown
@property (nonatomic, assign) SMCalloutArrowDirection permittedArrowDirection;
/// The current arrow direction
@property (nonatomic, readonly) SMCalloutArrowDirection currentArrowDirection;
/// if the @c UIView you're constraining to has portions that are overlapped by nav bar, tab bar, etc. you'll need to tell us those insets.
@property (nonatomic, assign) UIEdgeInsets constrainedInsets;
/// default is @c SMCalloutMaskedBackgroundView, or @c SMCalloutDrawnBackgroundView when using @c SMClassicCalloutView
@property (nonatomic, strong) SMCalloutBackgroundView \*backgroundView;

/\*\*
@brief Custom title view.

@disucssion Keep in mind that @c SMCalloutView calls @c -sizeThatFits on titleView/subtitleView if defined, so your view
may be resized as a result of that (especially if you're using @c UILabel/UITextField). You may want to subclass and override @c -sizeThatFits, or just wrap your view in a "generic" @c UIView if you do not want it to be auto-sized.

@warning If this is set, the respective @c title property will be ignored.
*/
@property (nonatomic, strong, nullable) UIView *titleView;

/\*\*
@brief Custom subtitle view.

@discussion Keep in mind that @c SMCalloutView calls @c -sizeThatFits on subtitleView if defined, so your view
may be resized as a result of that (especially if you're using @c UILabel/UITextField). You may want to subclass and override @c -sizeThatFits, or just wrap your view in a "generic" @c UIView if you do not want it to be auto-sized.

@warning If this is set, the respective @c subtitle property will be ignored.
*/
@property (nonatomic, strong, nullable) UIView *subtitleView;

/// Custom "content" view that can be any width/height. If this is set, title/subtitle/titleView/subtitleView are all ignored.
@property (nonatomic, retain, nullable) UIView \*contentView;

/// Custom content view margin
@property (nonatomic, assign) UIEdgeInsets contentViewInset;

/// calloutOffset is the offset in screen points from the top-middle of the target view, where the anchor of the callout should be shown.
@property (nonatomic, assign) CGPoint calloutOffset;

/// default SMCalloutAnimationBounce, SMCalloutAnimationFade respectively
@property (nonatomic, assign) SMCalloutAnimation presentAnimation, dismissAnimation;

/// Returns a new instance of SMCalloutView if running on iOS 7 or better, otherwise a new instance of SMClassicCalloutView if available.

- (SMCalloutView \*)platformCalloutView;

/\*\*
@brief Presents a callout view by adding it to "inView" and pointing at the given rect of inView's bounds.

@discussion Constrains the callout to the bounds of the given view. Optionally scrolls the given rect into view (plus margins)
if @c -delegate is set and responds to @c -delayForRepositionWithSize.

@param rect @c CGRect to present the view from
@param view view to 'constrain' the @c constrainedView to
@param constrainedView @c UIView to be constrainted in @c view
@param animated @c BOOL if presentation should be animated
\*/

- (void)presentCalloutFromRect:(CGRect)rect inView:(UIView _)view constrainedToView:(UIView _)constrainedView animated:(BOOL)animated;

/\*\*
@brief Present a callout layer in the `layer` and pointing at the given rect of the `layer` bounds

@discussion Same as the view-based presentation, but inserts the callout into a CALayer hierarchy instead.
@note Be aware that you'll have to direct your own touches to any accessory views, since CALayer doesn't relay touch events.

@param rect @c CGRect to present the view from
@param layer layer to 'constrain' the @c constrainedLayer to
@param constrainedLayer @c CALayer to be constrained in @c layer
@param animated @c BOOL if presentation should be animated
\*/

- (void)presentCalloutFromRect:(CGRect)rect inLayer:(CALayer _)layer constrainedToLayer:(CALayer _)constrainedLayer animated:(BOOL)animated;

/\*\*
Dismiss the callout view

@param animated @c BOOL if dismissal should be animated
\*/

- (void)dismissCalloutAnimated:(BOOL)animated;

/// For subclassers. You can override this method to provide your own custom animation for presenting/dismissing the callout.

- (CAAnimation \*)animationWithType:(SMCalloutAnimation)type presenting:(BOOL)presenting;

@end

//
// Background view - default draws the iOS 7 system background style (translucent white with rounded arrow).
//

/// Abstract base class
@interface SMCalloutBackgroundView : UIView
/// indicates where the tip of the arrow should be drawn, as a pixel offset
@property (nonatomic, assign) CGPoint arrowPoint;
/// will be set by the callout when the callout is in a highlighted state
@property (nonatomic, assign) BOOL highlighted;
/// returns an optional layer whose contents should mask the callout view's contents (not honored by @c SMClassicCalloutView )
@property (nonatomic, assign) CALayer \*contentMask;
/// height of the callout "arrow"
@property (nonatomic, assign) CGFloat anchorHeight;
/// the smallest possible distance from the edge of our control to the "tip" of the anchor, from either left or right
@property (nonatomic, assign) CGFloat anchorMargin;
@end

/// Default for iOS 7, this reproduces the "masked" behavior of the iOS 7-style callout view.
/// Accessories are masked by the shape of the callout (including the arrow itself).
@interface SMCalloutMaskedBackgroundView : SMCalloutBackgroundView
@end

//
// Delegate methods
//

@protocol SMCalloutViewDelegate <NSObject>
@optional

/// Controls whether the callout "highlights" when pressed. default YES. You must also respond to @c -calloutViewClicked below.
/// Not honored by @c SMClassicCalloutView.

- (BOOL)calloutViewShouldHighlight:(SMCalloutView \*)calloutView;

/// Called when the callout view is clicked. Not honored by @c SMClassicCalloutView.

- (void)calloutViewClicked:(SMCalloutView \*)calloutView;

/\*\*
Called when the callout view detects that it will be outside the constrained view when it appears,
or if the target rect was already outside the constrained view. You can implement this selector
to respond to this situation by repositioning your content first in order to make everything visible.
The @c CGSize passed is the calculated offset necessary to make everything visible (plus a nice margin).
It expects you to return the amount of time you need to reposition things so the popup can be delayed.
Typically you would return @c kSMCalloutViewRepositionDelayForUIScrollView if you're repositioning by calling @c [UIScrollView @c setContentOffset:animated:].

@param calloutView the @c SMCalloutView to reposition
@param offset calculated offset necessary to make everything visible
@returns @c NSTimeInterval to delay the repositioning
\*/

- (NSTimeInterval)calloutView:(SMCalloutView \*)calloutView delayForRepositionWithSize:(CGSize)offset;

/// Called before the callout view appears on screen, or before the appearance animation will start.

- (void)calloutViewWillAppear:(SMCalloutView \*)calloutView;

/// Called after the callout view appears on screen, or after the appearance animation is complete.

- (void)calloutViewDidAppear:(SMCalloutView \*)calloutView;

/// Called before the callout view is removed from the screen, or before the disappearance animation is complete.

- (void)calloutViewWillDisappear:(SMCalloutView \*)calloutView;

/// Called after the callout view is removed from the screen, or after the disappearance animation is complete.

- (void)calloutViewDidDisappear:(SMCalloutView \*)calloutView;

NS_ASSUME_NONNULL_END
@end
</file>

<file path="ios/AirMaps/Callout/SMCalloutView.m">
#import "SMCalloutView.h"

//
// UIView frame helpers - we do a lot of UIView frame fiddling in this class; these functions help keep things readable.
//

@interface UIView (SMFrameAdditions)
@property (nonatomic, assign) CGPoint frameOrigin;
@property (nonatomic, assign) CGSize frameSize;
@property (nonatomic, assign) CGFloat frameX, frameY, frameWidth, frameHeight; // normal rect properties
@property (nonatomic, assign) CGFloat frameLeft, frameTop, frameRight, frameBottom; // these will stretch/shrink the rect
@end

//
// Callout View.
//

#define CALLOUT_DEFAULT_CONTAINER_HEIGHT 44 // height of just the main portion without arrow
#define CALLOUT_SUB_DEFAULT_CONTAINER_HEIGHT 52 // height of just the main portion without arrow (when subtitle is present)
#define CALLOUT_MIN_WIDTH 61 // minimum width of system callout
#define TITLE_HMARGIN 12 // the title/subtitle view's normal horizontal margin from the edges of our callout view or from the accessories
#define TITLE_TOP 11 // the top of the title view when no subtitle is present
#define TITLE_SUB_TOP 4 // the top of the title view when a subtitle IS present
#define TITLE_HEIGHT 21 // title height, fixed
#define SUBTITLE_TOP 28 // the top of the subtitle, when present
#define SUBTITLE_HEIGHT 15 // subtitle height, fixed
#define BETWEEN_ACCESSORIES_MARGIN 7 // margin between accessories when no title/subtitle is present
#define TOP_ANCHOR_MARGIN 13 // all the above measurements assume a bottom anchor! if we're pointing "up" we'll need to add this top margin to everything.
#define COMFORTABLE_MARGIN 10 // when we try to reposition content to be visible, we'll consider this margin around your target rect

NSTimeInterval const kSMCalloutViewRepositionDelayForUIScrollView = 1.0/3.0;

@interface SMCalloutView ()
@property (nonatomic, strong) UIButton *containerView; // for masking and interaction
@property (nonatomic, strong) UILabel *titleLabel, \*subtitleLabel;
@property (nonatomic, assign) SMCalloutArrowDirection currentArrowDirection;
@property (nonatomic, assign) BOOL popupCancelled;
@end

@implementation SMCalloutView

- (SMCalloutView \*)platformCalloutView {

      // if you haven't compiled SMClassicCalloutView into your app, then we can't possibly create an instance of it!
      if (!NSClassFromString(@"SMClassicCalloutView"))
          return [SMCalloutView new];

      // ok we have both - so choose the best one based on current platform
      if (floor(NSFoundationVersionNumber) > NSFoundationVersionNumber_iOS_6_1)
          return [SMCalloutView new]; // iOS 7+
      else
          return [NSClassFromString(@"SMClassicCalloutView") new];

  }

* (id)initWithFrame:(CGRect)frame {
  if (self = [super initWithFrame:frame]) {
  self.permittedArrowDirection = SMCalloutArrowDirectionDown;
  self.presentAnimation = SMCalloutAnimationBounce;
  self.dismissAnimation = SMCalloutAnimationFade;
  self.backgroundColor = [UIColor clearColor];
  self.containerView = [UIButton new];
  self.containerView.isAccessibilityElement = NO;
  self.isAccessibilityElement = NO;
  self.contentViewInset = UIEdgeInsetsMake(12, 12, 12, 12);

          [self.containerView addTarget:self action:@selector(highlightIfNecessary) forControlEvents:UIControlEventTouchDown | UIControlEventTouchDragInside];
          [self.containerView addTarget:self action:@selector(unhighlightIfNecessary) forControlEvents:UIControlEventTouchDragOutside | UIControlEventTouchCancel | UIControlEventTouchUpOutside | UIControlEventTouchUpInside];
          [self.containerView addTarget:self action:@selector(calloutClicked) forControlEvents:UIControlEventTouchUpInside];
      }
      return self;

  }

* (BOOL)supportsHighlighting {
  if (![self.delegate respondsToSelector:@selector(calloutViewClicked:)])
  return NO;
  if ([self.delegate respondsToSelector:@selector(calloutViewShouldHighlight:)])
  return [self.delegate calloutViewShouldHighlight:self];
  return YES;
  }

* (void)highlightIfNecessary { if (self.supportsHighlighting) self.backgroundView.highlighted = YES; }
* (void)unhighlightIfNecessary { if (self.supportsHighlighting) self.backgroundView.highlighted = NO; }

* (void)calloutClicked {
  if ([self.delegate respondsToSelector:@selector(calloutViewClicked:)])
  [self.delegate calloutViewClicked:self];
  }

* (UIView \*)titleViewOrDefault {
  if (self.titleView)
  // if you have a custom title view defined, return that.
  return self.titleView;
  else {
  if (!self.titleLabel) {
  // create a default titleView
  self.titleLabel = [UILabel new];
  self.titleLabel.frameHeight = TITLE_HEIGHT;
  self.titleLabel.opaque = NO;
  self.titleLabel.backgroundColor = [UIColor clearColor];
  self.titleLabel.font = [UIFont systemFontOfSize:17];
  self.titleLabel.textColor = [UIColor blackColor];
  }
  return self.titleLabel;
  }
  }

* (UIView \*)subtitleViewOrDefault {
  if (self.subtitleView)
  // if you have a custom subtitle view defined, return that.
  return self.subtitleView;
  else {
  if (!self.subtitleLabel) {
  // create a default subtitleView
  self.subtitleLabel = [UILabel new];
  self.subtitleLabel.frameHeight = SUBTITLE_HEIGHT;
  self.subtitleLabel.opaque = NO;
  self.subtitleLabel.backgroundColor = [UIColor clearColor];
  self.subtitleLabel.font = [UIFont systemFontOfSize:12];
  self.subtitleLabel.textColor = [UIColor blackColor];
  }
  return self.subtitleLabel;
  }
  }

* (SMCalloutBackgroundView \*)backgroundView {
  // create our default background on first access only if it's nil, since you might have set your own background anyway.
  return \_backgroundView ? \_backgroundView : (\_backgroundView = [self defaultBackgroundView]);
  }

* (SMCalloutBackgroundView \*)defaultBackgroundView {
  return [SMCalloutMaskedBackgroundView new];
  }

* (void)rebuildSubviews {
  // remove and re-add our appropriate subviews in the appropriate order
  [self.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
  [self.containerView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
  [self setNeedsDisplay];

      [self addSubview:self.backgroundView];
      [self addSubview:self.containerView];

      if (self.contentView) {
          [self.containerView addSubview:self.contentView];
      }
      else {
          if (self.titleViewOrDefault) [self.containerView addSubview:self.titleViewOrDefault];
          if (self.subtitleViewOrDefault) [self.containerView addSubview:self.subtitleViewOrDefault];
      }
      if (self.leftAccessoryView) [self.containerView addSubview:self.leftAccessoryView];
      if (self.rightAccessoryView) [self.containerView addSubview:self.rightAccessoryView];

  }

// Accessory margins. Accessories are centered vertically when shorter
// than the callout, otherwise they grow from the upper corner.

- (CGFloat)leftAccessoryVerticalMargin {
  if (self.leftAccessoryView.frameHeight < self.calloutContainerHeight)
  return roundf((self.calloutContainerHeight - self.leftAccessoryView.frameHeight) / 2);
  else
  return 0;
  }

- (CGFloat)leftAccessoryHorizontalMargin {
  return fminf(self.leftAccessoryVerticalMargin, TITLE_HMARGIN);
  }

- (CGFloat)rightAccessoryVerticalMargin {
  if (self.rightAccessoryView.frameHeight < self.calloutContainerHeight)
  return roundf((self.calloutContainerHeight - self.rightAccessoryView.frameHeight) / 2);
  else
  return 0;
  }

- (CGFloat)rightAccessoryHorizontalMargin {
  return fminf(self.rightAccessoryVerticalMargin, TITLE_HMARGIN);
  }

- (CGFloat)innerContentMarginLeft {
  if (self.leftAccessoryView)
  return self.leftAccessoryHorizontalMargin + self.leftAccessoryView.frameWidth + TITLE_HMARGIN;
  else
  return self.contentViewInset.left;
  }

- (CGFloat)innerContentMarginRight {
  if (self.rightAccessoryView)
  return self.rightAccessoryHorizontalMargin + self.rightAccessoryView.frameWidth + TITLE_HMARGIN;
  else
  return self.contentViewInset.right;
  }

- (CGFloat)calloutHeight {
  return self.calloutContainerHeight + self.backgroundView.anchorHeight;
  }

- (CGFloat)calloutContainerHeight {
  if (self.contentView)
  return self.contentView.frameHeight + self.contentViewInset.bottom + self.contentViewInset.top;
  else if (self.subtitleView || self.subtitle.length > 0)
  return CALLOUT_SUB_DEFAULT_CONTAINER_HEIGHT;
  else
  return CALLOUT_DEFAULT_CONTAINER_HEIGHT;
  }

- (CGSize)sizeThatFits:(CGSize)size {

      // calculate how much non-negotiable space we need to reserve for margin and accessories
      CGFloat margin = self.innerContentMarginLeft + self.innerContentMarginRight;

      // how much room is left for text?
      CGFloat availableWidthForText = size.width - margin - 1;

      // no room for text? then we'll have to squeeze into the given size somehow.
      if (availableWidthForText < 0)
          availableWidthForText = 0;

      CGSize preferredTitleSize = [self.titleViewOrDefault sizeThatFits:CGSizeMake(availableWidthForText, TITLE_HEIGHT)];
      CGSize preferredSubtitleSize = [self.subtitleViewOrDefault sizeThatFits:CGSizeMake(availableWidthForText, SUBTITLE_HEIGHT)];

      // total width we'd like
      CGFloat preferredWidth;

      if (self.contentView) {

          // if we have a content view, then take our preferred size directly from that
          preferredWidth = self.contentView.frameWidth + margin;
      }
      else if (preferredTitleSize.width >= 0.000001 || preferredSubtitleSize.width >= 0.000001) {

          // if we have a title or subtitle, then our assumed margins are valid, and we can apply them
          preferredWidth = fmaxf(preferredTitleSize.width, preferredSubtitleSize.width) + margin;
      }
      else {
          // ok we have no title or subtitle to speak of. In this case, the system callout would actually not display
          // at all! But we can handle it.
          preferredWidth = self.leftAccessoryView.frameWidth + self.rightAccessoryView.frameWidth + self.leftAccessoryHorizontalMargin + self.rightAccessoryHorizontalMargin;

          if (self.leftAccessoryView && self.rightAccessoryView)
              preferredWidth += BETWEEN_ACCESSORIES_MARGIN;
      }

      // ensure we're big enough to fit our graphics!
      preferredWidth = fmaxf(preferredWidth, CALLOUT_MIN_WIDTH);

      // ask to be smaller if we have space, otherwise we'll fit into what we have by truncating the title/subtitle.
      return CGSizeMake(fminf(preferredWidth, size.width), self.calloutHeight);

  }

- (CGSize)offsetToContainRect:(CGRect)innerRect inRect:(CGRect)outerRect {
  CGFloat nudgeRight = fmaxf(0, CGRectGetMinX(outerRect) - CGRectGetMinX(innerRect));
  CGFloat nudgeLeft = fminf(0, CGRectGetMaxX(outerRect) - CGRectGetMaxX(innerRect));
  CGFloat nudgeTop = fmaxf(0, CGRectGetMinY(outerRect) - CGRectGetMinY(innerRect));
  CGFloat nudgeBottom = fminf(0, CGRectGetMaxY(outerRect) - CGRectGetMaxY(innerRect));
  return CGSizeMake(nudgeLeft ? nudgeLeft : nudgeRight, nudgeTop ? nudgeTop : nudgeBottom);
  }

- (void)presentCalloutFromRect:(CGRect)rect inView:(UIView _)view constrainedToView:(UIView _)constrainedView animated:(BOOL)animated {
  [self presentCalloutFromRect:rect inLayer:view.layer ofView:view constrainedToLayer:constrainedView.layer animated:animated];
  }

- (void)presentCalloutFromRect:(CGRect)rect inLayer:(CALayer _)layer constrainedToLayer:(CALayer _)constrainedLayer animated:(BOOL)animated {
  [self presentCalloutFromRect:rect inLayer:layer ofView:nil constrainedToLayer:constrainedLayer animated:animated];
  }

// this private method handles both CALayer and UIView parents depending on what's passed.

- (void)presentCalloutFromRect:(CGRect)rect inLayer:(CALayer _)layer ofView:(UIView _)view constrainedToLayer:(CALayer \*)constrainedLayer animated:(BOOL)animated {

      // Sanity check: dismiss this callout immediately if it's displayed somewhere
      if (self.layer.superlayer) [self dismissCalloutAnimated:NO];

      // cancel any presenting animation that may be in progress
      [self.layer removeAnimationForKey:@"present"];

      // figure out the constrained view's rect in our popup view's coordinate system
      CGRect constrainedRect = [constrainedLayer convertRect:constrainedLayer.bounds toLayer:layer];

      // apply our edge constraints
      constrainedRect = UIEdgeInsetsInsetRect(constrainedRect, self.constrainedInsets);

      constrainedRect = CGRectInset(constrainedRect, COMFORTABLE_MARGIN, COMFORTABLE_MARGIN);

      // form our subviews based on our content set so far
      [self rebuildSubviews];

      // apply title/subtitle (if present
      self.titleLabel.text = self.title;
      self.subtitleLabel.text = self.subtitle;

      // size the callout to fit the width constraint as best as possible
      self.frameSize = [self sizeThatFits:CGSizeMake(constrainedRect.size.width, self.calloutHeight)];

      // how much room do we have in the constraint box, both above and below our target rect?
      CGFloat topSpace = CGRectGetMinY(rect) - CGRectGetMinY(constrainedRect);
      CGFloat bottomSpace = CGRectGetMaxY(constrainedRect) - CGRectGetMaxY(rect);

      // we prefer to point our arrow down.
      SMCalloutArrowDirection bestDirection = SMCalloutArrowDirectionDown;

      // we'll point it up though if that's the only option you gave us.
      if (self.permittedArrowDirection == SMCalloutArrowDirectionUp)
          bestDirection = SMCalloutArrowDirectionUp;

      // or, if we don't have enough space on the top and have more space on the bottom, and you
      // gave us a choice, then pointing up is the better option.
      if (self.permittedArrowDirection == SMCalloutArrowDirectionAny && topSpace < self.calloutHeight && bottomSpace > topSpace)
          bestDirection = SMCalloutArrowDirectionUp;

      self.currentArrowDirection = bestDirection;

      // we want to point directly at the horizontal center of the given rect. calculate our "anchor point" in terms of our
      // target view's coordinate system. make sure to offset the anchor point as requested if necessary.
      CGFloat anchorX = self.calloutOffset.x + CGRectGetMidX(rect);
      CGFloat anchorY = self.calloutOffset.y + (bestDirection == SMCalloutArrowDirectionDown ? CGRectGetMinY(rect) : CGRectGetMaxY(rect));

      // we prefer to sit centered directly above our anchor
      CGFloat calloutX = roundf(anchorX - self.frameWidth / 2);

      // but not if it's going to get too close to the edge of our constraints
      if (calloutX < constrainedRect.origin.x)
          calloutX = constrainedRect.origin.x;

      if (calloutX > constrainedRect.origin.x+constrainedRect.size.width-self.frameWidth)
          calloutX = constrainedRect.origin.x+constrainedRect.size.width-self.frameWidth;

      // what's the farthest to the left and right that we could point to, given our background image constraints?
      CGFloat minPointX = calloutX + self.backgroundView.anchorMargin;
      CGFloat maxPointX = calloutX + self.frameWidth - self.backgroundView.anchorMargin;

      // we may need to scoot over to the left or right to point at the correct spot
      CGFloat adjustX = 0;
      if (anchorX < minPointX) adjustX = anchorX - minPointX;
      if (anchorX > maxPointX) adjustX = anchorX - maxPointX;

      // add the callout to the given layer (or view if possible, to receive touch events)
      if (view)
          [view addSubview:self];
      else
          [layer addSublayer:self.layer];

      CGPoint calloutOrigin = {
              .x = calloutX + adjustX,
              .y = bestDirection == SMCalloutArrowDirectionDown ? (anchorY - self.calloutHeight) : anchorY
      };

      self.frameOrigin = calloutOrigin;

      // now set the *actual* anchor point for our layer so that our "popup" animation starts from this point.
      CGPoint anchorPoint = [layer convertPoint:CGPointMake(anchorX, anchorY) toLayer:self.layer];

      // pass on the anchor point to our background view so it knows where to draw the arrow
      self.backgroundView.arrowPoint = anchorPoint;

      // adjust it to unit coordinates for the actual layer.anchorPoint property
      anchorPoint.x /= self.frameWidth;
      anchorPoint.y /= self.frameHeight;
      self.layer.anchorPoint = anchorPoint;

      // setting the anchor point moves the view a bit, so we need to reset
      self.frameOrigin = calloutOrigin;

      // make sure our frame is not on half-pixels or else we may be blurry!
      CGFloat scale = [UIScreen mainScreen].scale;
      self.frameX = floorf(self.frameX*scale)/scale;
      self.frameY = floorf(self.frameY*scale)/scale;

      // layout now so we can immediately start animating to the final position if needed
      [self setNeedsLayout];
      [self layoutIfNeeded];

      // if we're outside the bounds of our constraint rect, we'll give our delegate an opportunity to shift us into position.
      // consider both our size and the size of our target rect (which we'll assume to be the size of the content you want to scroll into view.
      CGRect contentRect = CGRectUnion(self.frame, rect);
      CGSize offset = [self offsetToContainRect:contentRect inRect:constrainedRect];

      NSTimeInterval delay = 0;
      self.popupCancelled = NO; // reset this before calling our delegate below

      if ([self.delegate respondsToSelector:@selector(calloutView:delayForRepositionWithSize:)] && !CGSizeEqualToSize(offset, CGSizeZero))
          delay = [self.delegate calloutView:(id)self delayForRepositionWithSize:offset];

      // there's a chance that user code in the delegate method may have called -dismissCalloutAnimated to cancel things; if that
      // happened then we need to bail!
      if (self.popupCancelled) return;

      // now we want to mask our contents to our background view (if requested) to match the iOS 7 style
      self.containerView.layer.mask = self.backgroundView.contentMask;

      // if we need to delay, we don't want to be visible while we're delaying, so hide us in preparation for our popup
      self.hidden = YES;

      // create the appropriate animation, even if we're not animated
      CAAnimation *animation = [self animationWithType:self.presentAnimation presenting:YES];

      // nuke the duration if no animation requested - we'll still need to "run" the animation to get delays and callbacks
      if (!animated)
          animation.duration = 0.0000001; // can't be zero or the animation won't "run"

      animation.beginTime = CACurrentMediaTime() + delay;
      animation.delegate = self;

      [self.layer addAnimation:animation forKey:@"present"];

  }

- (void)animationDidStart:(CAAnimation \*)anim {
  BOOL presenting = [[anim valueForKey:@"presenting"] boolValue];

      if (presenting) {
          if ([_delegate respondsToSelector:@selector(calloutViewWillAppear:)])
              [_delegate calloutViewWillAppear:(id)self];

          // ok, animation is on, let's make ourselves visible!
          self.hidden = NO;
      }
      else if (!presenting) {
          if ([_delegate respondsToSelector:@selector(calloutViewWillDisappear:)])
              [_delegate calloutViewWillDisappear:(id)self];
      }

  }

- (void)animationDidStop:(CAAnimation \*)anim finished:(BOOL)finished {
  BOOL presenting = [[anim valueForKey:@"presenting"] boolValue];

      if (presenting && finished) {
          if ([_delegate respondsToSelector:@selector(calloutViewDidAppear:)])
              [_delegate calloutViewDidAppear:(id)self];
      }
      else if (!presenting && finished) {

          [self removeFromParent];
          [self.layer removeAnimationForKey:@"dismiss"];

          if ([_delegate respondsToSelector:@selector(calloutViewDidDisappear:)])
              [_delegate calloutViewDidDisappear:(id)self];
      }

  }

- (void)dismissCalloutAnimated:(BOOL)animated {

      // cancel all animations that may be in progress
      [self.layer removeAnimationForKey:@"present"];
      [self.layer removeAnimationForKey:@"dismiss"];

      self.popupCancelled = YES;

      if (animated) {
          CAAnimation *animation = [self animationWithType:self.dismissAnimation presenting:NO];
          animation.delegate = self;
          [self.layer addAnimation:animation forKey:@"dismiss"];
      }
      else {
          [self removeFromParent];
      }

  }

- (void)removeFromParent {
  if (self.superview)
  [self removeFromSuperview];
  else {
  // removing a layer from a superlayer causes an implicit fade-out animation that we wish to disable.
  [CATransaction begin];
  [CATransaction setDisableActions:YES];
  [self.layer removeFromSuperlayer];
  [CATransaction commit];
  }
  }

- (CAAnimation *)animationWithType:(SMCalloutAnimation)type presenting:(BOOL)presenting {
  CAAnimation *animation = nil;

      if (type == SMCalloutAnimationBounce) {

          CABasicAnimation *fade = [CABasicAnimation animationWithKeyPath:@"opacity"];
          fade.duration = 0.23;
          fade.fromValue = presenting ? @0.0 : @1.0;
          fade.toValue = presenting ? @1.0 : @0.0;
          fade.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];

          CABasicAnimation *bounce = [CABasicAnimation animationWithKeyPath:@"transform.scale"];
          bounce.duration = 0.23;
          bounce.fromValue = presenting ? @0.7 : @1.0;
          bounce.toValue = presenting ? @1.0 : @0.7;
          bounce.timingFunction = [CAMediaTimingFunction functionWithControlPoints:0.59367:0.12066:0.18878:1.5814];

          CAAnimationGroup *group = [CAAnimationGroup animation];
          group.animations = @[fade, bounce];
          group.duration = 0.23;

          animation = group;
      }
      else if (type == SMCalloutAnimationFade) {
          CABasicAnimation *fade = [CABasicAnimation animationWithKeyPath:@"opacity"];
          fade.duration = 1.0/3.0;
          fade.fromValue = presenting ? @0.0 : @1.0;
          fade.toValue = presenting ? @1.0 : @0.0;
          animation = fade;
      }
      else if (type == SMCalloutAnimationStretch) {
          CABasicAnimation *stretch = [CABasicAnimation animationWithKeyPath:@"transform.scale"];
          stretch.duration = 0.1;
          stretch.fromValue = presenting ? @0.0 : @1.0;
          stretch.toValue = presenting ? @1.0 : @0.0;
          animation = stretch;
      }

      // CAAnimation is KVC compliant, so we can store whether we're presenting for lookup in our delegate methods
      [animation setValue:@(presenting) forKey:@"presenting"];

      animation.fillMode = kCAFillModeForwards;
      animation.removedOnCompletion = NO;
      return animation;

  }

- (void)layoutSubviews {

      self.containerView.frame = self.bounds;
      self.backgroundView.frame = self.bounds;

      // if we're pointing up, we'll need to push almost everything down a bit
      CGFloat dy = self.currentArrowDirection == SMCalloutArrowDirectionUp ? TOP_ANCHOR_MARGIN : 0;

      self.titleViewOrDefault.frameX = self.innerContentMarginLeft;
      self.titleViewOrDefault.frameY = (self.subtitleView || self.subtitle.length ? TITLE_SUB_TOP : TITLE_TOP) + dy;
      self.titleViewOrDefault.frameWidth = self.frameWidth - self.innerContentMarginLeft - self.innerContentMarginRight;

      self.subtitleViewOrDefault.frameX = self.titleViewOrDefault.frameX;
      self.subtitleViewOrDefault.frameY = SUBTITLE_TOP + dy;
      self.subtitleViewOrDefault.frameWidth = self.titleViewOrDefault.frameWidth;

      self.leftAccessoryView.frameX = self.leftAccessoryHorizontalMargin;
      self.leftAccessoryView.frameY = self.leftAccessoryVerticalMargin + dy;

      self.rightAccessoryView.frameX = self.frameWidth - self.rightAccessoryHorizontalMargin - self.rightAccessoryView.frameWidth;
      self.rightAccessoryView.frameY = self.rightAccessoryVerticalMargin + dy;

      if (self.contentView) {
          self.contentView.frameX = self.innerContentMarginLeft;
          self.contentView.frameY = self.contentViewInset.top + dy;
      }

  }

#pragma mark - Accessibility

- (NSInteger)accessibilityElementCount {
  return (!!self.leftAccessoryView + !!self.titleViewOrDefault +
  !!self.subtitleViewOrDefault + !!self.rightAccessoryView);
  }

- (id)accessibilityElementAtIndex:(NSInteger)index {
  if (index == 0) {
  return self.leftAccessoryView ? self.leftAccessoryView : self.titleViewOrDefault;
  }
  if (index == 1) {
  return self.leftAccessoryView ? self.titleViewOrDefault : self.subtitleViewOrDefault;
  }
  if (index == 2) {
  return self.leftAccessoryView ? self.subtitleViewOrDefault : self.rightAccessoryView;
  }
  if (index == 3) {
  return self.leftAccessoryView ? self.rightAccessoryView : nil;
  }
  return nil;
  }

- (NSInteger)indexOfAccessibilityElement:(id)element {
  if (element == nil) return NSNotFound;
  if (element == self.leftAccessoryView) return 0;
  if (element == self.titleViewOrDefault) {
  return self.leftAccessoryView ? 1 : 0;
  }
  if (element == self.subtitleViewOrDefault) {
  return self.leftAccessoryView ? 2 : 1;
  }
  if (element == self.rightAccessoryView) {
  return self.leftAccessoryView ? 3 : 2;
  }
  return NSNotFound;
  }

@end

// import this known "private API" from SMCalloutBackgroundView
@interface SMCalloutBackgroundView (EmbeddedImages)

- (UIImage _)embeddedImageNamed:(NSString _)name;
  @end

//
// Callout Background View.
//

@interface SMCalloutMaskedBackgroundView ()
@property (nonatomic, strong) UIView *containerView, *containerBorderView, *arrowView;
@property (nonatomic, strong) UIImageView *arrowImageView, *arrowHighlightedImageView, *arrowBorderView;
@end

static UIImage *blackArrowImage = nil, *whiteArrowImage = nil, \*grayArrowImage = nil;

@implementation SMCalloutMaskedBackgroundView

- (id)initWithFrame:(CGRect)frame {
  if (self = [super initWithFrame:frame]) {

          // Here we're mimicking the very particular (and odd) structure of the system callout view.
          // The hierarchy and view/layer values were discovered by inspecting map kit using Reveal.app

          self.containerView = [UIView new];
          self.containerView.backgroundColor = [UIColor whiteColor];
          self.containerView.alpha = 0.96;
          self.containerView.layer.cornerRadius = 8;
          self.containerView.layer.shadowRadius = 30;
          self.containerView.layer.shadowOpacity = 0.1;

          self.containerBorderView = [UIView new];
          self.containerBorderView.layer.borderColor = [UIColor colorWithWhite:0 alpha:0.1].CGColor;
          self.containerBorderView.layer.borderWidth = 0.5;
          self.containerBorderView.layer.cornerRadius = 8.5;

          if (!blackArrowImage) {
              blackArrowImage = [SMCalloutBackgroundView embeddedImageNamed:@"CalloutArrow"];
              whiteArrowImage = [self image:blackArrowImage withColor:[UIColor whiteColor]];
              grayArrowImage = [self image:blackArrowImage withColor:[UIColor colorWithWhite:0.85 alpha:1]];
          }

          self.anchorHeight = 13;
          self.anchorMargin = 27;

          self.arrowView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, blackArrowImage.size.width, blackArrowImage.size.height)];
          self.arrowView.alpha = 0.96;
          self.arrowImageView = [[UIImageView alloc] initWithImage:whiteArrowImage];
          self.arrowHighlightedImageView = [[UIImageView alloc] initWithImage:grayArrowImage];
          self.arrowHighlightedImageView.hidden = YES;
          self.arrowBorderView = [[UIImageView alloc] initWithImage:blackArrowImage];
          self.arrowBorderView.alpha = 0.1;
          self.arrowBorderView.frameY = 0.5;

          [self addSubview:self.containerView];
          [self.containerView addSubview:self.containerBorderView];
          [self addSubview:self.arrowView];
          [self.arrowView addSubview:self.arrowBorderView];
          [self.arrowView addSubview:self.arrowImageView];
          [self.arrowView addSubview:self.arrowHighlightedImageView];
      }
      return self;

  }

// Make sure we relayout our images when our arrow point changes!

- (void)setArrowPoint:(CGPoint)arrowPoint {
  [super setArrowPoint:arrowPoint];
  [self setNeedsLayout];
  }

- (void)setHighlighted:(BOOL)highlighted {
  [super setHighlighted:highlighted];
  self.containerView.backgroundColor = highlighted ? [UIColor colorWithWhite:0.85 alpha:1] : [UIColor whiteColor];
  self.arrowImageView.hidden = highlighted;
  self.arrowHighlightedImageView.hidden = !highlighted;
  }

- (UIImage _)image:(UIImage _)image withColor:(UIColor \*)color {

      UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);
      CGRect imageRect = (CGRect){.size=image.size};
      CGContextRef c = UIGraphicsGetCurrentContext();
      CGContextTranslateCTM(c, 0, image.size.height);
      CGContextScaleCTM(c, 1, -1);
      CGContextClipToMask(c, imageRect, image.CGImage);
      [color setFill];
      CGContextFillRect(c, imageRect);
      UIImage *whiteImage = UIGraphicsGetImageFromCurrentImageContext();
      UIGraphicsEndImageContext();
      return whiteImage;

  }

- (void)layoutSubviews {

      BOOL pointingUp = self.arrowPoint.y < self.frameHeight/2;

      // if we're pointing up, we'll need to push almost everything down a bit
      CGFloat dy = pointingUp ? TOP_ANCHOR_MARGIN : 0;

      self.containerView.frame = CGRectMake(0, dy, self.frameWidth, self.frameHeight - self.arrowView.frameHeight + 0.5);
      self.containerBorderView.frame = CGRectInset(self.containerView.bounds, -0.5, -0.5);

      self.arrowView.frameX = roundf(self.arrowPoint.x - self.arrowView.frameWidth / 2);

      if (pointingUp) {
          self.arrowView.frameY = 1;
          self.arrowView.transform = CGAffineTransformMakeRotation(M_PI);
      }
      else {
          self.arrowView.frameY = self.containerView.frameHeight - 0.5;
          self.arrowView.transform = CGAffineTransformIdentity;
      }

  }

- (CALayer \*)contentMask {

      UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, 0);

      [self.layer renderInContext:UIGraphicsGetCurrentContext()];

      UIImage *maskImage = UIGraphicsGetImageFromCurrentImageContext();
      UIGraphicsEndImageContext();

      CALayer *layer = [CALayer layer];
      layer.frame = self.bounds;
      layer.contents = (id)maskImage.CGImage;
      return layer;

  }

@end

@implementation SMCalloutBackgroundView

- (NSData _)dataWithBase64EncodedString:(NSString _)string {
  //
  // NSData+Base64.m
  //
  // Version 1.0.2
  //
  // Created by Nick Lockwood on 12/01/2012.
  // Copyright (C) 2012 Charcoal Design
  //
  // Distributed under the permissive zlib License
  // Get the latest version from here:
  //
  // https://github.com/nicklockwood/Base64
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  // claim that you wrote the original software. If you use this software
  // in a product, an acknowledgment in the product documentation would be
  // appreciated but is not required.
  //
  // 2. Altered source versions must be plainly marked as such, and must not be
  // misrepresented as being the original software.
  //
  // 3. This notice may not be removed or altered from any source distribution.
  //
  const char lookup[] = {
  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
  99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 62, 99, 99, 99, 63,
  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 99, 99, 99, 99, 99, 99,
  99, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 99, 99, 99, 99, 99,
  99, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 99, 99, 99, 99, 99
  };

      NSData *inputData = [string dataUsingEncoding:NSASCIIStringEncoding allowLossyConversion:YES];
      long long inputLength = [inputData length];
      const unsigned char *inputBytes = [inputData bytes];

      long long maxOutputLength = (inputLength / 4 + 1) * 3;
      NSMutableData *outputData = [NSMutableData dataWithLength:(NSUInteger)maxOutputLength];
      unsigned char *outputBytes = (unsigned char *)[outputData mutableBytes];

      int accumulator = 0;
      long long outputLength = 0;
      unsigned char accumulated[] = {0, 0, 0, 0};
      for (long long i = 0; i < inputLength; i++) {
          unsigned char decoded = lookup[inputBytes[i] & 0x7F];
          if (decoded != 99) {
              accumulated[accumulator] = decoded;
              if (accumulator == 3) {
                  outputBytes[outputLength++] = (accumulated[0] << 2) | (accumulated[1] >> 4);
                  outputBytes[outputLength++] = (accumulated[1] << 4) | (accumulated[2] >> 2);
                  outputBytes[outputLength++] = (accumulated[2] << 6) | accumulated[3];
              }
              accumulator = (accumulator + 1) % 4;
          }
      }

      //handle left-over data
      if (accumulator > 0) outputBytes[outputLength] = (accumulated[0] << 2) | (accumulated[1] >> 4);
      if (accumulator > 1) outputBytes[++outputLength] = (accumulated[1] << 4) | (accumulated[2] >> 2);
      if (accumulator > 2) outputLength++;

      //truncate data to match actual output length
      outputData.length = (NSUInteger)outputLength;
      return outputLength? outputData: nil;

  }

- (UIImage _)embeddedImageNamed:(NSString _)name {
  CGFloat screenScale = [UIScreen mainScreen].scale;
  if (screenScale > 1.0) {
  name = [name stringByAppendingString:@"_2x"];
  screenScale = 2.0;
  }

      SEL selector = NSSelectorFromString(name);

      if (![(id)self respondsToSelector:selector]) {
          NSLog(@"Could not find an embedded image. Ensure that you've added a class-level method named +%@", name);
          return nil;
      }

      // We need to hush the compiler here - but we know what we're doing!

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
  NSString \*base64String = [(id)self performSelector:selector];
  #pragma clang diagnostic pop

      UIImage *rawImage = [UIImage imageWithData:[self dataWithBase64EncodedString:base64String]];
      return [UIImage imageWithCGImage:rawImage.CGImage scale:screenScale orientation:UIImageOrientationUp];

  }

- (NSString \*)CalloutArrow { return @"iVBORw0KGgoAAAANSUhEUgAAACcAAAANCAYAAAAqlHdlAAAAHGlET1QAAAACAAAAAAAAAAcAAAAoAAAABwAAAAYAAADJEgYpIwAAAJVJREFUOBFiYIAAdn5+fkFOTkE5Dg5eW05O3lJOTr6zQPyfDhhoD28pxF5BOZA7gE5ih7oLN8XJyR8MdNwrGjkQaC5/MG7biZDh4OBXBDruLpUdeBdkLhHWE1bCzs6nAnTcUyo58DnIPMK2kqAC6DALIP5JoQNB+i1IsJZ4pcBEm0iJ40D6ibeNDJVAx00k04ETSbUOAAAA//+SwicfAAAAe0lEQVRjYCAdMHNy8u7l5OT7Tzzm3Qu0hpl0q8jQwcPDIwp02B0iHXeHl5dXhAxryNfCzc2tC3TcJwIO/ARSR74tFOjk4uL1BzruHw4H/gPJU2A85Vq5uPjTgY77g+bAPyBxyk2nggkcHPxOnJz8B4AOfAGiQXwqGMsAACGK1kPPMHNBAAAAAElFTkSuQmCC"; }

- (NSString \*)CalloutArrow_2x { return @"iVBORw0KGgoAAAANSUhEUgAAAE4AAAAaCAYAAAAZtWr8AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAHGlET1QAAAACAAAAAAAAAA0AAAAoAAAADQAAAA0AAAFMRh0LGwAAARhJREFUWAnclbENwjAQRZ0mih2fDYgsQEVDxQZMgKjpWYAJkBANI8AGDIEoM0WkzBDRAf8klB44g0OkU1zE3/+9RIpS7VVY730/y/woTWlsjJ9iPcN9pbXfY85auyvm/qcDNmb0e2Z+sk/ZBTthN0oVttX12mJIWeaWEFf+kbySmZQa0msu3nzaGJprTXV3BVLNDG/if7bNOTeAvFP35NGJu39GL7Abb27bFXncVQBZLgJf3jp+ebSWIxZMgrxdvPJoJ4gqHpXgV36ITR46HUGaiNMKB6YQd4lI3gV8qTBjmDhrbQFxVQTyKu4ShjJQap7nE4hrfiiv4Q6B8MLGat1bQNztB/JwZm8Rli5wujFu821xfGZgLPUAAAD//4wvm4gAAAD7SURBVOWXMQ6CMBiFgaFpi6VyBEedXJy4hMQTeBSvRDgJEySegI3EQWOivkZnqUB/k0LyL7R9L++D9G+DwP0TCZGUqCdRlYgUuY9F4JCmqQa0hgBcY7wIItFZMLZYS5l0ruAZbXhs6BIROgmhcoB7OIAHTZUTRqG3wp9xmhqc0aRPQu8YAlwxIbwCEUL6GH9wfDcLXY2HpyvvmkHf9+BcrwCuHQGvNRp9Pl6OY0PPAO42AB7WqMxLKLahpFR7gLv/AA9zPe+gtvAMCIC7WMC7CqEPtrqzmBfHyy3A1V/g1Th27GYBY0BIxrk6Ap65254/VZp30GID9JwteQEZrVMWXqGn8gAAAABJRU5ErkJggg=="; }

@end

//
// Our UIView frame helpers implementation
//

@implementation UIView (SMFrameAdditions)

- (CGPoint)frameOrigin { return self.frame.origin; }
- (void)setFrameOrigin:(CGPoint)origin { self.frame = (CGRect){ .origin=origin, .size=self.frame.size }; }

- (CGFloat)frameX { return self.frame.origin.x; }
- (void)setFrameX:(CGFloat)x { self.frame = (CGRect){ .origin.x=x, .origin.y=self.frame.origin.y, .size=self.frame.size }; }

- (CGFloat)frameY { return self.frame.origin.y; }
- (void)setFrameY:(CGFloat)y { self.frame = (CGRect){ .origin.x=self.frame.origin.x, .origin.y=y, .size=self.frame.size }; }

- (CGSize)frameSize { return self.frame.size; }
- (void)setFrameSize:(CGSize)size { self.frame = (CGRect){ .origin=self.frame.origin, .size=size }; }

- (CGFloat)frameWidth { return self.frame.size.width; }
- (void)setFrameWidth:(CGFloat)width { self.frame = (CGRect){ .origin=self.frame.origin, .size.width=width, .size.height=self.frame.size.height }; }

- (CGFloat)frameHeight { return self.frame.size.height; }
- (void)setFrameHeight:(CGFloat)height { self.frame = (CGRect){ .origin=self.frame.origin, .size.width=self.frame.size.width, .size.height=height }; }

- (CGFloat)frameLeft { return self.frame.origin.x; }
- (void)setFrameLeft:(CGFloat)left { self.frame = (CGRect){ .origin.x=left, .origin.y=self.frame.origin.y, .size.width=fmaxf(self.frame.origin.x+self.frame.size.width-left,0), .size.height=self.frame.size.height }; }

- (CGFloat)frameTop { return self.frame.origin.y; }
- (void)setFrameTop:(CGFloat)top { self.frame = (CGRect){ .origin.x=self.frame.origin.x, .origin.y=top, .size.width=self.frame.size.width, .size.height=fmaxf(self.frame.origin.y+self.frame.size.height-top,0) }; }

- (CGFloat)frameRight { return self.frame.origin.x + self.frame.size.width; }
- (void)setFrameRight:(CGFloat)right { self.frame = (CGRect){ .origin=self.frame.origin, .size.width=fmaxf(right-self.frame.origin.x,0), .size.height=self.frame.size.height }; }

- (CGFloat)frameBottom { return self.frame.origin.y + self.frame.size.height; }
- (void)setFrameBottom:(CGFloat)bottom { self.frame = (CGRect){ .origin=self.frame.origin, .size.width=self.frame.size.width, .size.height=fmaxf(bottom-self.frame.origin.y,0) }; }

@end
</file>

<file path="ios/AirMaps/AIRMap.h">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import <React/RCTComponent.h>
#import "SMCalloutView.h"
#import "RCTConvert+AirMap.h"
#import "AIRMapCalloutSubview.h"

@class AIRMapMarker;

extern const NSTimeInterval AIRMapRegionChangeObserveInterval;
extern const CGFloat AIRMapZoomBoundBuffer;
extern const NSInteger AIRMapMaxZoomLevel;

@interface AIRMap: MKMapView<SMCalloutViewDelegate>

@property (nonatomic, strong) SMCalloutView *calloutView;
@property (nonatomic, strong) UIImageView *cacheImageView;
@property (nonatomic, strong) UIView \*loadingView;

@property (nonatomic, copy) NSString *userLocationAnnotationTitle;
@property (nonatomic, assign) BOOL followUserLocation;
@property (nonatomic, assign) BOOL userLocationCalloutEnabled;
@property (nonatomic, assign) BOOL hasStartedRendering;
@property (nonatomic, assign) BOOL cacheEnabled;
@property (nonatomic, assign) BOOL loadingEnabled;
@property (nonatomic, assign) BOOL legacyZoomConstraintsEnabled;
@property (nonatomic, strong) UIColor *loadingBackgroundColor;
@property (nonatomic, strong) UIColor *loadingIndicatorColor;
@property (nonatomic, assign) BOOL hasShownInitialLoading;
@property (nonatomic, assign) CGFloat minDelta;
@property (nonatomic, assign) CGFloat maxDelta;
@property (nonatomic, assign) UIEdgeInsets legalLabelInsets;
@property (nonatomic, assign) MKCoordinateRegion initialRegion;
@property (nonatomic, assign) MKMapCamera *initialCamera;
@property (nonatomic, assign) CGFloat minZoomLevel;
@property (nonatomic, assign) CGFloat maxZoomLevel;
@property (nonatomic, assign) CGPoint compassOffset;
@property (nonatomic, assign) UIEdgeInsets mapPadding;

@property (nonatomic, assign) CLLocationCoordinate2D pendingCenter;
@property (nonatomic, assign) MKCoordinateSpan pendingSpan;

@property (nonatomic, assign) BOOL ignoreRegionChanges;

@property (nonatomic, copy) RCTBubblingEventBlock onMapReady;
@property (nonatomic, copy) RCTBubblingEventBlock onChange;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@property (nonatomic, copy) RCTBubblingEventBlock onPanDrag;
@property (nonatomic, copy) RCTBubblingEventBlock onDoublePress;
@property (nonatomic, copy) RCTBubblingEventBlock onLongPress;
@property (nonatomic, copy) RCTDirectEventBlock onMarkerPress;
@property (nonatomic, copy) RCTDirectEventBlock onMarkerSelect;
@property (nonatomic, copy) RCTDirectEventBlock onMarkerDeselect;
@property (nonatomic, copy) RCTDirectEventBlock onMarkerDragStart;
@property (nonatomic, copy) RCTDirectEventBlock onMarkerDrag;
@property (nonatomic, copy) RCTDirectEventBlock onMarkerDragEnd;

@property (nonatomic, copy) RCTDirectEventBlock onCalloutPress;
@property (nonatomic, copy) RCTDirectEventBlock onRegionChangeStart;
@property (nonatomic, copy) RCTDirectEventBlock onRegionChange;
@property (nonatomic, copy) RCTBubblingEventBlock onUserLocationChange;

- (void)cacheViewIfNeeded;
- (void)beginLoading;
- (void)finishLoading;
- (double)getZoomLevel;
- (NSArray \*)getMapBoundaries;

- (AIRMapMarker\*) markerAtPoint:(CGPoint)point;
- (NSDictionary\*) getMarkersFramesWithOnlyVisible:(BOOL)onlyVisible;

@end
</file>

<file path="ios/AirMaps/AIRMap.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMap.h"

#import <React/RCTEventDispatcher.h>
#import <React/UIView+React.h>
#import "AIRMapMarker.h"
#import "AIRMapPolyline.h"
#import "AIRMapPolygon.h"
#import "AIRMapCircle.h"
#import <QuartzCore/QuartzCore.h>
#import "AIRMapUrlTile.h"
#import "AIRMapWMSTile.h"
#import "AIRMapLocalTile.h"
#import "AIRMapOverlay.h"

const NSTimeInterval AIRMapRegionChangeObserveInterval = 0.1;
const CGFloat AIRMapZoomBoundBuffer = 0.01;
const NSInteger AIRMapMaxZoomLevel = 20;

@interface MKMapView (UIGestureRecognizer)

// this tells the compiler that MKMapView actually implements this method

- (BOOL)gestureRecognizer:(UIGestureRecognizer _)gestureRecognizer shouldReceiveTouch:(UITouch _)touch;

@end

@interface AIRMap ()

@property (nonatomic, strong) UIActivityIndicatorView *activityIndicatorView;
@property (nonatomic, assign) NSNumber *shouldZoomEnabled;
@property (nonatomic, assign) NSNumber *shouldScrollEnabled;
@property (nonatomic, strong) MKCompassButton *defaultCompassButton;
@property (nonatomic, strong) MKCompassButton \*overlayCompassButton;

- (void)updateScrollEnabled;
- (void)updateZoomEnabled;

@end

@implementation AIRMap
{
UIView \*\_legalLabel;
BOOL \_initialRegionSet;
BOOL \_initialCameraSet;

    // Array to manually track RN subviews
    //
    // AIRMap implicitly creates subviews that aren't regular RN children
    // (SMCalloutView injects an overlay subview), which otherwise confuses RN
    // during component re-renders:
    // https://github.com/facebook/react-native/blob/v0.16.0/React/Modules/RCTUIManager.m#L657
    //
    // Implementation based on RCTTextField, another component with indirect children
    // https://github.com/facebook/react-native/blob/v0.16.0/Libraries/Text/RCTTextField.m#L20
    NSMutableArray<UIView *> *_reactSubviews;

}

- (instancetype)init
  {
  if ((self = [super init])) {
  \_hasStartedRendering = NO;
  \_reactSubviews = [NSMutableArray new];
          // Find Apple link label
          for (UIView *subview in self.subviews) {
              if ([NSStringFromClass(subview.class) isEqualToString:@"MKAttributionLabel"]) {
                  // This check is super hacky, but the whole premise of moving around
                  // Apple's internal subviews is super hacky
                  _legalLabel = subview;
                  break;
              }
          }

          // 3rd-party callout view for MapKit that has more options than the built-in. It's painstakingly built to
          // be identical to the built-in callout view (which has a private API)
          self.calloutView = [SMCalloutView platformCalloutView];
          self.calloutView.delegate = self;

          self.minZoomLevel = 0;
          self.maxZoomLevel = AIRMapMaxZoomLevel;
          self.compassOffset = CGPointMake(0, 0);
          self.legacyZoomConstraintsEnabled = YES;
      }
      return self;
  }

-(void)addSubview:(UIView \*)view {
if([view isKindOfClass:[AIRMapMarker class]]) {
[self addAnnotation:(id <MKAnnotation>)view];
} else {
[super addSubview:view];
}
}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-missing-super-calls"

- (void)insertReactSubview:(id<RCTComponent>)subview atIndex:(NSInteger)atIndex {
  // Our desired API is to pass up markers/overlays as children to the mapview component.
  // This is where we intercept them and do the appropriate underlying mapview action.
  if ([subview isKindOfClass:[AIRMapMarker class]]) {
  [self addAnnotation:(id <MKAnnotation>) subview];
  } else if ([subview isKindOfClass:[AIRMapPolyline class]]) {
  ((AIRMapPolyline _)subview).map = self;
  [self addOverlay:(id<MKOverlay>)subview];
  } else if ([subview isKindOfClass:[AIRMapPolygon class]]) {
  ((AIRMapPolygon _)subview).map = self;
  [self addOverlay:(id<MKOverlay>)subview];
  } else if ([subview isKindOfClass:[AIRMapCircle class]]) {
  ((AIRMapCircle _)subview).map = self;
  [self addOverlay:(id<MKOverlay>)subview];
  } else if ([subview isKindOfClass:[AIRMapUrlTile class]]) {
  ((AIRMapUrlTile _)subview).map = self;
  [self addOverlay:(id<MKOverlay>)subview];
  }else if ([subview isKindOfClass:[AIRMapWMSTile class]]) {
  ((AIRMapWMSTile _)subview).map = self;
  [self addOverlay:(id<MKOverlay>)subview];
  } else if ([subview isKindOfClass:[AIRMapLocalTile class]]) {
  ((AIRMapLocalTile _)subview).map = self;
  [self addOverlay:(id<MKOverlay>)subview];
  } else if ([subview isKindOfClass:[AIRMapOverlay class]]) {
  ((AIRMapOverlay *)subview).map = self;
  [self addOverlay:(id<MKOverlay>)subview];
  } else {
  NSArray<id<RCTComponent>> *childSubviews = [subview reactSubviews];
  for (int i = 0; i < childSubviews.count; i++) {
  [self insertReactSubview:(UIView _)childSubviews[i] atIndex:atIndex];
  }
  }
  [\_reactSubviews insertObject:(UIView _)subview atIndex:(NSUInteger) atIndex];
  }
  #pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-missing-super-calls"

- (void)removeReactSubview:(id<RCTComponent>)subview {
  // similarly, when the children are being removed we have to do the appropriate
  // underlying mapview action here.
  if ([subview isKindOfClass:[AIRMapMarker class]]) {
  [self removeAnnotation:(id<MKAnnotation>)subview];
  } else if ([subview isKindOfClass:[AIRMapPolyline class]]) {
  [self removeOverlay:(id <MKOverlay>) subview];
  } else if ([subview isKindOfClass:[AIRMapPolygon class]]) {
  [self removeOverlay:(id <MKOverlay>) subview];
  } else if ([subview isKindOfClass:[AIRMapCircle class]]) {
  [self removeOverlay:(id <MKOverlay>) subview];
  } else if ([subview isKindOfClass:[AIRMapUrlTile class]]) {
  [self removeOverlay:(id <MKOverlay>) subview];
  } else if ([subview isKindOfClass:[AIRMapWMSTile class]]) {
  [self removeOverlay:(id <MKOverlay>) subview];
  } else if ([subview isKindOfClass:[AIRMapLocalTile class]]) {
  [self removeOverlay:(id <MKOverlay>) subview];
  } else if ([subview isKindOfClass:[AIRMapOverlay class]]) {
  [self removeOverlay:(id <MKOverlay>) subview];
  } else {
  NSArray<id<RCTComponent>> _childSubviews = [subview reactSubviews];
  for (int i = 0; i < childSubviews.count; i++) {
  [self removeReactSubview:(UIView _)childSubviews[i]];
  }
  }
  [_reactSubviews removeObject:(UIView *)subview];
  }
  #pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-missing-super-calls"

- (NSArray<id<RCTComponent>> \*)reactSubviews {
  return \_reactSubviews;
  }
  #pragma clang diagnostic pop

#pragma mark Utils

- (NSArray*) markers {
  NSPredicate *filterMarkers = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
  AIRMapMarker *marker = (AIRMapMarker *)evaluatedObject;
  return [marker isKindOfClass:[AIRMapMarker class]];
  }];
  NSArray *filteredMarkers = [self.annotations filteredArrayUsingPredicate:filterMarkers];
  return filteredMarkers;
  }

- (AIRMapMarker*) markerForCallout:(AIRMapCallout*)callout {
  AIRMapMarker* marker = nil;
  NSArray* markers = [self markers];
  for (AIRMapMarker\* mrk in markers) {
  if (mrk.calloutView == callout) {
  marker = mrk;
  break;
  }
  }
  return marker;
  }

- (CGRect) frameForMarker:(AIRMapMarker*) mrkAnn {
  MKAnnotationView* mrkView = [self viewForAnnotation: mrkAnn];
  CGRect mrkFrame = mrkView.frame;
  return mrkFrame;
  }

- (NSDictionary*) getMarkersFramesWithOnlyVisible:(BOOL)onlyVisible {
  NSMutableDictionary* markersFrames = [NSMutableDictionary new];
  for (AIRMapMarker* mrkAnn in self.markers) {
  CGRect frame = [self frameForMarker:mrkAnn];
  CGPoint point = [self convertCoordinate:mrkAnn.coordinate toPointToView:self];
  NSDictionary* frameDict = @{
  @"x": @(frame.origin.x),
  @"y": @(frame.origin.y),
  @"width": @(frame.size.width),
  @"height": @(frame.size.height)
  };
  NSDictionary* pointDict = @{
  @"x": @(point.x),
  @"y": @(point.y)
  };
  NSString* k = mrkAnn.identifier;
  BOOL isVisible = CGRectIntersectsRect(self.bounds, frame);
  if (k != nil && (!onlyVisible || isVisible)) {
  [markersFrames setObject:@{ @"frame": frameDict, @"point": pointDict } forKey:k];
  }
  }
  return markersFrames;
  }

- (AIRMapMarker*) markerAtPoint:(CGPoint)point {
  AIRMapMarker* mrk = nil;
  for (AIRMapMarker\* mrkAnn in self.markers) {
  CGRect frame = [self frameForMarker:mrkAnn];
  if (CGRectContainsPoint(frame, point)) {
  mrk = mrkAnn;
  break;
  }
  }
  return mrk;
  }

#pragma mark Overrides for Callout behavior

// override UIGestureRecognizer's delegate method so we can prevent MKMapView's recognizer from firing
// when we interact with UIControl subclasses inside our callout view.

- (BOOL)gestureRecognizer:(UIGestureRecognizer _)gestureRecognizer shouldReceiveTouch:(UITouch _)touch {
  if ([touch.view isDescendantOfView:self.calloutView])
  return NO;
  else
  return [super gestureRecognizer:gestureRecognizer shouldReceiveTouch:touch];
  }

// Allow touches to be sent to our calloutview.
// See this for some discussion of why we need to override this: https://github.com/nfarina/calloutview/pull/9

- (UIView _)hitTest:(CGPoint)point withEvent:(UIEvent _)event {
      CGPoint touchPoint = [self.calloutView convertPoint:point fromView:self];
      UIView *touchedView = [self.calloutView hitTest:touchPoint withEvent:event];

      if (touchedView) {
          UIWindow* win = [[[UIApplication sharedApplication] windows] firstObject];
          AIRMapCalloutSubview* calloutSubview = nil;
          AIRMapCallout* callout = nil;
          AIRMapMarker* marker = nil;

          UIView* tmp = touchedView;
          while (tmp && tmp != win && tmp != self.calloutView) {
              if ([tmp respondsToSelector:@selector(onPress)]) {
                  calloutSubview = (AIRMapCalloutSubview*) tmp;
              }
              if ([tmp isKindOfClass:[AIRMapCallout class]]) {
                  callout = (AIRMapCallout*) tmp;
                  break;
              }
              tmp = tmp.superview;
          }

          if (callout) {
              marker = [self markerForCallout:callout];
              if (marker) {
                  CGPoint touchPointReal = [marker.calloutView convertPoint:point fromView:self];
                  if (![callout isPointInside:touchPointReal]) {
                      return [super hitTest:point withEvent:event];
                  }
              }
          }

          return calloutSubview ? calloutSubview : touchedView;
      }

      return [super hitTest:point withEvent:event];
  }

#pragma mark SMCalloutViewDelegate

- (NSTimeInterval)calloutView:(SMCalloutView \*)calloutView delayForRepositionWithSize:(CGSize)offset {
      // When the callout is being asked to present in a way where it or its target will be partially offscreen, it asks us
      // if we'd like to reposition our surface first so the callout is completely visible. Here we scroll the map into view,
      // but it takes some math because we have to deal in lon/lat instead of the given offset in pixels.

      CLLocationCoordinate2D coordinate = self.region.center;

      // where's the center coordinate in terms of our view?
      CGPoint center = [self convertCoordinate:coordinate toPointToView:self];

      // move it by the requested offset
      center.x -= offset.width;
      center.y -= offset.height;

      // and translate it back into map coordinates
      coordinate = [self convertPoint:center toCoordinateFromView:self];

      // move the map!
      [self setCenterCoordinate:coordinate animated:YES];

      // tell the callout to wait for a while while we scroll (we assume the scroll delay for MKMapView matches UIScrollView)
      return kSMCalloutViewRepositionDelayForUIScrollView;
  }

#pragma mark Accessors

- (NSArray \*)getMapBoundaries
  {
  MKMapRect mapRect = self.visibleMapRect;

      CLLocationCoordinate2D northEast = MKCoordinateForMapPoint(MKMapPointMake(MKMapRectGetMaxX(mapRect), mapRect.origin.y));
      CLLocationCoordinate2D southWest = MKCoordinateForMapPoint(MKMapPointMake(mapRect.origin.x, MKMapRectGetMaxY(mapRect)));

      return @[
          @[
              [NSNumber numberWithDouble:northEast.longitude],
              [NSNumber numberWithDouble:northEast.latitude]
          ],
          @[
              [NSNumber numberWithDouble:southWest.longitude],
              [NSNumber numberWithDouble:southWest.latitude]
          ]
      ];

  }

- (void)setShowsUserLocation:(BOOL)showsUserLocation
  {
  if (self.showsUserLocation != showsUserLocation) {
  super.showsUserLocation = showsUserLocation;
  }
  }

- (void)setUserInterfaceStyle:(NSString*)userInterfaceStyle
  {
  if (@available(iOS 13.0, *)) {
  if([userInterfaceStyle isEqualToString:@"light"]) {
  self.overrideUserInterfaceStyle = UIUserInterfaceStyleLight;
  } else if([userInterfaceStyle isEqualToString:@"dark"]) {
  self.overrideUserInterfaceStyle = UIUserInterfaceStyleDark;
  } else {
  self.overrideUserInterfaceStyle = UIUserInterfaceStyleUnspecified;
  }
  } else {
  NSLog(@"UserInterfaceStyle not supported below iOS 13");
  }
  }

- (void)setTintColor:(UIColor \*)tintColor
  {
  super.tintColor = tintColor;
  }

- (void)setFollowsUserLocation:(BOOL)followsUserLocation
  {
  \_followUserLocation = followsUserLocation;
  }

- (void)setUserLocationCalloutEnabled:(BOOL)calloutEnabled
  {
  \_userLocationCalloutEnabled = calloutEnabled;
  }

- (void)setHandlePanDrag:(BOOL)handleMapDrag {
  for (UIGestureRecognizer \*recognizer in [self gestureRecognizers]) {
  if ([recognizer isKindOfClass:[UIPanGestureRecognizer class]]) {
  recognizer.enabled = handleMapDrag;
  break;
  }
  }
  }

- (void)setRegion:(MKCoordinateRegion)region animated:(BOOL)animated
  {
  // If location is invalid, abort
  if (!CLLocationCoordinate2DIsValid(region.center)) {
  return;
  }

      // If new span values are nil, use old values instead
      if (!region.span.latitudeDelta) {
          region.span.latitudeDelta = self.region.span.latitudeDelta;
      }
      if (!region.span.longitudeDelta) {
          region.span.longitudeDelta = self.region.span.longitudeDelta;
      }

      // Animate/move to new position
      [super setRegion:region animated:animated];

  }

- (void)setInitialRegion:(MKCoordinateRegion)initialRegion {
  if (!\_initialRegionSet) {
  \_initialRegionSet = YES;
  [self setRegion:initialRegion animated:NO];
  }
  }

- (void)setCamera:(MKMapCamera\*)camera animated:(BOOL)animated
  {
  [super setCamera:camera animated:animated];
  }

- (void)setInitialCamera:(MKMapCamera\*)initialCamera {
  if (!\_initialCameraSet) {
  \_initialCameraSet = YES;
  [self setCamera:initialCamera animated:NO];
  }
  }

- (void)setCacheEnabled:(BOOL)cacheEnabled {
  \_cacheEnabled = cacheEnabled;
  if (self.cacheEnabled && self.cacheImageView.image == nil) {
  self.loadingView.hidden = NO;
  [self.activityIndicatorView startAnimating];
  }
  else {
  if (\_loadingView != nil) {
  self.loadingView.hidden = YES;
  }
  }
  }

- (void)setLoadingEnabled:(BOOL)loadingEnabled {
  \_loadingEnabled = loadingEnabled;
  if (!self.hasShownInitialLoading) {
  self.loadingView.hidden = !self.loadingEnabled;
  }
  else {
  if (\_loadingView != nil) {
  self.loadingView.hidden = YES;
  }
  }
  }

- (UIColor \*)loadingBackgroundColor {
  return self.loadingView.backgroundColor;
  }

- (void)setLoadingBackgroundColor:(UIColor \*)loadingBackgroundColor {
  self.loadingView.backgroundColor = loadingBackgroundColor;
  }

- (UIColor \*)loadingIndicatorColor {
  return self.activityIndicatorView.color;
  }

- (void)setLoadingIndicatorColor:(UIColor \*)loadingIndicatorColor {
  self.activityIndicatorView.color = loadingIndicatorColor;
  }

- (void)setCameraZoomRange:(NSDictionary _)cameraZoomRange {
  if (@available(iOS 13.0, _)) {
          if (cameraZoomRange == nil) {
              cameraZoomRange = @{};
          }

          NSNumber *minValue = cameraZoomRange[@"minCenterCoordinateDistance"];
          NSNumber *maxValue = cameraZoomRange[@"maxCenterCoordinateDistance"];

          if (minValue == nil && maxValue == nil) {
              self.legacyZoomConstraintsEnabled = YES;

              MKMapCameraZoomRange *defaultZoomRange = [[MKMapCameraZoomRange alloc] initWithMinCenterCoordinateDistance:MKMapCameraZoomDefault maxCenterCoordinateDistance:MKMapCameraZoomDefault];
              [super setCameraZoomRange:defaultZoomRange animated:NO];

              return;
          }

          MKMapCameraZoomRange *zoomRange = nil;

          if (minValue != nil && maxValue != nil) {
              zoomRange = [[MKMapCameraZoomRange alloc] initWithMinCenterCoordinateDistance:[minValue doubleValue] maxCenterCoordinateDistance:[maxValue doubleValue]];
          } else if (minValue != nil) {
              zoomRange = [[MKMapCameraZoomRange alloc] initWithMinCenterCoordinateDistance:[minValue doubleValue]];
          } else if (maxValue != nil) {
              zoomRange = [[MKMapCameraZoomRange alloc] initWithMaxCenterCoordinateDistance:[maxValue doubleValue]];
          }

          BOOL animated = [cameraZoomRange[@"animated"] boolValue];

          self.legacyZoomConstraintsEnabled = NO;
          [super setCameraZoomRange:zoomRange animated:animated];
      }
  }

// Include properties of MKMapView which are only available on iOS 9+
// and check if their selector is available before calling super method.

- (void)setShowsCompass:(BOOL)showsCompass {
  if (self.overlayCompassButton != nil) {
  self.overlayCompassButton.compassVisibility = showsCompass ? MKFeatureVisibilityAdaptive : MKFeatureVisibilityHidden;
  }
  if ([MKMapView instancesRespondToSelector:@selector(setShowsCompass:)]) {
  [super setShowsCompass:showsCompass];
  }
  }

- (BOOL)showsCompass {
  if ([MKMapView instancesRespondToSelector:@selector(showsCompass)]) {
  return [super showsCompass];
  } else {
  return NO;
  }
  }

- (void)setShowsScale:(BOOL)showsScale {
  if ([MKMapView instancesRespondToSelector:@selector(setShowsScale:)]) {
  [super setShowsScale:showsScale];
  }
  }

- (BOOL)showsScale {
  if ([MKMapView instancesRespondToSelector:@selector(showsScale)]) {
  return [super showsScale];
  } else {
  return NO;
  }
  }

- (void)setShowsTraffic:(BOOL)showsTraffic {
  if ([MKMapView instancesRespondToSelector:@selector(setShowsTraffic:)]) {
  [super setShowsTraffic:showsTraffic];
  }
  }

- (BOOL)showsTraffic {
  if ([MKMapView instancesRespondToSelector:@selector(showsTraffic)]) {
  return [super showsTraffic];
  } else {
  return NO;
  }
  }

- (void)setScrollEnabled:(BOOL)scrollEnabled {
  self.shouldScrollEnabled = [NSNumber numberWithBool:scrollEnabled];
  [self updateScrollEnabled];
  }

- (void)updateScrollEnabled {
  if (self.cacheEnabled) {
  [super setScrollEnabled:NO];
  }
  else if (self.shouldScrollEnabled != nil) {
  [super setScrollEnabled:[self.shouldScrollEnabled boolValue]];
  }
  }

- (void)setZoomEnabled:(BOOL)zoomEnabled {
  self.shouldZoomEnabled = [NSNumber numberWithBool:zoomEnabled];
  [self updateZoomEnabled];
  }

- (void)updateZoomEnabled {
  if (self.cacheEnabled) {
  [super setZoomEnabled: NO];
  }
  else if (self.shouldZoomEnabled != nil) {
  [super setZoomEnabled:[self.shouldZoomEnabled boolValue]];
  }
  }

- (void)cacheViewIfNeeded {
  // https://github.com/react-native-maps/react-native-maps/issues/3100
  // Do nothing if app is not active
  if ([[UIApplication sharedApplication] applicationState] != UIApplicationStateActive) {
  return;
  }
  if (self.hasShownInitialLoading) {
  if (!self.cacheEnabled) {
  if (\_cacheImageView != nil) {
  self.cacheImageView.hidden = YES;
  self.cacheImageView.image = nil;
  }
  }
  else {
  self.cacheImageView.image = nil;
  self.cacheImageView.hidden = YES;

              dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.01 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                  self.cacheImageView.image = nil;
                  self.cacheImageView.hidden = YES;
                  UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, 0.0);
                  [self.layer renderInContext:UIGraphicsGetCurrentContext()];
                  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
                  UIGraphicsEndImageContext();

                  self.cacheImageView.image = image;
                  self.cacheImageView.hidden = NO;
              });
          }

          [self updateScrollEnabled];
          [self updateZoomEnabled];
          [self updateLegalLabelInsets];
      }

  }

- (void)updateLegalLabelInsets {
  if (\_legalLabel) {
  dispatch_async(dispatch_get_main_queue(), ^{
  CGRect frame = self->\_legalLabel.frame;
  if (self->\_legalLabelInsets.left) {
  frame.origin.x = self->\_legalLabelInsets.left;
  } else if (self->\_legalLabelInsets.right) {
  frame.origin.x = self.frame.size.width - self->\_legalLabelInsets.right - frame.size.width;
  }
  if (self->\_legalLabelInsets.top) {
  frame.origin.y = self->\_legalLabelInsets.top;
  } else if (self->\_legalLabelInsets.bottom) {
  frame.origin.y = self.frame.size.height - self->\_legalLabelInsets.bottom - frame.size.height;
  }
  self->\_legalLabel.frame = frame;
  });
  }
  }

- (void)setLegalLabelInsets:(UIEdgeInsets)legalLabelInsets {
  \_legalLabelInsets = legalLabelInsets;
  [self updateLegalLabelInsets];
  }

- (void)setMapPadding:(UIEdgeInsets)mapPadding {
  self.layoutMargins = mapPadding;
  }

- (UIEdgeInsets)mapPadding {
  return self.layoutMargins;
  }

- (void)beginLoading {
  if ((!self.hasShownInitialLoading && self.loadingEnabled) || (self.cacheEnabled && self.cacheImageView.image == nil)) {
  self.loadingView.hidden = NO;
  [self.activityIndicatorView startAnimating];
  }
  else {
  if (\_loadingView != nil) {
  self.loadingView.hidden = YES;
  }
  }
  }

- (void)finishLoading {
  self.hasShownInitialLoading = YES;
  if (\_loadingView != nil) {
  self.loadingView.hidden = YES;
  }
  [self cacheViewIfNeeded];
  }

- (UIActivityIndicatorView \*)activityIndicatorView {
  if (\_activityIndicatorView == nil) {
  \_activityIndicatorView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleGray];
  \_activityIndicatorView.center = self.loadingView.center;
  \_activityIndicatorView.autoresizingMask = UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleRightMargin;
  \_activityIndicatorView.color = [UIColor colorWithRed:96.f/255.f green:96.f/255.f blue:96.f/255.f alpha:1.f]; // defaults to #606060
  }
  [self.loadingView addSubview:_activityIndicatorView];
  return \_activityIndicatorView;
  }

- (UIView \*)loadingView {
  if (\_loadingView == nil) {
  \_loadingView = [[UIView alloc] initWithFrame:self.bounds];
  \_loadingView.autoresizingMask = UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight;
  \_loadingView.backgroundColor = [UIColor whiteColor]; // defaults to #FFFFFF
  [self addSubview:_loadingView];
  \_loadingView.hidden = NO;
  }
  return \_loadingView;
  }

- (UIImageView \*)cacheImageView {
  if (\_cacheImageView == nil) {
  \_cacheImageView = [[UIImageView alloc] initWithFrame:self.bounds];
  \_cacheImageView.contentMode = UIViewContentModeCenter;
  \_cacheImageView.autoresizingMask = UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight;
  [self addSubview:self.cacheImageView];
  \_cacheImageView.hidden = YES;
  }
  return \_cacheImageView;
  }

- (void)layoutSubviews {
  [super layoutSubviews];
  [self cacheViewIfNeeded];
  if (self.overlayCompassButton == nil) {
  for (UIView \*subview in self.subviews) {
  if (![NSStringFromClass(subview.class) isEqualToString:@"MKPassThroughStackView"]) continue;
  self.overlayCompassButton = [MKCompassButton compassButtonWithMapView:self];
  [subview addSubview:self.overlayCompassButton];
  self.overlayCompassButton.frame = CGRectMake(self.overlayCompassButton.frame.origin.x + \_compassOffset.x, self.overlayCompassButton.frame.origin.y + \_compassOffset.y, self.overlayCompassButton.frame.size.width, self.overlayCompassButton.frame.size.height);
  break;
  }
  }
  if (self.defaultCompassButton == nil) {
  for (UIView *subview in self.subviews) {
  if (![NSStringFromClass(subview.class) isEqualToString:@"MKPassThroughStackView"]) continue;
  for (UIView *subview2 in subview.subviews) {
  if (![NSStringFromClass(subview2.class) isEqualToString:@"MKCompassView"]) continue;
  self.defaultCompassButton = subview2;
  self.defaultCompassButton.hidden = YES;
  }
  break;
  }
  }

}

// based on https://medium.com/@dmytrobabych/getting-actual-rotation-and-zoom-level-for-mapkit-mkmapview-e7f03f430aa9

- (CGFloat)getZoomLevel {
  CGFloat cameraAngle = self.camera.heading;
      if (cameraAngle > 270) {
          cameraAngle = 360 - cameraAngle;
      } else if (cameraAngle > 90) {
          cameraAngle = fabs(cameraAngle - 180);
      }

      CGFloat angleRad = M_PI * cameraAngle / 180; // map rotation in radians
      CGFloat width = self.frame.size.width;
      CGFloat height = self.frame.size.height;
      CGFloat heightOffset = 20; // the offset (status bar height) which is taken by MapKit into consideration to calculate visible area height

      // calculating Longitude span corresponding to normal (non-rotated) width
      CGFloat spanStraight = width * self.region.span.longitudeDelta / (width * cos(angleRad) + (height - heightOffset) * sin(angleRad));
      int normalizingFactor = 512;

      return log2(360 * ((width / normalizingFactor) / spanStraight));
  }

@end
</file>

<file path="ios/AirMaps/AIRMapCallout.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <React/RCTView.h>

@interface AIRMapCallout : RCTView

@property (nonatomic, assign) BOOL tooltip;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@property (nonatomic, assign) BOOL alphaHitTest;

- (BOOL) isPointInside:(CGPoint)pointInCallout;

@end
</file>

<file path="ios/AirMaps/AIRMapCallout.m">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import "AIRMapCallout.h"

@implementation AIRMapCallout

- (BOOL) isPointInside:(CGPoint)pointInCallout {
  if (!self.alphaHitTest)
  return TRUE;
  CGFloat alpha = [self alphaOfPoint:pointInCallout];
  return alpha >= 0.01;
  }

- (CGFloat) alphaOfPoint:(CGPoint)point {
  unsigned char pixel[4] = {0};
  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
  CGContextRef context = CGBitmapContextCreate(pixel, 1, 1, 8, 4, colorSpace, kCGBitmapAlphaInfoMask & kCGImageAlphaPremultipliedLast);
  CGContextTranslateCTM(context, -point.x, -point.y);
  [self.layer renderInContext:context];
  CGContextRelease(context);
  CGColorSpaceRelease(colorSpace);
  return pixel[3]/255.0;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapCalloutManager.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <React/RCTViewManager.h>

@interface AIRMapCalloutManager : RCTViewManager
@end
</file>

<file path="ios/AirMaps/AIRMapCalloutManager.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMapCalloutManager.h"

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "AIRMapMarker.h"
#import "AIRMapCallout.h"

@interface AIRMapCalloutManager()

@end

@implementation AIRMapCalloutManager

RCT_EXPORT_MODULE()

- (UIView \*)view
  {
  return [AIRMapCallout new];
  }

RCT_EXPORT_VIEW_PROPERTY(tooltip, BOOL)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(alphaHitTest, BOOL)

@end
</file>

<file path="ios/AirMaps/AIRMapCalloutSubview.h">
//
//  AIRMapCalloutSubview.h
//  AirMaps
//
//  Created by Denis Oblogin on 10/8/18.
//
//

#import <UIKit/UIKit.h>
#import <React/RCTView.h>

@interface AIRMapCalloutSubview : UIView
@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@end
</file>

<file path="ios/AirMaps/AIRMapCalloutSubview.m">
//
//  AIRMapCalloutSubview.m
//  AirMaps
//
//  Created by Denis Oblogin on 10/8/18.
//
//

#import "AIRMapCalloutSubview.h"
#import <React/RCTUtils.h>
#import <React/RCTView.h>
#import <React/RCTBridge.h>

@implementation AIRMapCalloutSubview
@end
</file>

<file path="ios/AirMaps/AIRMapCalloutSubviewManager.h">
//
//  AIRMapCalloutSubviewManager.h
//  AirMaps
//
//  Created by Denis Oblogin on 10/8/18.
//
//

#import <React/RCTViewManager.h>

@interface AIRMapCalloutSubviewManager : RCTViewManager

@end
</file>

<file path="ios/AirMaps/AIRMapCalloutSubviewManager.m">
//
//  AIRMapCalloutSubviewManager.m
//  AirMaps
//
//  Created by Denis Oblogin on 10/8/18.
//
//

#import "AIRMapCalloutSubviewManager.h"
#import "AIRMapCalloutSubview.h"
#import <React/RCTView.h>

@implementation AIRMapCalloutSubviewManager
RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapCalloutSubview *calloutSubview = [AIRMapCalloutSubview new];
  return calloutSubview;
  }

RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)

@end
</file>

<file path="ios/AirMaps/AIRMapCircle.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <Foundation/Foundation.h>

#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import <React/RCTComponent.h>
#import <React/RCTView.h>

#import "AIRMapCoordinate.h"
#import "AIRMap.h"
#import "RCTConvert+AirMap.h"

@interface AIRMapCircle: MKAnnotationView <MKOverlay>

@property (nonatomic, weak) AIRMap \*map;

@property (nonatomic, strong) MKCircle *circle;
@property (nonatomic, strong) MKCircleRenderer *renderer;

@property (nonatomic, assign) CLLocationCoordinate2D centerCoordinate;
@property (nonatomic, assign) CLLocationDistance radius;

@property (nonatomic, strong) UIColor *fillColor;
@property (nonatomic, strong) UIColor *strokeColor;
@property (nonatomic, assign) CGFloat strokeWidth;
@property (nonatomic, assign) CGFloat miterLimit;
@property (nonatomic, assign) CGLineCap lineCap;
@property (nonatomic, assign) CGLineJoin lineJoin;
@property (nonatomic, assign) CGFloat lineDashPhase;
@property (nonatomic, strong) NSArray <NSNumber *> *lineDashPattern;

#pragma mark MKOverlay protocol

@property(nonatomic, readonly) CLLocationCoordinate2D coordinate;
@property(nonatomic, readonly) MKMapRect boundingMapRect;

- (BOOL)intersectsMapRect:(MKMapRect)mapRect;
- (BOOL)canReplaceMapContent;

@end
</file>

<file path="ios/AirMaps/AIRMapCircle.m">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import "AIRMapCircle.h"
#import <React/UIView+React.h>

@implementation AIRMapCircle {
BOOL \_radiusSet;
BOOL \_centerSet;
}

- (void)setFillColor:(UIColor \*)fillColor {
  \_fillColor = fillColor;
  [self update];
  }

- (void)setStrokeColor:(UIColor \*)strokeColor {
  \_strokeColor = strokeColor;
  [self update];
  }

- (void)setStrokeWidth:(CGFloat)strokeWidth {
  \_strokeWidth = strokeWidth;
  [self update];
  }

- (void)setLineJoin:(CGLineJoin)lineJoin {
  \_lineJoin = lineJoin;
  [self update];
  }

- (void)setLineCap:(CGLineCap)lineCap {
  \_lineCap = lineCap;
  [self update];
  }

- (void)setMiterLimit:(CGFloat)miterLimit {
  \_miterLimit = miterLimit;
  [self update];
  }

- (void)setLineDashPhase:(CGFloat)lineDashPhase {
  \_lineDashPhase = lineDashPhase;
  [self update];
  }

- (void)setLineDashPattern:(NSArray <NSNumber _> _)lineDashPattern {
  \_lineDashPattern = lineDashPattern;
  [self update];
  }

- (void)setRadius:(CLLocationDistance)radius {
  \_radius = radius;
  \_radiusSet = YES;
  [self createCircleAndRendererIfPossible];
  [self update];
  }

- (void)setCenterCoordinate:(CLLocationCoordinate2D)centerCoordinate{
  \_centerCoordinate = centerCoordinate;
  \_centerSet = YES;
  [self createCircleAndRendererIfPossible];
  [self update];
  }

- (void) createCircleAndRendererIfPossible
  {
  if (!\_centerSet || !\_radiusSet) return;
  self.circle = [MKCircle circleWithCenterCoordinate:_centerCoordinate radius:_radius];
  self.renderer = [[MKCircleRenderer alloc] initWithCircle:self.circle];
  }

- (void) update
  {
  if (!\_renderer) return;
  \_renderer.fillColor = \_fillColor;
  \_renderer.strokeColor = \_strokeColor;
  \_renderer.lineWidth = \_strokeWidth;
  \_renderer.lineCap = \_lineCap;
  \_renderer.lineJoin = \_lineJoin;
  \_renderer.miterLimit = \_miterLimit;
  \_renderer.lineDashPhase = \_lineDashPhase;
  \_renderer.lineDashPattern = \_lineDashPattern;

      if (_map == nil) return;
      [_map removeOverlay:self];
      [_map addOverlay:self];

  }

#pragma mark MKOverlay implementation

- (CLLocationCoordinate2D) coordinate
  {
  return self.circle.coordinate;
  }

- (MKMapRect) boundingMapRect
  {
  return self.circle.boundingMapRect;
  }

- (BOOL)intersectsMapRect:(MKMapRect)mapRect
  {
  BOOL answer = [self.circle intersectsMapRect:mapRect];
  return answer;
  }

- (BOOL)canReplaceMapContent
  {
  return NO;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapCircleManager.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <React/RCTViewManager.h>

@interface AIRMapCircleManager : RCTViewManager
@end
</file>

<file path="ios/AirMaps/AIRMapCircleManager.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMapCircleManager.h"

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "AIRMapMarker.h"
#import "AIRMapCircle.h"

@interface AIRMapCircleManager()

@end

@implementation AIRMapCircleManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapCircle *circle = [AIRMapCircle new];
  return circle;
  }

RCT_REMAP_VIEW_PROPERTY(center, centerCoordinate, CLLocationCoordinate2D)
RCT_EXPORT_VIEW_PROPERTY(radius, CLLocationDistance)
RCT_EXPORT_VIEW_PROPERTY(fillColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeWidth, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineCap, CGLineCap)
RCT_EXPORT_VIEW_PROPERTY(lineJoin, CGLineJoin)
RCT_EXPORT_VIEW_PROPERTY(miterLimit, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineDashPhase, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineDashPattern, NSArray)

// NOTE(lmr):
// for now, onPress events for overlays will be left unimplemented. Seems it is possible with some work, but
// it is difficult to achieve in both ios and android so I decided to leave it out.
//RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)

@end
</file>

<file path="ios/AirMaps/AIRMapCoordinate.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <MapKit/MapKit.h>

@interface AIRMapCoordinate : NSObject

@property (nonatomic, assign) CLLocationCoordinate2D coordinate;

@end
</file>

<file path="ios/AirMaps/AIRMapCoordinate.m">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import "AIRMapCoordinate.h"

@implementation AIRMapCoordinate
@end
</file>

<file path="ios/AirMaps/AIRMapLocalTile.h">
//
//  AIRMapLocalTile.h
//  AirMaps
//
//  Created by Peter Zavadsky on 01/12/2017.
//  Copyright  2017 Christopher. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import <React/RCTComponent.h>
#import <React/RCTView.h>
#import "AIRMapCoordinate.h"
#import "AIRMap.h"
#import "RCTConvert+AirMap.h"

@interface AIRMapLocalTile : MKAnnotationView <MKOverlay>

@property (nonatomic, weak) AIRMap \*map;

@property (nonatomic, strong) MKTileOverlay *tileOverlay;
@property (nonatomic, strong) MKTileOverlayRenderer *renderer;

@property (nonatomic, copy) NSString \*pathTemplate;
@property (nonatomic, assign) CGFloat tileSize;

#pragma mark MKOverlay protocol

@property(nonatomic, readonly) CLLocationCoordinate2D coordinate;
@property(nonatomic, readonly) MKMapRect boundingMapRect;
//- (BOOL)intersectsMapRect:(MKMapRect)mapRect;

- (BOOL)canReplaceMapContent;

@end
</file>

<file path="ios/AirMaps/AIRMapLocalTile.m">
//
//  AIRMapLocalTile.m
//  AirMaps
//
//  Created by Peter Zavadsky on 01/12/2017.
//  Copyright  2017 Christopher. All rights reserved.
//

#import "AIRMapLocalTile.h"
#import <React/UIView+React.h>
#import "AIRMapLocalTileOverlay.h"

@implementation AIRMapLocalTile {
BOOL \_pathTemplateSet;
BOOL \_tileSizeSet;
}

- (void)setPathTemplate:(NSString \*)pathTemplate{
  \_pathTemplate = pathTemplate;
  \_pathTemplateSet = YES;
  [self createTileOverlayAndRendererIfPossible];
  [self update];
  }

- (void)setTileSize:(CGFloat)tileSize{
  \_tileSize = tileSize;
  \_tileSizeSet = YES;
  [self createTileOverlayAndRendererIfPossible];
  [self update];
  }

- (void) createTileOverlayAndRendererIfPossible
  {
  if (!\_pathTemplateSet || !\_tileSizeSet) return;
  self.tileOverlay = [[AIRMapLocalTileOverlay alloc] initWithURLTemplate:self.pathTemplate];
  self.tileOverlay.canReplaceMapContent = YES;
  self.tileOverlay.tileSize = CGSizeMake(\_tileSize, \_tileSize);
  self.renderer = [[MKTileOverlayRenderer alloc] initWithTileOverlay:self.tileOverlay];
  }

- (void) update
  {
  if (!\_renderer) return;
      if (_map == nil) return;
      [_map removeOverlay:self];
      [_map addOverlay:self level:MKOverlayLevelAboveLabels];
  }

#pragma mark MKOverlay implementation

- (CLLocationCoordinate2D) coordinate
  {
  return self.tileOverlay.coordinate;
  }

- (MKMapRect) boundingMapRect
  {
  return self.tileOverlay.boundingMapRect;
  }

- (BOOL)canReplaceMapContent
  {
  return self.tileOverlay.canReplaceMapContent;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapLocalTileManager.h">
//
//  AIRMapLocalTileManager.h
//  AirMaps
//
//  Created by Peter Zavadsky on 01/12/2017.
//  Copyright  2017 Christopher. All rights reserved.
//

#import <React/RCTViewManager.h>

@interface AIRMapLocalTileManager : RCTViewManager

@end
</file>

<file path="ios/AirMaps/AIRMapLocalTileManager.m">
//
//  AIRMapLocalTileManager.m
//  AirMaps
//
//  Created by Peter Zavadsky on 01/12/2017.
//  Copyright  2017 Christopher. All rights reserved.
//

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "AIRMapMarker.h"
#import "AIRMapLocalTile.h"

#import "AIRMapLocalTileManager.h"

@interface AIRMapLocalTileManager()

@end

@implementation AIRMapLocalTileManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapLocalTile *tile = [AIRMapLocalTile new];
  return tile;
  }

RCT_EXPORT_VIEW_PROPERTY(pathTemplate, NSString)
RCT_EXPORT_VIEW_PROPERTY(tileSize, CGFloat)

@end
</file>

<file path="ios/AirMaps/AIRMapLocalTileOverlay.h">
//
//  AIRMapLocalTileOverlay.h
//  Pods
//
//  Created by Peter Zavadsky on 04/12/2017.
//

#import <MapKit/MapKit.h>

@interface AIRMapLocalTileOverlay : MKTileOverlay

@end
</file>

<file path="ios/AirMaps/AIRMapLocalTileOverlay.m">
//
//  AIRMapLocalTileOverlay.m
//  Pods-AirMapsExplorer
//
//  Created by Peter Zavadsky on 04/12/2017.
//

#import "AIRMapLocalTileOverlay.h"

@interface AIRMapLocalTileOverlay ()

@end

@implementation AIRMapLocalTileOverlay

-(void)loadTileAtPath:(MKTileOverlayPath)path result:(void (^)(NSData _, NSError _))result {
NSMutableString _tileFilePath = [self.URLTemplate mutableCopy];
[tileFilePath replaceOccurrencesOfString: @"{x}" withString:[NSString stringWithFormat:@"%li", (long)path.x] options:0 range:NSMakeRange(0, tileFilePath.length)];
[tileFilePath replaceOccurrencesOfString:@"{y}" withString:[NSString stringWithFormat:@"%li", (long)path.y] options:0 range:NSMakeRange(0, tileFilePath.length)];
[tileFilePath replaceOccurrencesOfString:@"{z}" withString:[NSString stringWithFormat:@"%li", (long)path.z] options:0 range:NSMakeRange(0, tileFilePath.length)];
if ([[NSFileManager defaultManager] fileExistsAtPath:tileFilePath]) {
NSData_ tile = [NSData dataWithContentsOfFile:tileFilePath];
result(tile,nil);
} else {
result(nil, nil);
}
}

@end
</file>

<file path="ios/AirMaps/AIRMapManager.h">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import <React/RCTViewManager.h>
#import "AIRMap.h"

#define MERCATOR_RADIUS 85445659.44705395
#define MERCATOR_OFFSET 268435456

@interface AIRMapManager : RCTViewManager

- (void)setCenterCoordinate:(CLLocationCoordinate2D)centerCoordinate
  zoomLevel:(double)zoomLevel
  animated:(BOOL)animated
  mapView:(AIRMap \*)mapView;

- (MKCoordinateRegion)coordinateRegionWithMapView:(AIRMap \*)mapView
  centerCoordinate:(CLLocationCoordinate2D)centerCoordinate
  andZoomLevel:(double)zoomLevel;
- (double) zoomLevel:(AIRMap \*)mapView;

@end
</file>

<file path="ios/AirMaps/AIRMapManager.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMapManager.h"

#import <React/RCTBridge.h>
#import <React/RCTUIManager.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "AIRMap.h"
#import "AIRMapMarker.h"
#import "AIRMapPolyline.h"
#import "AIRMapPolygon.h"
#import "AIRMapCircle.h"
#import "SMCalloutView.h"
#import "AIRMapUrlTile.h"
#import "AIRMapWMSTile.h"
#import "AIRMapLocalTile.h"
#import "AIRMapSnapshot.h"
#import "RCTConvert+AirMap.h"
#import "AIRMapOverlay.h"
#import <MapKit/MapKit.h>

static NSString \*const RCTMapViewKey = @"MapView";

@interface AIRMapManager() <MKMapViewDelegate, UIGestureRecognizerDelegate>

- (BOOL)gestureRecognizer:(UIGestureRecognizer _)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer _)otherGestureRecognizer;

@end

@implementation AIRMapManager{
BOOL \_hasObserver;
}

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMap *map = [AIRMap new];
  map.delegate = self;

      map.isAccessibilityElement = NO;
      map.accessibilityElementsHidden = NO;

      // MKMapView doesn't report tap events, so we attach gesture recognizers to it
      UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleMapTap:)];
      UITapGestureRecognizer *doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleMapDoubleTap:)];
      [doubleTap setNumberOfTapsRequired:2];
      [tap requireGestureRecognizerToFail:doubleTap];

      UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleMapLongPress:)];
      UIPanGestureRecognizer *drag = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleMapDrag:)];
      [drag setMinimumNumberOfTouches:1];
      // setting this to NO allows the parent MapView to continue receiving marker selection events
      tap.cancelsTouchesInView = NO;
      doubleTap.cancelsTouchesInView = NO;
      longPress.cancelsTouchesInView = NO;

      doubleTap.delegate = self;

      // disable drag by default
      drag.enabled = NO;
      drag.delegate = self;

      [map addGestureRecognizer:tap];
      [map addGestureRecognizer:doubleTap];
      [map addGestureRecognizer:longPress];
      [map addGestureRecognizer:drag];

      return map;

  }

RCT_EXPORT_VIEW_PROPERTY(isAccessibilityElement, BOOL)
RCT_REMAP_VIEW_PROPERTY(testID, accessibilityIdentifier, NSString)
RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)
RCT_EXPORT_VIEW_PROPERTY(tintColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(userLocationAnnotationTitle, NSString)
RCT_EXPORT_VIEW_PROPERTY(userInterfaceStyle, NSString)
RCT_EXPORT_VIEW_PROPERTY(followsUserLocation, BOOL)
RCT_EXPORT_VIEW_PROPERTY(userLocationCalloutEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsPointsOfInterest, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsBuildings, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsCompass, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsScale, BOOL)
RCT_EXPORT_VIEW_PROPERTY(showsTraffic, BOOL)
RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(kmlSrc, NSString)
RCT_EXPORT_VIEW_PROPERTY(rotateEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(scrollEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(pitchEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(cacheEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(loadingEnabled, BOOL)
RCT_EXPORT_VIEW_PROPERTY(loadingBackgroundColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(loadingIndicatorColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(handlePanDrag, BOOL)
RCT_EXPORT_VIEW_PROPERTY(maxDelta, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(minDelta, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(compassOffset, CGPoint)
RCT_EXPORT_VIEW_PROPERTY(legalLabelInsets, UIEdgeInsets)
RCT_EXPORT_VIEW_PROPERTY(mapPadding, UIEdgeInsets)
RCT_EXPORT_VIEW_PROPERTY(mapType, MKMapType)
RCT_EXPORT_VIEW_PROPERTY(cameraZoomRange, NSDictionary)
RCT_EXPORT_VIEW_PROPERTY(onMapReady, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onChange, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onRegionChangeStart, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onPanDrag, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onLongPress, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onDoublePress, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerPress, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerSelect, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerDeselect, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerDragStart, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerDrag, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onMarkerDragEnd, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onCalloutPress, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onUserLocationChange, RCTBubblingEventBlock)
RCT_CUSTOM_VIEW_PROPERTY(initialRegion, MKCoordinateRegion, AIRMap)
{
if (json == nil) return;

    // don't emit region change events when we are setting the initialRegion
    BOOL originalIgnore = view.ignoreRegionChanges;
    view.ignoreRegionChanges = YES;
    [view setInitialRegion:[RCTConvert MKCoordinateRegion:json]];
    view.ignoreRegionChanges = originalIgnore;

}
RCT_CUSTOM_VIEW_PROPERTY(initialCamera, MKMapCamera, AIRMap)
{
if (json == nil) return;

    // don't emit region change events when we are setting the initialCamera
    BOOL originalIgnore = view.ignoreRegionChanges;
    view.ignoreRegionChanges = YES;
    [view setInitialCamera:[RCTConvert MKMapCamera:json]];
    view.ignoreRegionChanges = originalIgnore;

}

RCT_EXPORT_VIEW_PROPERTY(minZoomLevel, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(maxZoomLevel, CGFloat)

RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, AIRMap)
{
if (json == nil) return;

    // don't emit region change events when we are setting the region
    BOOL originalIgnore = view.ignoreRegionChanges;
    view.ignoreRegionChanges = YES;
    [view setRegion:[RCTConvert MKCoordinateRegion:json] animated:NO];
    view.ignoreRegionChanges = originalIgnore;

}

RCT_CUSTOM_VIEW_PROPERTY(camera, MKMapCamera\*, AIRMap)
{
if (json == nil) return;

    // don't emit region change events when we are setting the camera
    BOOL originalIgnore = view.ignoreRegionChanges;
    view.ignoreRegionChanges = YES;
    [view setCamera:[RCTConvert MKMapCamera:json] animated:NO];
    view.ignoreRegionChanges = originalIgnore;

}

#pragma mark exported MapView methods

RCT_EXPORT_METHOD(getMapBoundaries:(nonnull NSNumber *)reactTag
resolver:(RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
NSArray *boundingBox = [view getMapBoundaries];

            resolve(@{
                @"northEast" : @{
                    @"longitude" : boundingBox[0][0],
                    @"latitude" : boundingBox[0][1]
                },
                @"southWest" : @{
                    @"longitude" : boundingBox[1][0],
                    @"latitude" : boundingBox[1][1]
                }
            });
        }
    }];

}

RCT_EXPORT_METHOD(getCamera:(nonnull NSNumber *)reactTag
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
AIRMap *mapView = (AIRMap *)view;
if (![view isKindOfClass:[AIRMap class]]) {
reject(@"Invalid argument", [NSString stringWithFormat:@"Invalid view returned from registry, expecting AIRMap, got: %@", view], NULL);
} else {
MKMapCamera *camera = [mapView camera];
resolve(@{
@"center": @{
@"latitude": @(camera.centerCoordinate.latitude),
@"longitude": @(camera.centerCoordinate.longitude),
},
@"pitch": @(camera.pitch),
@"heading": @(camera.heading),
@"altitude": @(camera.altitude),
});
}
}];
}

RCT_EXPORT_METHOD(setCamera:(nonnull NSNumber *)reactTag
camera:(id)json)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRMap *mapView = (AIRMap \*)view;

            // Merge the changes given with the current camera
            MKMapCamera *camera = [RCTConvert MKMapCameraWithDefaults:json existingCamera:[mapView camera]];

            // don't emit region change events when we are setting the camera
            BOOL originalIgnore = mapView.ignoreRegionChanges;
            mapView.ignoreRegionChanges = YES;
            [mapView setCamera:camera animated:NO];
            mapView.ignoreRegionChanges = originalIgnore;
        }
    }];

}

RCT_EXPORT_METHOD(animateCamera:(nonnull NSNumber *)reactTag
withCamera:(id)json
withDuration:(CGFloat)duration)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRMap *mapView = (AIRMap \*)view;

            // Merge the changes given with the current camera
            MKMapCamera *camera = [RCTConvert MKMapCameraWithDefaults:json existingCamera:[mapView camera]];

            // don't emit region change events when we are setting the camera
            BOOL originalIgnore = mapView.ignoreRegionChanges;
            mapView.ignoreRegionChanges = YES;
            [AIRMap animateWithDuration:duration/1000 animations:^{
                [mapView setCamera:camera animated:YES];
            } completion:^(BOOL finished){
                mapView.ignoreRegionChanges = originalIgnore;
            }];
        }
    }];

}

RCT_EXPORT_METHOD(animateToRegion:(nonnull NSNumber *)reactTag
withRegion:(MKCoordinateRegion)region
withDuration:(CGFloat)duration)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> _viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
[AIRMap animateWithDuration:duration/1000 animations:^{
[(AIRMap _)view setRegion:region animated:YES];
}];
}
}];
}

RCT_EXPORT_METHOD(fitToElements:(nonnull NSNumber _)reactTag
edgePadding:(nonnull NSDictionary _)edgePadding
animated:(BOOL)animated)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRMap _mapView = (AIRMap _)view;
// TODO(lmr): we potentially want to include overlays here... and could concat the two arrays together.
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.1 \* NSEC_PER_SEC), dispatch_get_main_queue(), ^{
[mapView showAnnotations:mapView.annotations animated:animated];
});
}
}];
}

RCT_EXPORT_METHOD(fitToSuppliedMarkers:(nonnull NSNumber _)reactTag
markers:(nonnull NSArray _)markers
edgePadding:(nonnull NSDictionary *)edgePadding
animated:(BOOL)animated)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRMap *mapView = (AIRMap \*)view;
// TODO(lmr): we potentially want to include overlays here... and could concat the two arrays together.
// id annotations = mapView.annotations;

            NSPredicate *filterMarkers = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {
                AIRMapMarker *marker = (AIRMapMarker *)evaluatedObject;
                return [marker isKindOfClass:[AIRMapMarker class]] && [markers containsObject:marker.identifier];
            }];

            NSArray *filteredMarkers = [mapView.annotations filteredArrayUsingPredicate:filterMarkers];

            [mapView showAnnotations:filteredMarkers animated:animated];

        }
    }];

}

RCT_EXPORT_METHOD(fitToCoordinates:(nonnull NSNumber _)reactTag
coordinates:(nonnull NSArray<AIRMapCoordinate _> _)coordinates
edgePadding:(nonnull NSDictionary _)edgePadding
animated:(BOOL)animated)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRMap _mapView = (AIRMap _)view;

            // Create Polyline with coordinates
            CLLocationCoordinate2D coords[coordinates.count];
            for(int i = 0; i < coordinates.count; i++)
            {
                coords[i] = coordinates[i].coordinate;
            }
            MKPolyline *polyline = [MKPolyline polylineWithCoordinates:coords count:coordinates.count];

            // Set Map viewport
            CGFloat top = [RCTConvert CGFloat:edgePadding[@"top"]];
            CGFloat right = [RCTConvert CGFloat:edgePadding[@"right"]];
            CGFloat bottom = [RCTConvert CGFloat:edgePadding[@"bottom"]];
            CGFloat left = [RCTConvert CGFloat:edgePadding[@"left"]];

            [mapView setVisibleMapRect:[polyline boundingMapRect] edgePadding:UIEdgeInsetsMake(top, left, bottom, right) animated:animated];

        }
    }];

}

RCT_EXPORT_METHOD(takeSnapshot:(nonnull NSNumber _)reactTag
width:(nonnull NSNumber _)width
height:(nonnull NSNumber _)height
region:(MKCoordinateRegion)region
format:(nonnull NSString _)format
quality:(nonnull NSNumber _)quality
result:(nonnull NSString _)result
callback:(RCTResponseSenderBlock)callback)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
AIRMap _mapView = (AIRMap _)view;
MKMapSnapshotOptions \*options = [[MKMapSnapshotOptions alloc] init];

            options.mapType = mapView.mapType;
            options.region = (region.center.latitude && region.center.longitude) ? region : mapView.region;
            options.size = CGSizeMake(
              ([width floatValue] == 0) ? mapView.bounds.size.width : [width floatValue],
              ([height floatValue] == 0) ? mapView.bounds.size.height : [height floatValue]
            );
            options.scale = [[UIScreen mainScreen] scale];

            MKMapSnapshotter *snapshotter = [[MKMapSnapshotter alloc] initWithOptions:options];

            [self takeMapSnapshot:mapView
                snapshotter:snapshotter
                format:format
                quality:quality.floatValue
                result:result
                callback:callback];
        }
    }];

}

RCT_EXPORT_METHOD(pointForCoordinate:(nonnull NSNumber _)reactTag
coordinate: (NSDictionary _)coordinate
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
AIRMap _mapView = (AIRMap _)view;
if (![view isKindOfClass:[AIRMap class]]) {
reject(@"Invalid argument", [NSString stringWithFormat:@"Invalid view returned from registry, expecting AIRMap, got: %@", view], NULL);
} else {
CGPoint touchPoint = [mapView convertCoordinate:
CLLocationCoordinate2DMake(
[coordinate[@"latitude"] doubleValue],
[coordinate[@"longitude"] doubleValue]
)
toPointToView:mapView];

            resolve(@{
                      @"x": @(touchPoint.x),
                      @"y": @(touchPoint.y),
                      });
        }
    }];

}

RCT_EXPORT_METHOD(getMarkersFrames:(nonnull NSNumber *)reactTag
onlyVisible:(BOOL)onlyVisible
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> *viewRegistry) {
id view = viewRegistry[reactTag];
AIRMap *mapView = (AIRMap \*)view;
if (![view isKindOfClass:[AIRMap class]]) {
reject(@"Invalid argument", [NSString stringWithFormat:@"Invalid view returned from registry, expecting AIRMap, got: %@", view], NULL);
} else {
resolve([mapView getMarkersFramesWithOnlyVisible:onlyVisible]);
}
}];
}

RCT_EXPORT_METHOD(coordinateForPoint:(nonnull NSNumber _)reactTag
point:(NSDictionary _)point
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
AIRMap _mapView = (AIRMap _)view;
if (![view isKindOfClass:[AIRMap class]]) {
reject(@"Invalid argument", [NSString stringWithFormat:@"Invalid view returned from registry, expecting AIRMap, got: %@", view], NULL);
} else {
CLLocationCoordinate2D coordinate = [mapView convertPoint:
CGPointMake(
[point[@"x"] doubleValue],
[point[@"y"] doubleValue]
)
toCoordinateFromView:mapView];

            resolve(@{
                      @"latitude": @(coordinate.latitude),
                      @"longitude": @(coordinate.longitude),
                      });
        }
    }];

}

RCT_EXPORT_METHOD(getAddressFromCoordinates:(nonnull NSNumber _)reactTag
coordinate: (NSDictionary _)coordinate
resolver: (RCTPromiseResolveBlock)resolve
rejecter:(RCTPromiseRejectBlock)reject)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager _uiManager, NSDictionary<NSNumber _, UIView *> *viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMap class]]) {
reject(@"Invalid argument", [NSString stringWithFormat:@"Invalid view returned from registry, expecting AIRMap, got: %@", view], NULL);
} else {
if (coordinate == nil ||
![[coordinate allKeys] containsObject:@"latitude"] ||
                ![[coordinate allKeys] containsObject:@"longitude"]) {
                reject(@"Invalid argument", [NSString stringWithFormat:@"Invalid coordinate format"], NULL);
            }
            CLLocation *location = [[CLLocation alloc] initWithLatitude:[coordinate[@"latitude"] doubleValue]
                                                              longitude:[coordinate[@"longitude"] doubleValue]];
CLGeocoder *geoCoder = [[CLGeocoder alloc] init];
[geoCoder reverseGeocodeLocation:location
completionHandler:^(NSArray *placemarks, NSError *error) {
if (error == nil && [placemarks count] > 0){
CLPlacemark *placemark = placemarks[0];
resolve(@{
@"name" : [NSString stringWithFormat:@"%@", placemark.name],
@"thoroughfare" : [NSString stringWithFormat:@"%@", placemark.thoroughfare],
@"subThoroughfare" : [NSString stringWithFormat:@"%@", placemark.subThoroughfare],
@"locality" : [NSString stringWithFormat:@"%@", placemark.locality],
@"subLocality" : [NSString stringWithFormat:@"%@", placemark.subLocality],
@"administrativeArea" : [NSString stringWithFormat:@"%@", placemark.administrativeArea],
@"subAdministrativeArea" : [NSString stringWithFormat:@"%@", placemark.subAdministrativeArea],
@"postalCode" : [NSString stringWithFormat:@"%@", placemark.postalCode],
@"countryCode" : [NSString stringWithFormat:@"%@", placemark.ISOcountryCode],
@"country" : [NSString stringWithFormat:@"%@", placemark.country],
});
} else {
reject(@"Invalid argument", [NSString stringWithFormat:@"Can not get address location"], NULL);
}
}];
}
}];
}

#pragma mark Take Snapshot

- (void)takeMapSnapshot:(AIRMap _)mapView
  snapshotter:(MKMapSnapshotter _) snapshotter
  format:(NSString _)format
  quality:(CGFloat) quality
  result:(NSString _)result
  callback:(RCTResponseSenderBlock) callback {
  NSTimeInterval timeStamp = [[NSDate date] timeIntervalSince1970];
  NSString *pathComponent = [NSString stringWithFormat:@"Documents/snapshot-%.20lf.%@", timeStamp, format];
  NSString *filePath = [NSHomeDirectory() stringByAppendingPathComponent: pathComponent];

      [snapshotter startWithQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
                completionHandler:^(MKMapSnapshot *snapshot, NSError *error) {
                    if (error) {
                        callback(@[error]);
                        return;
                    }
                    MKAnnotationView *pin = [[MKPinAnnotationView alloc] initWithAnnotation:nil reuseIdentifier:nil];

                    UIImage *image = snapshot.image;
                    UIGraphicsBeginImageContextWithOptions(image.size, YES, image.scale);
                    {
                        [image drawAtPoint:CGPointMake(0.0f, 0.0f)];

                        CGRect rect = CGRectMake(0.0f, 0.0f, image.size.width, image.size.height);

                        for (id <AIRMapSnapshot> overlay in mapView.overlays) {
                            if ([overlay respondsToSelector:@selector(drawToSnapshot:context:)]) {
                                    [overlay drawToSnapshot:snapshot context:UIGraphicsGetCurrentContext()];
                            }
                        }

                        for (id <MKAnnotation> annotation in mapView.annotations) {
                            CGPoint point = [snapshot pointForCoordinate:annotation.coordinate];

                            MKAnnotationView* anView = [mapView viewForAnnotation: annotation];

                            if (anView){
                                pin = anView;
                            }

                            if (CGRectContainsPoint(rect, point)) {
                                point.x = point.x + pin.centerOffset.x - (pin.bounds.size.width / 2.0f);
                                point.y = point.y + pin.centerOffset.y - (pin.bounds.size.height / 2.0f);
                                if (pin.image) {
                                    [pin.image drawAtPoint:point];
                                } else {
                                    CGRect pinRect = CGRectMake(point.x, point.y, pin.bounds.size.width, pin.bounds.size.height);
                                    [pin drawViewHierarchyInRect:pinRect afterScreenUpdates:NO];
                                }
                            }
                        }

                        UIImage *compositeImage = UIGraphicsGetImageFromCurrentImageContext();

                        NSData *data;
                        if ([format isEqualToString:@"png"]) {
                            data = UIImagePNGRepresentation(compositeImage);
                        }
                        else if([format isEqualToString:@"jpg"]) {
                            data = UIImageJPEGRepresentation(compositeImage, quality);
                        }

                        if ([result isEqualToString:@"file"]) {
                            [data writeToFile:filePath atomically:YES];
                            callback(@[[NSNull null], filePath]);
                        }
                        else if ([result isEqualToString:@"base64"]) {
                            callback(@[[NSNull null], [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithCarriageReturn]]);
                        }
                    }
                    UIGraphicsEndImageContext();
                }];

  }

#pragma mark Gesture Recognizer Handlers

#define MAX_DISTANCE_PX 10.0f

- (void)handleMapTap:(UITapGestureRecognizer *)recognizer {
  AIRMap *map = (AIRMap \*)recognizer.view;

  CGPoint tapPoint = [recognizer locationInView:map];
  CLLocationCoordinate2D tapCoordinate = [map convertPoint:tapPoint toCoordinateFromView:map];
  MKMapPoint mapPoint = MKMapPointForCoordinate(tapCoordinate);
  CGPoint mapPointAsCGP = CGPointMake(mapPoint.x, mapPoint.y);

  double maxMeters = [self metersFromPixel:MAX_DISTANCE_PX atPoint:tapPoint forMap:map];
  float nearestDistance = MAXFLOAT;
  AIRMapPolyline \*nearestPolyline = nil;

  for (id<MKOverlay> overlay in map.overlays) {
  if([overlay isKindOfClass:[AIRMapPolygon class]]){
  AIRMapPolygon _polygon = (AIRMapPolygon_) overlay;
  if (polygon.onPress) {
  CGMutablePathRef mpr = CGPathCreateMutable();

                for(int i = 0; i < polygon.coordinates.count; i++) {
                    AIRMapCoordinate *c = polygon.coordinates[i];
                    MKMapPoint mp = MKMapPointForCoordinate(c.coordinate);
                    if (i == 0) {
                        CGPathMoveToPoint(mpr, NULL, mp.x, mp.y);
                    } else {
                        CGPathAddLineToPoint(mpr, NULL, mp.x, mp.y);
                    }
                }

                if (CGPathContainsPoint(mpr, NULL, mapPointAsCGP, FALSE)) {
                    id event = @{
                                @"action": @"polygon-press",
                                @"coordinate": @{
                                    @"latitude": @(tapCoordinate.latitude),
                                    @"longitude": @(tapCoordinate.longitude),
                                },
                            };
                    polygon.onPress(event);
                }

                CGPathRelease(mpr);
            }
        }

        if([overlay isKindOfClass:[AIRMapPolyline class]]){
            AIRMapPolyline *polyline = (AIRMapPolyline*) overlay;
            if (polyline.onPress) {
                float distance = [self distanceOfPoint:MKMapPointForCoordinate(tapCoordinate)
                                          toPoly:polyline];
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestPolyline = polyline;
                }
            }
        }

        if ([overlay isKindOfClass:[AIRMapOverlay class]]) {
            AIRMapOverlay *imageOverlay = (AIRMapOverlay*) overlay;
            if (MKMapRectContainsPoint(imageOverlay.boundingMapRect, mapPoint)) {
                if (imageOverlay.onPress) {
                    id event = @{
                                 @"action": @"image-overlay-press",
                                 @"name": imageOverlay.name ?: @"unknown",
                                 @"coordinate": @{
                                         @"latitude": @(imageOverlay.coordinate.latitude),
                                         @"longitude": @(imageOverlay.coordinate.longitude)
                                         }
                                 };
                    imageOverlay.onPress(event);
                }
            }
        }

  }

  if (nearestDistance <= maxMeters) {
  id event = @{
  @"action": @"polyline-press",
  @"coordinate": @{
  @"latitude": @(tapCoordinate.latitude),
  @"longitude": @(tapCoordinate.longitude)
  }
  };
  nearestPolyline.onPress(event);
  }

  if (!map.onPress) return;
  map.onPress(@{
  @"coordinate": @{
  @"latitude": @(tapCoordinate.latitude),
  @"longitude": @(tapCoordinate.longitude),
  },
  @"position": @{
  @"x": @(tapPoint.x),
  @"y": @(tapPoint.y),
  },
  });

}

- (void)handleMapDrag:(UIPanGestureRecognizer*)recognizer {
  AIRMap *map = (AIRMap \*)recognizer.view;
  if (!map.onPanDrag) return;

  CGPoint touchPoint = [recognizer locationInView:map];
  CLLocationCoordinate2D coord = [map convertPoint:touchPoint toCoordinateFromView:map];
  map.onPanDrag(@{
  @"coordinate": @{
  @"latitude": @(coord.latitude),
  @"longitude": @(coord.longitude),
  },
  @"position": @{
  @"x": @(touchPoint.x),
  @"y": @(touchPoint.y),
  },
  @"numberOfTouches": @(recognizer.numberOfTouches)
  });

}

- (void)handleMapDoubleTap:(UIPanGestureRecognizer*)recognizer {
  AIRMap *map = (AIRMap \*)recognizer.view;
  if (!map.onDoublePress) return;
  CGPoint touchPoint = [recognizer locationInView:map];
  CLLocationCoordinate2D coord = [map convertPoint:touchPoint toCoordinateFromView:map];
  map.onDoublePress(@{
  @"coordinate": @{
  @"latitude": @(coord.latitude),
  @"longitude": @(coord.longitude),
  },
  @"position": @{
  @"x": @(touchPoint.x),
  @"y": @(touchPoint.y),
  },
  });

}

- (void)handleMapLongPress:(UITapGestureRecognizer \*)recognizer {

      // NOTE: android only does the equivalent of "began", so we only send in this case
      if (recognizer.state != UIGestureRecognizerStateBegan) return;

      AIRMap *map = (AIRMap *)recognizer.view;
      if (!map.onLongPress) return;

      CGPoint touchPoint = [recognizer locationInView:map];
      CLLocationCoordinate2D coord = [map convertPoint:touchPoint toCoordinateFromView:map];

      map.onLongPress(@{
              @"coordinate": @{
                      @"latitude": @(coord.latitude),
                      @"longitude": @(coord.longitude),
              },
              @"position": @{
                      @"x": @(touchPoint.x),
                      @"y": @(touchPoint.y),
              },
      });

  }

#pragma mark MKMapViewDelegate

#pragma mark Polyline stuff

- (MKOverlayRenderer _)mapView:(MKMapView _)mapView rendererForOverlay:(id <MKOverlay>)overlay{
  if ([overlay isKindOfClass:[AIRMapPolyline class]]) {
  return ((AIRMapPolyline _)overlay).renderer;
  } else if ([overlay isKindOfClass:[AIRMapPolygon class]]) {
  return ((AIRMapPolygon _)overlay).renderer;
  } else if ([overlay isKindOfClass:[AIRMapCircle class]]) {
  return ((AIRMapCircle _)overlay).renderer;
  } else if ([overlay isKindOfClass:[AIRMapUrlTile class]]) {
  return ((AIRMapUrlTile _)overlay).renderer;
  } else if ([overlay isKindOfClass:[AIRMapWMSTile class]]) {
  return ((AIRMapWMSTile _)overlay).renderer;
  } else if ([overlay isKindOfClass:[AIRMapLocalTile class]]) {
  return ((AIRMapLocalTile _)overlay).renderer;
  } else if ([overlay isKindOfClass:[AIRMapOverlay class]]) {
  return ((AIRMapOverlay \*)overlay).renderer;
  } else if([overlay isKindOfClass:[MKTileOverlay class]]) {
  return [[MKTileOverlayRenderer alloc] initWithTileOverlay:overlay];
  } else {
  return nil;
  }
  }

#pragma mark Annotation Stuff

- (void)mapView:(AIRMap _)mapView didAddAnnotationViews:(NSArray<MKAnnotationView _> _)views
  {
  if(!mapView.userLocationCalloutEnabled){
  for(MKAnnotationView_ view in views){
  if ([view.annotation isKindOfClass:[MKUserLocation class]]){
  [view setEnabled:NO];
  [view setCanShowCallout:NO];
  break;
  }
  }
  }
  }

- (void)mapView:(AIRMap _)mapView didSelectAnnotationView:(MKAnnotationView _)view
  {
  if ([view.annotation isKindOfClass:[AIRMapMarker class]]) {
  [(AIRMapMarker *)view.annotation showCalloutView];
  } else if ([view.annotation isKindOfClass:[MKUserLocation class]] && mapView.userLocationAnnotationTitle != nil && view.annotation.title != mapView.userLocationAnnotationTitle) {
  [(MKUserLocation*)view.annotation setTitle: mapView.userLocationAnnotationTitle];
  }

}

- (void)mapView:(AIRMap _)mapView didDeselectAnnotationView:(MKAnnotationView _)view {
  if ([view.annotation isKindOfClass:[AIRMapMarker class]]) {
  [(AIRMapMarker *)view.annotation hideCalloutView];
  }
  }

- (MKAnnotationView _)mapView:(\_\_unused AIRMap _)mapView viewForAnnotation:(AIRMapMarker _)marker
  {
  if (![marker isKindOfClass:[AIRMapMarker class]]) {
  if ([marker isKindOfClass:[MKUserLocation class]] && mapView.userLocationAnnotationTitle != nil) {
  [(MKUserLocation_)marker setTitle: mapView.userLocationAnnotationTitle];
  return nil;
  }
  return nil;
  }

      marker.map = mapView;
      return [marker getAnnotationView];

  }

static int kDragCenterContext;

- (void)mapView:(AIRMap _)mapView
  annotationView:(MKAnnotationView _)view
  didChangeDragState:(MKAnnotationViewDragState)newState
  fromOldState:(MKAnnotationViewDragState)oldState
  {
  if (![view.annotation isKindOfClass:[AIRMapMarker class]]) return;
  AIRMapMarker _marker = (AIRMapMarker _)view.annotation;

      BOOL isPinView = [view isKindOfClass:[MKPinAnnotationView class]];

      id event = @{
                   @"id": marker.identifier ?: @"unknown",
                   @"coordinate": @{
                           @"latitude": @(marker.coordinate.latitude),
                           @"longitude": @(marker.coordinate.longitude)
                           }
                   };

      if (newState == MKAnnotationViewDragStateEnding || newState == MKAnnotationViewDragStateCanceling) {
          if (!isPinView) {
              [view setDragState:MKAnnotationViewDragStateNone animated:NO];
          }
          if (mapView.onMarkerDragEnd) mapView.onMarkerDragEnd(event);
          if (marker.onDragEnd) marker.onDragEnd(event);

         if(_hasObserver) [view removeObserver:self forKeyPath:@"center"];
          _hasObserver = NO;
      } else if (newState == MKAnnotationViewDragStateStarting) {
          // MapKit doesn't emit continuous drag events. To get around this, we are going to use KVO.
          [view addObserver:self forKeyPath:@"center" options:NSKeyValueObservingOptionNew context:&kDragCenterContext];
          _hasObserver = YES;
          if (mapView.onMarkerDragStart) mapView.onMarkerDragStart(event);
          if (marker.onDragStart) marker.onDragStart(event);
      }

  }

- (void)observeValueForKeyPath:(NSString _)keyPath
  ofObject:(id)object
  change:(NSDictionary _)change
  context:(void *)context
  {
  if ([keyPath isEqualToString:@"center"] && [object isKindOfClass:[MKAnnotationView class]]) {
  MKAnnotationView *view = (MKAnnotationView *)object;
  AIRMapMarker *marker = (AIRMapMarker \*)view.annotation;

          // a marker we don't control might be getting dragged. Check just in case.
          if (!marker) return;

          AIRMap *map = marker.map;

          // don't waste time calculating if there are no events to listen to it
          if (!map.onMarkerDrag && !marker.onDrag) return;

          CGPoint position = CGPointMake(view.center.x - view.centerOffset.x, view.center.y - view.centerOffset.y);
          CLLocationCoordinate2D coordinate = [map convertPoint:position toCoordinateFromView:map];

          id event = @{
                  @"id": marker.identifier ?: @"unknown",
                  @"position": @{
                          @"x": @(position.x),
                          @"y": @(position.y),
                  },
                  @"coordinate": @{
                          @"latitude": @(coordinate.latitude),
                          @"longitude": @(coordinate.longitude),
                  }
          };

          if (map.onMarkerDrag) map.onMarkerDrag(event);
          if (marker.onDrag) marker.onDrag(event);

      } else {
          // This message is not for me; pass it on to super.
          [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
      }

  }

- (void)mapView:(AIRMap _)mapView didUpdateUserLocation:(MKUserLocation _)location
  {
  id event = @{@"coordinate": @{
  @"latitude": @(location.coordinate.latitude),
  @"longitude": @(location.coordinate.longitude),
  @"altitude": @(location.location.altitude),
  @"timestamp": @(location.location.timestamp.timeIntervalSince1970 \* 1000),
  @"accuracy": @(location.location.horizontalAccuracy),
  @"altitudeAccuracy": @(location.location.verticalAccuracy),
  @"speed": @(location.location.speed),
  @"heading": @(location.location.course),
  }
  };
      if (mapView.onUserLocationChange) {
          mapView.onUserLocationChange(event);
      }

      if (mapView.followUserLocation) {
          [mapView setCenterCoordinate:location.coordinate animated:YES];
      }

}

- (void)mapView:(AIRMap \*)mapView regionWillChangeAnimated:(BOOL)animated
  {
  if (mapView.onRegionChangeStart) mapView.onRegionChangeStart(@{});
  }

- (void)mapViewDidChangeVisibleRegion:(AIRMap \*)mapView
  {
  [self _regionChanged:mapView];
  }

- (void)mapView:(AIRMap \*)mapView regionDidChangeAnimated:(\_\_unused BOOL)animated
  {
  // Don't send region did change events until map has
  // started rendering, as these won't represent the final location
  if(mapView.hasStartedRendering){
  [self _regionChanged:mapView];
  }

      if (mapView.legacyZoomConstraintsEnabled == YES) {
          [self applyLegacyZoomConstrains:mapView];
      }

      // Don't send region did change events until map has
      // started rendering, as these won't represent the final location
      if (mapView.hasStartedRendering) {
          [self _emitRegionChangeEvent:mapView continuous:NO];
      };

      mapView.pendingCenter = mapView.region.center;
      mapView.pendingSpan = mapView.region.span;

  }

- (void)mapViewWillStartRenderingMap:(AIRMap \*)mapView
  {
  if (!mapView.hasStartedRendering) {
  mapView.onMapReady(@{});
  mapView.hasStartedRendering = YES;
  }
  [mapView beginLoading];
  }

- (void)mapViewDidFinishRenderingMap:(AIRMap \*)mapView fullyRendered:(BOOL)fullyRendered
  {
  [mapView finishLoading];
  }

#pragma mark Private

- (void)\_regionChanged:(AIRMap _)mapView
  {
  BOOL needZoom = NO;
  CGFloat newLongitudeDelta = 0.0f;
  MKCoordinateRegion region = mapView.region;
  // On iOS 7, it's possible that we observe invalid locations during initialization of the map.
  // Filter those out.
  if (!CLLocationCoordinate2DIsValid(region.center)) {
  return;
  }
  // Calculation on float is not 100% accurate. If user zoom to max/min and then move, it's likely the map will auto zoom to max/min from time to time.
  // So let's try to make map zoom back to 99% max or 101% min so that there are some buffer that moving the map won't constantly hitting the max/min bound.
  if (mapView.maxDelta > FLT_EPSILON && region.span.longitudeDelta > mapView.maxDelta) {
  needZoom = YES;
  newLongitudeDelta = mapView.maxDelta _ (1 - AIRMapZoomBoundBuffer);
  } else if (mapView.minDelta > FLT_EPSILON && region.span.longitudeDelta < mapView.minDelta) {
  needZoom = YES;
  newLongitudeDelta = mapView.minDelta _ (1 + AIRMapZoomBoundBuffer);
  }
  if (needZoom) {
  region.span.latitudeDelta = region.span.latitudeDelta / region.span.longitudeDelta _ newLongitudeDelta;
  region.span.longitudeDelta = newLongitudeDelta;
  mapView.region = region;
  }

      // Continuously observe region changes
      [self _emitRegionChangeEvent:mapView continuous:YES];

  }

- (void)\_emitRegionChangeEvent:(AIRMap \*)mapView continuous:(BOOL)continuous
  {
  if (!mapView.ignoreRegionChanges && mapView.onChange) {
  MKCoordinateRegion region = mapView.region;
  if (!CLLocationCoordinate2DIsValid(region.center)) {
  return;
  }

#define FLUSH_NAN(value) (isnan(value) ? 0 : value)
mapView.onChange(@{
@"continuous": @(continuous),
@"region": @{
@"latitude": @(FLUSH_NAN(region.center.latitude)),
@"longitude": @(FLUSH_NAN(region.center.longitude)),
@"latitudeDelta": @(FLUSH_NAN(region.span.latitudeDelta)),
@"longitudeDelta": @(FLUSH_NAN(region.span.longitudeDelta)),
}
});
}
}

/\*\* Returns the distance of |pt| to |poly| in meters

-
- \*/

* (double)distanceOfPoint:(MKMapPoint)pt toPoly:(AIRMapPolyline \*)poly
  {
  double distance = MAXFLOAT;
  for (int n = 0; n < poly.coordinates.count - 1; n++) {

          MKMapPoint ptA = MKMapPointForCoordinate(poly.coordinates[n].coordinate);
          MKMapPoint ptB = MKMapPointForCoordinate(poly.coordinates[n + 1].coordinate);

          double xDelta = ptB.x - ptA.x;
          double yDelta = ptB.y - ptA.y;

          if (xDelta == 0.0 && yDelta == 0.0) {
              continue;
          }

          double u = ((pt.x - ptA.x) * xDelta + (pt.y - ptA.y) * yDelta) / (xDelta * xDelta + yDelta * yDelta);
          MKMapPoint ptClosest;
          if (u < 0.0) {
              ptClosest = ptA;
          }
          else if (u > 1.0) {
              ptClosest = ptB;
          }
          else {
              ptClosest = MKMapPointMake(ptA.x + u * xDelta, ptA.y + u * yDelta);
          }

          distance = MIN(distance, MKMetersBetweenMapPoints(ptClosest, pt));
      }

      return distance;

  }

/\*_ Converts |px| to meters at location |pt| _/

- (double)metersFromPixel:(NSUInteger)px atPoint:(CGPoint)pt forMap:(AIRMap \*)mapView
  {
  CGPoint ptB = CGPointMake(pt.x + px, pt.y);

      CLLocationCoordinate2D coordA = [mapView convertPoint:pt toCoordinateFromView:mapView];
      CLLocationCoordinate2D coordB = [mapView convertPoint:ptB toCoordinateFromView:mapView];

      return MKMetersBetweenMapPoints(MKMapPointForCoordinate(coordA), MKMapPointForCoordinate(coordB));

  }

* (double)longitudeToPixelSpaceX:(double)longitude
  {
  return round(MERCATOR_OFFSET + MERCATOR_RADIUS _ longitude _ M_PI / 180.0);
  }

* (double)latitudeToPixelSpaceY:(double)latitude
  {
  if (latitude == 90.0) {
  return 0;
  } else if (latitude == -90.0) {
  return MERCATOR_OFFSET _ 2;
  } else {
  return round(MERCATOR_OFFSET - MERCATOR_RADIUS _ logf((1 + sinf(latitude _ M_PI / 180.0)) / (1 - sinf(latitude _ M_PI / 180.0))) / 2.0);
  }
  }

* (double)pixelSpaceXToLongitude:(double)pixelX
  {
  return ((round(pixelX) - MERCATOR_OFFSET) / MERCATOR_RADIUS) \* 180.0 / M_PI;
  }

* (double)pixelSpaceYToLatitude:(double)pixelY
  {
  return (M_PI / 2.0 - 2.0 _ atan(exp((round(pixelY) - MERCATOR_OFFSET) / MERCATOR_RADIUS))) _ 180.0 / M_PI;
  }

#pragma mark -
#pragma mark Helper methods

- (MKCoordinateSpan)coordinateSpanWithMapView:(AIRMap \*)mapView
  centerCoordinate:(CLLocationCoordinate2D)centerCoordinate
  andZoomLevel:(double)zoomLevel
  {
  // convert center coordiate to pixel space
  double centerPixelX = [AIRMapManager longitudeToPixelSpaceX:centerCoordinate.longitude];
  double centerPixelY = [AIRMapManager latitudeToPixelSpaceY:centerCoordinate.latitude];

      // determine the scale value from the zoom level
      double zoomExponent = AIRMapMaxZoomLevel - zoomLevel;
      double zoomScale = pow(2, zoomExponent);

      // scale the maps size in pixel space
      CGSize mapSizeInPixels = mapView.bounds.size;
      double scaledMapWidth = mapSizeInPixels.width * zoomScale;
      double scaledMapHeight = mapSizeInPixels.height * zoomScale;

      // figure out the position of the top-left pixel
      double topLeftPixelX = centerPixelX - (scaledMapWidth / 2);
      double topLeftPixelY = centerPixelY - (scaledMapHeight / 2);

      // find delta between left and right longitudes
      CLLocationDegrees minLng = [AIRMapManager pixelSpaceXToLongitude:topLeftPixelX];
      CLLocationDegrees maxLng = [AIRMapManager pixelSpaceXToLongitude:topLeftPixelX + scaledMapWidth];
      CLLocationDegrees longitudeDelta = maxLng - minLng;

      // find delta between top and bottom latitudes
      CLLocationDegrees minLat = [AIRMapManager pixelSpaceYToLatitude:topLeftPixelY];
      CLLocationDegrees maxLat = [AIRMapManager pixelSpaceYToLatitude:topLeftPixelY + scaledMapHeight];
      CLLocationDegrees latitudeDelta = -1 * (maxLat - minLat);

      // create and return the lat/lng span
      MKCoordinateSpan span = MKCoordinateSpanMake(latitudeDelta, longitudeDelta);
      return span;

  }

#pragma mark -
#pragma mark Public methods

- (void)setCenterCoordinate:(CLLocationCoordinate2D)centerCoordinate
  zoomLevel:(double)zoomLevel
  animated:(BOOL)animated
  mapView:(AIRMap \*)mapView
  {
  // clamp large numbers to 28
  zoomLevel = MIN(zoomLevel, AIRMapMaxZoomLevel);

      // use the zoom level to compute the region
      MKCoordinateSpan span = [self coordinateSpanWithMapView:mapView centerCoordinate:centerCoordinate andZoomLevel:zoomLevel];
      MKCoordinateRegion region = MKCoordinateRegionMake(centerCoordinate, span);

      // set the region like normal
      [mapView setRegion:region animated:animated];

  }

-(void)applyLegacyZoomConstrains:(AIRMap \*)mapView {
// flyover maps don't use mercator projection so we can't calculate their zoom level.
if (mapView.mapType == MKMapTypeHybridFlyover || mapView.mapType == MKMapTypeSatelliteFlyover) {
return;
}

    CGFloat zoomLevel = [mapView getZoomLevel];

    if (zoomLevel < mapView.minZoomLevel) {
      [self setCenterCoordinate:[mapView centerCoordinate] zoomLevel:mapView.minZoomLevel animated:TRUE mapView:mapView];
    }
    else if (zoomLevel > mapView.maxZoomLevel) {
      [self setCenterCoordinate:[mapView centerCoordinate] zoomLevel:mapView.maxZoomLevel animated:TRUE mapView:mapView];
    }

}

//KMapView cannot display tiles that cross the pole (as these would involve wrapping the map from top to bottom, something that a Mercator projection just cannot do).
-(MKCoordinateRegion)coordinateRegionWithMapView:(AIRMap \*)mapView
centerCoordinate:(CLLocationCoordinate2D)centerCoordinate
andZoomLevel:(double)zoomLevel
{
// clamp lat/long values to appropriate ranges
centerCoordinate.latitude = MIN(MAX(-90.0, centerCoordinate.latitude), 90.0);
centerCoordinate.longitude = fmod(centerCoordinate.longitude, 180.0);

    // convert center coordiate to pixel space
    double centerPixelX = [AIRMapManager longitudeToPixelSpaceX:centerCoordinate.longitude];
    double centerPixelY = [AIRMapManager latitudeToPixelSpaceY:centerCoordinate.latitude];

    // determine the scale value from the zoom level
    double zoomExponent = AIRMapMaxZoomLevel - zoomLevel;
    double zoomScale = pow(2, zoomExponent);

    // scale the maps size in pixel space
    CGSize mapSizeInPixels = mapView.bounds.size;
    double scaledMapWidth = mapSizeInPixels.width * zoomScale;
    double scaledMapHeight = mapSizeInPixels.height * zoomScale;

    // figure out the position of the left pixel
    double topLeftPixelX = centerPixelX - (scaledMapWidth / 2);

    // find delta between left and right longitudes
    CLLocationDegrees minLng = [AIRMapManager pixelSpaceXToLongitude:topLeftPixelX];
    CLLocationDegrees maxLng = [AIRMapManager pixelSpaceXToLongitude:topLeftPixelX + scaledMapWidth];
    CLLocationDegrees longitudeDelta = maxLng - minLng;

    // if were at a pole then calculate the distance from the pole towards the equator
    // as MKMapView doesnt like drawing boxes over the poles
    double topPixelY = centerPixelY - (scaledMapHeight / 2);
    double bottomPixelY = centerPixelY + (scaledMapHeight / 2);
    BOOL adjustedCenterPoint = NO;
    if (topPixelY > MERCATOR_OFFSET * 2) {
    	topPixelY = centerPixelY - scaledMapHeight;
    	bottomPixelY = MERCATOR_OFFSET * 2;
    	adjustedCenterPoint = YES;
    }

    // find delta between top and bottom latitudes
    CLLocationDegrees minLat = [AIRMapManager pixelSpaceYToLatitude:topPixelY];
    CLLocationDegrees maxLat = [AIRMapManager pixelSpaceYToLatitude:bottomPixelY];
    CLLocationDegrees latitudeDelta = -1 * (maxLat - minLat);

    // create and return the lat/lng span
    MKCoordinateSpan span = MKCoordinateSpanMake(latitudeDelta, longitudeDelta);
    MKCoordinateRegion region = MKCoordinateRegionMake(centerCoordinate, span);
    // once again, MKMapView doesnt like drawing boxes over the poles
    // so adjust the center coordinate to the center of the resulting region
    if (adjustedCenterPoint) {
    	region.center.latitude = [AIRMapManager pixelSpaceYToLatitude:((bottomPixelY + topPixelY) / 2.0)];
    }

    return region;

}

#pragma mark MKMapViewDelegate - Tracking the User Location

- (void)mapView:(AIRMap _)mapView didFailToLocateUserWithError:(NSError _)error {
  id event = @{@"error": @{ @"message": error.localizedDescription }};
  if (mapView.onUserLocationChange) {
  mapView.onUserLocationChange(event);
  }
  }

- (BOOL)gestureRecognizer:(UIGestureRecognizer _)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer _)otherGestureRecognizer {
  return YES;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapMarker.h">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMapMarker.h"
#import "AIRMapCallout.h"

#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import <React/RCTComponent.h>
#import "AIRMap.h"
#import "SMCalloutView.h"
#import "RCTConvert+AirMap.h"

@class RCTBridge;

@interface AIRMapMarker : MKAnnotationView <MKAnnotation>

@property (nonatomic, strong) AIRMapCallout *calloutView;
@property (nonatomic, weak) AIRMap *map;
@property (nonatomic, weak) RCTBridge \*bridge;

@property (nonatomic, strong) NSString *identifier;
@property (nonatomic, copy) NSString *imageSrc;
@property (nonatomic, copy) NSString *title;
@property (nonatomic, copy) NSString *subtitle;
@property (nonatomic, assign) CLLocationCoordinate2D coordinate;
@property (nonatomic, strong) UIColor \*pinColor;
@property (nonatomic, assign) NSInteger zIndex;
@property (nonatomic, assign) double opacity;
@property (nonatomic, assign) BOOL isPreselected;
@property (nonatomic, assign) MKFeatureVisibility titleVisibility;
@property (nonatomic, assign) MKFeatureVisibility subtitleVisibility;
@property (nonatomic, assign) BOOL useLegacyPinView;

@property (nonatomic, copy) RCTBubblingEventBlock onPress;
@property (nonatomic, copy) RCTDirectEventBlock onSelect;
@property (nonatomic, copy) RCTDirectEventBlock onDeselect;
@property (nonatomic, copy) RCTDirectEventBlock onCalloutPress;
@property (nonatomic, copy) RCTDirectEventBlock onDragStart;
@property (nonatomic, copy) RCTDirectEventBlock onDrag;
@property (nonatomic, copy) RCTDirectEventBlock onDragEnd;

- (MKAnnotationView \*)getAnnotationView;
- (void)fillCalloutView:(SMCalloutView \*)calloutView;
- (BOOL)shouldShowCalloutView;
- (void)showCalloutView;
- (void)hideCalloutView;
- (void)addTapGestureRecognizer;
- (void)setUseLegacyPinView:(BOOL)value;

@end

@interface AIREmptyCalloutBackgroundView : SMCalloutBackgroundView
@end
</file>

<file path="ios/AirMaps/AIRMapMarker.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMapMarker.h"

#import <React/RCTBridge.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTImageLoaderProtocol.h>
#import <React/RCTUtils.h>
#import <React/UIView+React.h>

NSInteger const AIR_CALLOUT_OPEN_ZINDEX_BASELINE = 999;

@implementation AIREmptyCalloutBackgroundView
@end

@implementation AIRMapMarker {
BOOL \_hasSetCalloutOffset;
RCTImageLoaderCancellationBlock \_reloadImageCancellationBlock;
MKMarkerAnnotationView _\_markerView;
MKPinAnnotationView _\_pinView;
BOOL \_calloutIsOpen;
NSInteger \_zIndexBeforeOpen;
BOOL \_useLegacyPinView;
}

- (instancetype)initWithFrame:(CGRect)frame {
  self = [super initWithFrame:frame];
  if (self) {
  [self.layer addObserver:self forKeyPath:@"zPosition" options:NSKeyValueObservingOptionNew context:nil];
  }
  return self;
  }

- (void)reactSetFrame:(CGRect)frame
  {
  // Make sure we use the image size when available
  CGSize size = self.image ? self.image.size : frame.size;
  CGRect bounds = {CGPointZero, size};

      // The MapView is basically in charge of figuring out the center position of the marker view. If the view changed in
      // height though, we need to compensate in such a way that the bottom of the marker stays at the same spot on the
      // map.
      CGFloat dy = (bounds.size.height - self.bounds.size.height) / 2;
      CGPoint center = (CGPoint){ self.center.x, self.center.y - dy };

      // Avoid crashes due to nan coords
      if (isnan(center.x) || isnan(center.y) ||
              isnan(bounds.origin.x) || isnan(bounds.origin.y) ||
              isnan(bounds.size.width) || isnan(bounds.size.height)) {
          RCTLogError(@"Invalid layout for (%@)%@. position: %@. bounds: %@",
                  self.reactTag, self, NSStringFromCGPoint(center), NSStringFromCGRect(bounds));
          return;
      }

      self.center = center;
      self.bounds = bounds;

  }

- (void)insertReactSubview:(id<RCTComponent>)subview atIndex:(NSInteger)atIndex {
  if ([subview isKindOfClass:[AIRMapCallout class]]) {
  self.calloutView = (AIRMapCallout _)subview;
  } else {
  [super insertReactSubview:(UIView _)subview atIndex:atIndex];
  }
  }

- (void)removeReactSubview:(id<RCTComponent>)subview {
  if ([subview isKindOfClass:[AIRMapCallout class]] && self.calloutView == subview) {
  self.calloutView = nil;
  } else {
  [super removeReactSubview:(UIView *)subview];
  }
  }

- (MKAnnotationView \*)getAnnotationView
  {
  if ([self shouldUsePinView]) {
  // In this case, we want to render a platform "default" legacy marker.

          if (_pinView == nil && _useLegacyPinView) {
              _pinView = [[MKPinAnnotationView alloc] initWithAnnotation:self reuseIdentifier: nil];
              [self addGestureRecognizerToView:_pinView];
              _pinView.annotation = self;

              if ([_pinView respondsToSelector:@selector(setPinTintColor:)]) {
                  _pinView.pinTintColor = self.pinColor;
              }

              _pinView.draggable = self.draggable;
              _pinView.layer.zPosition = self.zIndex;

              return _pinView;
          }



          if (_markerView == nil && !_useLegacyPinView) {
              _markerView = [[MKMarkerAnnotationView alloc] initWithAnnotation:self reuseIdentifier: nil];
              [self addGestureRecognizerToView:_markerView];
              _markerView.annotation = self;

          _markerView.draggable = self.draggable;
          _markerView.layer.zPosition = self.zIndex;
          _markerView.markerTintColor = self.pinColor;
          _markerView.titleVisibility = self.titleVisibility ?: MKFeatureVisibilityHidden;
          _markerView.subtitleVisibility = self.subtitleVisibility ?: MKFeatureVisibilityHidden;

          }
          return _markerView ?: _pinView;
      } else {
          // If it has subviews, it means we are wanting to render a custom marker with arbitrary react views.
          // if it has a non-null image, it means we want to render a custom marker with the image.
          // In either case, we want to return the AIRMapMarker since it is both an MKAnnotation and an
          // MKAnnotationView all at the same time.
          self.layer.zPosition = self.zIndex;
          return self;
      }

  }

- (void)fillCalloutView:(SMCalloutView \*)calloutView
  {
  // Set everything necessary on the calloutView before it becomes visible.

      // Apply the MKAnnotationView's desired calloutOffset (from the top-middle of the view)
       if ([self shouldUsePinView] && !_hasSetCalloutOffset && _useLegacyPinView) {
          calloutView.calloutOffset = CGPointMake(-8,0);
      } else {
          calloutView.calloutOffset = self.calloutOffset;
      }

      if (self.calloutView) {
          calloutView.title = nil;
          calloutView.subtitle = nil;
          if (self.calloutView.tooltip) {
              // if tooltip is true, then the user wants their react view to be the "tooltip" as wwell, so we set
              // the background view to something empty/transparent
              calloutView.backgroundView = [AIREmptyCalloutBackgroundView new];
          } else {
              // the default tooltip look is wanted, and the user is just filling the content with their react subviews.
              // as a result, we use the default "masked" background view.
              calloutView.backgroundView = [SMCalloutMaskedBackgroundView new];
          }

          // when this is set, the callout's content will be whatever react views the user has put as the callout's
          // children.
          calloutView.contentView = self.calloutView;

      } else {

          // if there is no calloutView, it means the user wants to use the default callout behavior with title/subtitle
          // pairs.
          calloutView.title = self.title;
          calloutView.subtitle = self.subtitle;
          calloutView.contentView = nil;
          calloutView.backgroundView = [SMCalloutMaskedBackgroundView new];
      }

  }

- (void)showCalloutView
  {
  \_calloutIsOpen = YES;
  [self setZIndex:_zIndexBeforeOpen];

      MKAnnotationView *annotationView = [self getAnnotationView];

      [self setSelected:YES animated:NO];
      [self.map selectAnnotation:self animated:NO];

      id event = @{
              @"action": @"marker-select",
              @"id": self.identifier ?: @"unknown",
              @"coordinate": @{
                      @"latitude": @(self.coordinate.latitude),
                      @"longitude": @(self.coordinate.longitude)
              }
      };

      if (self.map.onMarkerSelect) self.map.onMarkerSelect(event);
      if (self.onSelect) self.onSelect(event);

      if (![self shouldShowCalloutView]) {
          // no callout to show
          return;
      }

      [self fillCalloutView:self.map.calloutView];

      // This is where we present our custom callout view... MapKit's built-in callout doesn't have the flexibility
      // we need, but a lot of work was done by Nick Farina to make this identical to MapKit's built-in.
      [self.map.calloutView presentCalloutFromRect:annotationView.bounds
                                           inView:annotationView
                                constrainedToView:self.map
                                         animated:YES];

  }

#pragma mark - Tap Gesture & Events.

- (void)addTapGestureRecognizer {
  [self addGestureRecognizerToView:nil];
  }

- (void)addGestureRecognizerToView:(UIView *)view {
  if (!view) {
  view = self;
  }
  UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(\_handleTap:)];
  // setting this to NO allows the parent MapView to continue receiving marker selection events
  tapGestureRecognizer.cancelsTouchesInView = NO;
  [view addGestureRecognizer:tapGestureRecognizer];
  }

- (void)\_handleTap:(UITapGestureRecognizer *)recognizer {
  AIRMapMarker *marker = self;
  if (!marker) return;

      if (marker.selected) {
          CGPoint touchPoint = [recognizer locationInView:marker.map.calloutView];
          CGRect bubbleFrame = [self.calloutView convertRect:marker.map.calloutView.bounds toView:marker.map];
          CGPoint touchPointReal = [recognizer locationInView:self.calloutView];

          UIView *calloutView = [marker.map.calloutView hitTest:touchPoint withEvent:nil];
          if (calloutView) {
              // the callout (or its subview) got clicked, not the marker
              UIWindow* win = [[[UIApplication sharedApplication] windows] firstObject];
              AIRMapCalloutSubview* calloutSubview = nil;
              UIView* tmp = calloutView;
              while (tmp && tmp != win && tmp != self.calloutView && tmp != self.map) {
                  if ([tmp respondsToSelector:@selector(onPress)]) {
                      calloutSubview = (AIRMapCalloutSubview*) tmp;
                      break;
                  }
                  tmp = tmp.superview;
              }

              id event = @{
                           @"action": calloutSubview ? @"callout-inside-press" : @"callout-press",
                           @"id": marker.identifier ?: @"unknown",
                           @"point": @{
                                   @"x": @(touchPointReal.x),
                                   @"y": @(touchPointReal.y),
                                   },
                           @"frame": @{
                               @"x": @(bubbleFrame.origin.x),
                               @"y": @(bubbleFrame.origin.y),
                               @"width": @(bubbleFrame.size.width),
                               @"height": @(bubbleFrame.size.height),
                               }
                           };

              if (calloutSubview) calloutSubview.onPress(event);
              if (marker.onCalloutPress) marker.onCalloutPress(event);
              if (marker.calloutView && marker.calloutView.onPress) marker.calloutView.onPress(event);
              if (marker.map.onCalloutPress) marker.map.onCalloutPress(event);
              return;
          }
      }

      // the actual marker got clicked
      CGPoint touchPointReal = [recognizer locationInView:self.calloutView];
      id event = @{
                   @"action": @"marker-press",
                   @"id": marker.identifier ?: @"unknown",
                   @"coordinate": @{
                           @"latitude": @(marker.coordinate.latitude),
                           @"longitude": @(marker.coordinate.longitude)
                           },
                   @"position": @{
                           @"x": @(touchPointReal.x),
                           @"y": @(touchPointReal.y),
                           }
                   };

      if (marker.onPress) marker.onPress(event);
      if (marker.map.onMarkerPress) marker.map.onMarkerPress(event);

      [marker.map selectAnnotation:marker animated:NO];

  }

- (void)hideCalloutView
  {
  \_calloutIsOpen = NO;
  [self setZIndex:_zIndexBeforeOpen];
  // hide the callout view
  [self.map.calloutView dismissCalloutAnimated:YES];

      [self setSelected:NO animated:NO];
      [self.map deselectAnnotation:self animated:NO];

      id event = @{
              @"action": @"marker-deselect",
              @"id": self.identifier ?: @"unknown",
              @"coordinate": @{
                      @"latitude": @(self.coordinate.latitude),
                      @"longitude": @(self.coordinate.longitude)
              }
      };

      if (self.map.onMarkerDeselect) self.map.onMarkerDeselect(event);
      if (self.onDeselect) self.onDeselect(event);

  }

- (void)setCalloutOffset:(CGPoint)calloutOffset
  {
  \_hasSetCalloutOffset = YES;
  [super setCalloutOffset:calloutOffset];
  }

- (BOOL)shouldShowCalloutView
  {
  return self.calloutView != nil || self.title != nil || self.subtitle != nil;
  }

- (BOOL)shouldUsePinView
  {
  return self.reactSubviews.count == 0 && !self.imageSrc;
  }

- (void)setOpacity:(double)opacity
  {
  [self setAlpha:opacity];
  }

- (void)setImageSrc:(NSString \*)imageSrc
  {
  \_imageSrc = imageSrc;

      if (_reloadImageCancellationBlock) {
          _reloadImageCancellationBlock();
          _reloadImageCancellationBlock = nil;
      }
      _reloadImageCancellationBlock = [[_bridge moduleForName:@"ImageLoader"] loadImageWithURLRequest:[RCTConvert NSURLRequest:_imageSrc]
                                                                              size:self.bounds.size
                                                                             scale:RCTScreenScale()
                                                                           clipped:YES
                                                                        resizeMode:RCTResizeModeCenter
                                                                     progressBlock:nil
                                                                  partialLoadBlock:nil
                                                                   completionBlock:^(NSError *error, UIImage *image) {
                                                                       if (error) {
                                                                           // TODO(lmr): do something with the error?
                                                                           NSLog(@"%@", error);
                                                                       }
                                                                       dispatch_async(dispatch_get_main_queue(), ^{
                                                                           self.image = image;
                                                                       });
                                                                   }];

  }

- (void)setPinColor:(UIColor \*)pinColor
  {
  \_pinColor = pinColor;

      if(_useLegacyPinView && [_pinView respondsToSelector:@selector(setPinTintColor:)]) {
          _pinView.pinTintColor = _pinColor;
      } else {
          _markerView.markerTintColor = _pinColor;
      }

  }

- (void)setZIndex:(NSInteger)zIndex
  {
  \_zIndexBeforeOpen = zIndex;
  \_zIndex = \_calloutIsOpen ? zIndex + AIR_CALLOUT_OPEN_ZINDEX_BASELINE : zIndex;
  self.layer.zPosition = zIndex;
  }

- (BOOL)isSelected {
  return \_isPreselected || [super isSelected];
  }

- (void)dealloc {
  [self.layer removeObserver:self forKeyPath:@"zPosition"];
  }

- (void)observeValueForKeyPath:(NSString _)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> _)change context:(void \*)context {
  if ([keyPath isEqualToString:@"zPosition"]) {
  self.layer.zPosition = \_zIndex;
  }
  }

- (void)setUseLegacyPinView:(BOOL)value {
  \_useLegacyPinView = value;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapMarkerManager.h">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import <React/RCTViewManager.h>

@interface AIRMapMarkerManager : RCTViewManager

@end
</file>

<file path="ios/AirMaps/AIRMapMarkerManager.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMapMarkerManager.h"

#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTUIManager.h>
#import <React/UIView+React.h>
#import "AIRMapMarker.h"

@interface AIRMapMarkerManager () <MKMapViewDelegate>

@end

@implementation AIRMapMarkerManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapMarker *marker = [AIRMapMarker new];
  [marker addTapGestureRecognizer];
  marker.bridge = self.bridge;
  marker.isAccessibilityElement = YES;
  marker.accessibilityElementsHidden = NO;
  return marker;
  }

RCT_EXPORT_VIEW_PROPERTY(identifier, NSString)
RCT_REMAP_VIEW_PROPERTY(testID, accessibilityIdentifier, NSString)
//RCT_EXPORT_VIEW_PROPERTY(reuseIdentifier, NSString)
RCT_EXPORT_VIEW_PROPERTY(title, NSString)
RCT_REMAP_VIEW_PROPERTY(description, subtitle, NSString)
RCT_EXPORT_VIEW_PROPERTY(coordinate, CLLocationCoordinate2D)
RCT_EXPORT_VIEW_PROPERTY(centerOffset, CGPoint)
RCT_EXPORT_VIEW_PROPERTY(calloutOffset, CGPoint)
RCT_REMAP_VIEW_PROPERTY(image, imageSrc, NSString)
RCT_EXPORT_VIEW_PROPERTY(pinColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(draggable, BOOL)
RCT_EXPORT_VIEW_PROPERTY(zIndex, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(opacity, double)
RCT_EXPORT_VIEW_PROPERTY(isPreselected, BOOL)
RCT_EXPORT_VIEW_PROPERTY(titleVisibility, NSString)
RCT_EXPORT_VIEW_PROPERTY(subtitleVisibility, NSString)
RCT_EXPORT_VIEW_PROPERTY(useLegacyPinView, BOOL)

RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onSelect, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onDeselect, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onCalloutPress, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onDragStart, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onDrag, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(onDragEnd, RCTDirectEventBlock)

RCT_EXPORT_METHOD(showCallout:(nonnull NSNumber *)reactTag)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> _viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMapMarker class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
[(AIRMapMarker _) view showCalloutView];
}
}];
}

RCT_EXPORT_METHOD(hideCallout:(nonnull NSNumber *)reactTag)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> _viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMapMarker class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
[(AIRMapMarker _) view hideCalloutView];
}
}];
}

RCT_EXPORT_METHOD(redrawCallout:(nonnull NSNumber *)reactTag)
{
[self.bridge.uiManager addUIBlock:^(\_\_unused RCTUIManager *uiManager, NSDictionary<NSNumber _, UIView _> \*viewRegistry) {
id view = viewRegistry[reactTag];
if (![view isKindOfClass:[AIRMapMarker class]]) {
RCTLogError(@"Invalid view returned from registry, expecting AIRMap, got: %@", view);
} else {
//no need to do anything here
}
}];
}

@end
</file>

<file path="ios/AirMaps/AIRMapOverlay.h">
#import "AIRMapCallout.h"

#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import "RCTConvert+AirMap.h"
#import <React/RCTComponent.h>
#import "AIRMap.h"
#import "AIRMapOverlayRenderer.h"

@class RCTBridge;

@interface AIRMapOverlay : UIView <MKOverlay>

@property (nonatomic, strong) AIRMapOverlayRenderer *renderer;
@property (nonatomic, weak) AIRMap *map;
@property (nonatomic, weak) RCTBridge \*bridge;

@property (nonatomic, strong) NSString *name;
@property (nonatomic, copy) NSString *imageSrc;
@property (nonatomic, strong, readonly) UIImage *overlayImage;
@property (nonatomic, copy) NSArray *boundsRect;
@property (nonatomic, assign) NSInteger rotation;
@property (nonatomic, assign) CGFloat transparency;
@property (nonatomic, assign) NSInteger zIndex;

@property (nonatomic, copy) RCTBubblingEventBlock onPress;

#pragma mark MKOverlay protocol

@property(nonatomic, readonly) CLLocationCoordinate2D coordinate;
@property(nonatomic, readonly) MKMapRect boundingMapRect;

- (BOOL)intersectsMapRect:(MKMapRect)mapRect;
- (BOOL)canReplaceMapContent;

@end
</file>

<file path="ios/AirMaps/AIRMapOverlay.m">
#import "AIRMapOverlay.h"

#import <React/RCTBridge.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTImageLoaderProtocol.h>
#import <React/RCTUtils.h>
#import <React/UIView+React.h>

@interface AIRMapOverlay()
@property (nonatomic, strong, readwrite) UIImage \*overlayImage;
@end

@implementation AIRMapOverlay {
RCTImageLoaderCancellationBlock \_reloadImageCancellationBlock;
CLLocationCoordinate2D \_southWest;
CLLocationCoordinate2D \_northEast;
MKMapRect \_mapRect;
}

- (void)setImageSrc:(NSString \*)imageSrc
  {
  NSLog(@">>> SET IMAGESRC: %@", imageSrc);
  \_imageSrc = imageSrc;

      if (_reloadImageCancellationBlock) {
          _reloadImageCancellationBlock();
          _reloadImageCancellationBlock = nil;
      }
      __weak typeof(self) weakSelf = self;
      _reloadImageCancellationBlock = [[_bridge moduleForName:@"ImageLoader"] loadImageWithURLRequest:[RCTConvert NSURLRequest:_imageSrc]
                                                                              size:weakSelf.bounds.size
                                                                             scale:RCTScreenScale()
                                                                           clipped:YES
                                                                        resizeMode:RCTResizeModeCenter
                                                                     progressBlock:nil
                                                                  partialLoadBlock:nil
                                                                   completionBlock:^(NSError *error, UIImage *image) {
                                                                       if (error) {
                                                                           NSLog(@"%@", error);
                                                                       }
                                                                       dispatch_async(dispatch_get_main_queue(), ^{
                                                                           NSLog(@">>> IMAGE: %@", image);
                                                                           weakSelf.overlayImage = image;
                                                                           [weakSelf createOverlayRendererIfPossible];
                                                                           [weakSelf update];
                                                                       });
                                                                   }];

  }

- (void)setBoundsRect:(NSArray \*)boundsRect {
  \_boundsRect = boundsRect;

      _southWest = CLLocationCoordinate2DMake([boundsRect[0][0] doubleValue], [boundsRect[0][1] doubleValue]);
      _northEast = CLLocationCoordinate2DMake([boundsRect[1][0] doubleValue], [boundsRect[1][1] doubleValue]);

      MKMapPoint southWest = MKMapPointForCoordinate(_southWest);
      MKMapPoint northEast = MKMapPointForCoordinate(_northEast);

      _mapRect = MKMapRectMake(southWest.x, northEast.y, ABS(northEast.x - southWest.x), ABS(northEast.y - southWest.y));

      [self update];

  }

- (void)createOverlayRendererIfPossible
  {
  if (MKMapRectIsEmpty(\_mapRect) || !self.overlayImage) return;
  \_\_weak typeof(self) weakSelf = self;
  self.renderer = [[AIRMapOverlayRenderer alloc] initWithOverlay:weakSelf];
  }

- (void)update
  {
  if (!\_renderer) return;

      if (_map == nil) return;
      [_map removeOverlay:self];
      [_map addOverlay:self];

  }

#pragma mark MKOverlay implementation

- (CLLocationCoordinate2D)coordinate
  {
  return MKCoordinateForMapPoint(MKMapPointMake(MKMapRectGetMidX(\_mapRect), MKMapRectGetMidY(\_mapRect)));
  }

- (MKMapRect)boundingMapRect
  {
  return \_mapRect;
  }

- (BOOL)intersectsMapRect:(MKMapRect)mapRect
  {
  return MKMapRectIntersectsRect(\_mapRect, mapRect);
  }

- (BOOL)canReplaceMapContent
  {
  return NO;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapOverlayManager.h">
#import <React/RCTViewManager.h>

@interface AIRMapOverlayManager : RCTViewManager

@end
</file>

<file path="ios/AirMaps/AIRMapOverlayManager.m">
#import "AIRMapOverlayManager.h"

#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTUIManager.h>
#import <React/UIView+React.h>
#import "AIRMapOverlay.h"

@interface AIRMapOverlayManager () <MKMapViewDelegate>

@end

@implementation AIRMapOverlayManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapOverlay *overlay = [AIRMapOverlay new];
  overlay.bridge = self.bridge;
  return overlay;
  }

RCT_REMAP_VIEW_PROPERTY(bounds, boundsRect, NSArray)
RCT_REMAP_VIEW_PROPERTY(image, imageSrc, NSString)

@end
</file>

<file path="ios/AirMaps/AIRMapOverlayRenderer.h">
#import <MapKit/MapKit.h>

@interface AIRMapOverlayRenderer : MKOverlayRenderer

@property (nonatomic, assign) NSInteger rotation;
@property (nonatomic, assign) CGFloat transparency;

@end
</file>

<file path="ios/AirMaps/AIRMapOverlayRenderer.m">
#import "AIRMapOverlayRenderer.h"
#import "AIRMapOverlay.h"

@implementation AIRMapOverlayRenderer

- (void)drawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context {
  UIImage _image = [(AIRMapOverlay _)self.overlay overlayImage];

      CGContextSaveGState(context);

      CGImageRef imageReference = image.CGImage;

      MKMapRect theMapRect = [self.overlay boundingMapRect];
      CGRect theRect = [self rectForMapRect:theMapRect];

      CGContextRotateCTM(context, M_PI);
      CGContextScaleCTM(context, -1.0, 1.0);
      CGContextTranslateCTM(context, 0.0, -theRect.size.height);
      CGContextAddRect(context, theRect);
      CGContextDrawImage(context, theRect, imageReference);

      CGContextRestoreGState(context);

  }

- (BOOL)canDrawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale {
  return [(AIRMapOverlay *)self.overlay overlayImage] != nil;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapPolygon.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <Foundation/Foundation.h>

#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import <React/RCTComponent.h>
#import <React/RCTView.h>
#import "AIRMapCoordinate.h"
#import "AIRMap.h"
#import "RCTConvert+AirMap.h"

@interface AIRMapPolygon: MKAnnotationView <MKOverlay>

@property (nonatomic, weak) AIRMap \*map;

@property (nonatomic, strong) MKPolygon *polygon;
@property (nonatomic, strong) MKPolygonRenderer *renderer;
@property (nonatomic, strong) NSArray<MKPolygon *> *interiorPolygons;

@property (nonatomic, strong) NSArray<AIRMapCoordinate *> *coordinates;
@property (nonatomic, strong) NSArray<NSArray<AIRMapCoordinate _> _> *holes;
@property (nonatomic, strong) UIColor *fillColor;
@property (nonatomic, strong) UIColor _strokeColor;
@property (nonatomic, assign) CGFloat strokeWidth;
@property (nonatomic, assign) CGFloat miterLimit;
@property (nonatomic, assign) CGLineCap lineCap;
@property (nonatomic, assign) CGLineJoin lineJoin;
@property (nonatomic, assign) CGFloat lineDashPhase;
@property (nonatomic, strong) NSArray <NSNumber _> \*lineDashPattern;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;

#pragma mark MKOverlay protocol

@property(nonatomic, readonly) CLLocationCoordinate2D coordinate;
@property(nonatomic, readonly) MKMapRect boundingMapRect;

- (BOOL)intersectsMapRect:(MKMapRect)mapRect;
- (BOOL)canReplaceMapContent;

@end
</file>

<file path="ios/AirMaps/AIRMapPolygon.m">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import "AIRMapPolygon.h"
#import <React/UIView+React.h>

@implementation AIRMapPolygon {

}

- (void)setFillColor:(UIColor \*)fillColor {
  \_fillColor = fillColor;
  [self update];
  }

- (void)setStrokeColor:(UIColor \*)strokeColor {
  \_strokeColor = strokeColor;
  [self update];
  }

- (void)setStrokeWidth:(CGFloat)strokeWidth {
  \_strokeWidth = strokeWidth;
  [self update];
  }

- (void)setLineJoin:(CGLineJoin)lineJoin {
  \_lineJoin = lineJoin;
  [self update];
  }

- (void)setLineCap:(CGLineCap)lineCap {
  \_lineCap = lineCap;
  [self update];
  }

- (void)setMiterLimit:(CGFloat)miterLimit {
  \_miterLimit = miterLimit;
  [self update];
  }

- (void)setLineDashPhase:(CGFloat)lineDashPhase {
  \_lineDashPhase = lineDashPhase;
  [self update];
  }

- (void)setLineDashPattern:(NSArray <NSNumber _> _)lineDashPattern {
  \_lineDashPattern = lineDashPattern;
  [self update];
  }

- (void)setCoordinates:(NSArray<AIRMapCoordinate _> _)coordinates {
  \_coordinates = coordinates;
  CLLocationCoordinate2D coords[coordinates.count];
  for(int i = 0; i < coordinates.count; i++)
  {
  coords[i] = coordinates[i].coordinate;
  }
  self.polygon = [MKPolygon polygonWithCoordinates:coords count:coordinates.count interiorPolygons:_interiorPolygons];
  // TODO: we could lazy-initialize the polygon, since we don't need it until the
  // polygon is in view.
  self.renderer = [[MKPolygonRenderer alloc] initWithPolygon:self.polygon];
  [self update];
  }

- (void)setHoles:(NSArray<NSArray<AIRMapCoordinate _> _> _)holes {
  \_holes = holes;
  if (holes.count)
  {
  NSMutableArray<MKPolygon _> \*polygons = [NSMutableArray array];
  for(int h = 0; h < holes.count; h++)
  {
  CLLocationCoordinate2D coords[holes[h].count];
  for(int i = 0; i < holes[h].count; i++)
  {
  coords[i] = holes[h][i].coordinate;
  }
  [polygons addObject:[MKPolygon polygonWithCoordinates:coords count:holes[h].count]];
  }
  \_interiorPolygons = polygons;
  }
  }

- (void) update
  {
  if (!\_renderer) return;
  \_renderer.fillColor = \_fillColor;
  \_renderer.strokeColor = \_strokeColor;
  \_renderer.lineWidth = \_strokeWidth;
  \_renderer.lineCap = \_lineCap;
  \_renderer.lineJoin = \_lineJoin;
  \_renderer.miterLimit = \_miterLimit;
  \_renderer.lineDashPhase = \_lineDashPhase;
  \_renderer.lineDashPattern = \_lineDashPattern;

      if (_map == nil) return;
      [_map removeOverlay:self];
      [_map addOverlay:self];

  }

#pragma mark MKOverlay implementation

- (CLLocationCoordinate2D) coordinate
  {
  return self.polygon.coordinate;
  }

- (MKMapRect) boundingMapRect
  {
  return self.polygon.boundingMapRect;
  }

- (BOOL)intersectsMapRect:(MKMapRect)mapRect
  {
  BOOL answer = [self.polygon intersectsMapRect:mapRect];
  return answer;
  }

- (BOOL)canReplaceMapContent
  {
  return NO;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapPolygonManager.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <React/RCTViewManager.h>

@interface AIRMapPolygonManager : RCTViewManager
@end
</file>

<file path="ios/AirMaps/AIRMapPolygonManager.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMapPolygonManager.h"

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "RCTConvert+AirMap.h"
#import "AIRMapMarker.h"
#import "AIRMapPolygon.h"

@interface AIRMapPolygonManager()

@end

@implementation AIRMapPolygonManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapPolygon *polygon = [AIRMapPolygon new];
  return polygon;
  }

RCT_EXPORT_VIEW_PROPERTY(coordinates, AIRMapCoordinateArray)
RCT_EXPORT_VIEW_PROPERTY(holes, AIRMapCoordinateArrayArray)
RCT_EXPORT_VIEW_PROPERTY(fillColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeWidth, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineCap, CGLineCap)
RCT_EXPORT_VIEW_PROPERTY(lineJoin, CGLineJoin)
RCT_EXPORT_VIEW_PROPERTY(miterLimit, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineDashPhase, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineDashPattern, NSArray)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)

@end
</file>

<file path="ios/AirMaps/AIRMapPolyline.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <Foundation/Foundation.h>

#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import <React/RCTComponent.h>
#import <React/RCTView.h>
#import "AIRMapCoordinate.h"
#import "AIRMap.h"
#import "RCTConvert+AirMap.h"

@interface AIRMapPolyline: MKAnnotationView <MKOverlay>

@property (nonatomic, weak) AIRMap \*map;

@property (nonatomic, strong) MKPolyline *polyline;
@property (nonatomic, strong) MKOverlayPathRenderer *renderer;

@property (nonatomic, strong) NSArray<AIRMapCoordinate *> *coordinates;
@property (nonatomic, strong) UIColor *fillColor;
@property (nonatomic, strong) UIColor *strokeColor;
@property (nonatomic, strong) NSArray<UIColor *> *strokeColors;
@property (nonatomic, assign) CGFloat strokeWidth;
@property (nonatomic, assign) CGFloat miterLimit;
@property (nonatomic, assign) CGLineCap lineCap;
@property (nonatomic, assign) CGLineJoin lineJoin;
@property (nonatomic, assign) CGFloat lineDashPhase;
@property (nonatomic, strong) NSArray <NSNumber *> *lineDashPattern;
@property (nonatomic, assign) BOOL geodesic;
@property (nonatomic, copy) RCTBubblingEventBlock onPress;

#pragma mark MKOverlay protocol

@property(nonatomic, readonly) CLLocationCoordinate2D coordinate;
@property(nonatomic, readonly) MKMapRect boundingMapRect;

- (BOOL)intersectsMapRect:(MKMapRect)mapRect;
- (BOOL)canReplaceMapContent;

@end
</file>

<file path="ios/AirMaps/AIRMapPolyline.m">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import "AIRMapPolyline.h"
#import "AIRMapPolylineRenderer.h"
#import <React/UIView+React.h>

@implementation AIRMapPolyline {

}

- (void)setFillColor:(UIColor \*)fillColor {
  \_fillColor = fillColor;
  [self update];
  }

- (void)setStrokeColor:(UIColor \*)strokeColor {
  \_strokeColor = strokeColor;
  [self update];
  }

- (void)setStrokeColors:(NSArray<UIColor _> _)strokeColors {
  \_strokeColors = strokeColors;
  if ((self.renderer != nil) && ![\_renderer isKindOfClass:[AIRMapPolylineRenderer class]]) {
  self.renderer = [self createRenderer];
  }
  [self update];
  }

- (void)setStrokeWidth:(CGFloat)strokeWidth {
  \_strokeWidth = strokeWidth;
  [self update];
  }

- (void)setLineJoin:(CGLineJoin)lineJoin {
  \_lineJoin = lineJoin;
  [self update];
  }

- (void)setLineCap:(CGLineCap)lineCap {
  \_lineCap = lineCap;
  [self update];
  }

- (void)setMiterLimit:(CGFloat)miterLimit {
  \_miterLimit = miterLimit;
  [self update];
  }

- (void)setLineDashPhase:(CGFloat)lineDashPhase {
  \_lineDashPhase = lineDashPhase;
  [self update];
  }

- (void)setLineDashPattern:(NSArray <NSNumber _> _)lineDashPattern {
  \_lineDashPattern = lineDashPattern;
  [self update];
  }

-(void)setGeodesic:(BOOL)geodesic
{
\_geodesic = geodesic;
if(\_coordinates){
[self setCoordinates:_coordinates];
}
}

- (void)setCoordinates:(NSArray<AIRMapCoordinate _> _)coordinates {
  \_coordinates = coordinates;
  CLLocationCoordinate2D \*coords = calloc(coordinates.count, sizeof(CLLocationCoordinate2D));
  for(int i = 0; i < coordinates.count; i++)
  {
  coords[i] = coordinates[i].coordinate;
  }
  if(\_geodesic){
  self.polyline = [MKGeodesicPolyline polylineWithCoordinates:coords count:coordinates.count];
  } else {
  self.polyline = [MKPolyline polylineWithCoordinates:coords count:coordinates.count];
  }
  free(coords);

      self.renderer = [self createRenderer];
      [self update];

  }

- (MKOverlayPathRenderer\*)createRenderer {
  if (self.polyline == nil) return nil;
  if (self.strokeColors == nil) {
  // Use the default renderer when no array of stroke-colors is defined.
  // This behaviour may be changed in the future if we permanently want to
  // use the custom renderer, because it can add funtionality that is not
  // supported by the default renderer.
  return [[MKPolylineRenderer alloc] initWithPolyline:self.polyline];
  }
  else {
  return [[AIRMapPolylineRenderer alloc] initWithOverlay:self polyline:self.polyline];
  }
  }

- (void) update
  {
  if (!\_renderer) return;
  [self updateRenderer:_renderer];

      if (_map == nil) return;
      [_map removeOverlay:self];
      [_map addOverlay:self];

  }

- (void) updateRenderer:(MKOverlayPathRenderer\*)renderer {
  renderer.fillColor = \_fillColor;
  renderer.strokeColor = \_strokeColor;
  renderer.lineWidth = \_strokeWidth;
  renderer.lineCap = \_lineCap;
  renderer.lineJoin = \_lineJoin;
  renderer.miterLimit = \_miterLimit;
  renderer.lineDashPhase = \_lineDashPhase;
  renderer.lineDashPattern = \_lineDashPattern;
      if ([renderer isKindOfClass:[AIRMapPolylineRenderer class]]) {
          ((AIRMapPolylineRenderer*)renderer).strokeColors = _strokeColors;
      }
  }

#pragma mark MKOverlay implementation

- (CLLocationCoordinate2D) coordinate
  {
  return self.polyline.coordinate;
  }

- (MKMapRect) boundingMapRect
  {
  return self.polyline.boundingMapRect;
  }

- (BOOL)intersectsMapRect:(MKMapRect)mapRect
  {
  BOOL answer = [self.polyline intersectsMapRect:mapRect];
  return answer;
  }

- (BOOL)canReplaceMapContent
  {
  return NO;
  }

#pragma mark AIRMapSnapshot implementation

- (void) drawToSnapshot:(MKMapSnapshot _) snapshot context:(CGContextRef) context
  {
  AIRMapPolylineRenderer_ renderer = [[AIRMapPolylineRenderer alloc] initWithSnapshot:snapshot overlay:self polyline:self.polyline];
  [self updateRenderer:renderer];
  [renderer drawWithZoomScale:2 inContext:context];
  }

@end
</file>

<file path="ios/AirMaps/AIRMapPolylineManager.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <React/RCTViewManager.h>

@interface AIRMapPolylineManager : RCTViewManager
@end
</file>

<file path="ios/AirMaps/AIRMapPolylineManager.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRMapPolylineManager.h"

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "RCTConvert+AirMap.h"
#import "AIRMapMarker.h"
#import "AIRMapPolyline.h"

@interface AIRMapPolylineManager()

@end

@implementation AIRMapPolylineManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapPolyline *polyline = [AIRMapPolyline new];
  return polyline;
  }

RCT_EXPORT_VIEW_PROPERTY(coordinates, AIRMapCoordinateArray)
RCT_EXPORT_VIEW_PROPERTY(strokeColor, UIColor)
RCT_EXPORT_VIEW_PROPERTY(strokeColors, UIColorArray)
RCT_EXPORT_VIEW_PROPERTY(strokeWidth, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineCap, CGLineCap)
RCT_EXPORT_VIEW_PROPERTY(lineJoin, CGLineJoin)
RCT_EXPORT_VIEW_PROPERTY(miterLimit, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineDashPhase, CGFloat)
RCT_EXPORT_VIEW_PROPERTY(lineDashPattern, NSArray)
RCT_EXPORT_VIEW_PROPERTY(geodesic, BOOL)
RCT_EXPORT_VIEW_PROPERTY(onPress, RCTBubblingEventBlock)

@end
</file>

<file path="ios/AirMaps/AIRMapPolylineRenderer.h">
//
//  AIRMapPolylineRenderer.h
//  mapDemo
//
//  Created by IjzerenHein on 13-11-21.
//  Copyright (c) 2017 IjzerenHein. All rights reserved.
//

#import <MapKit/MapKit.h>

@interface AIRMapPolylineRenderer : MKOverlayPathRenderer

-(id)initWithOverlay:(id<MKOverlay>)overlay polyline:(MKPolyline*)polyline;
-(id)initWithSnapshot:(MKMapSnapshot*)snapshot overlay:(id<MKOverlay>)overlay polyline:(MKPolyline\*)polyline;
-(void)drawWithZoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context;

@property (nonatomic, strong) NSArray<UIColor *> *strokeColors;

@end
</file>

<file path="ios/AirMaps/AIRMapPolylineRenderer.m">
//
//  AIRMapPolylineRenderer.h
//  mapDemo
//
//  Created by IjzerenHein on 13-11-21.
//  Copyright (c) 2017 IjzerenHein. All rights reserved.
//

#import "AIRMapPolylineRenderer.h"

@interface AIRMapPolylineRendererSegment : NSObject

- (id)initWithPoint:(CGPoint)point color:(UIColor\*)color;
- (void) addPoint:(CGPoint)point color:(UIColor*)color;
  @property CGMutablePathRef path;
  @property UIColor *startColor;
  @property UIColor \*endColor;
  @property CGPoint startPoint;
  @property CGPoint endPoint;
  @end
  @implementation AIRMapPolylineRendererSegment
- (id)initWithPoint:(CGPoint)point color:(UIColor\*)color
  {
  self = [super init];
  if (self){
  self.path = CGPathCreateMutable();
  self.startColor = color;
  self.startPoint = point;
  self.endPoint = point;
  CGPathMoveToPoint(self.path, nil, point.x, point.y);
  }
  return self;
  }
- (void) addPoint:(CGPoint)point color:(UIColor\*)color
  {
  self.endPoint = point;
  self.endColor = color;
  CGPathAddLineToPoint(self.path, nil, point.x, point.y);
  }
  @end

@implementation AIRMapPolylineRenderer {
MKPolyline* \_polyline;
NSArray<UIColor *> _\_strokeColors;
MKMapSnapshot_ \_snapshot;
CLLocationCoordinate2D\* \_coordinates;
}

@synthesize strokeColors;

- (id)initWithOverlay:(id<MKOverlay>)overlay polyline:(MKPolyline\*)polyline
  {
  self = [super initWithOverlay:overlay];
  if (self){
  \_polyline = polyline;
  [self createPath];
  }
  return self;
  }

- (id)initWithSnapshot:(MKMapSnapshot*)snapshot overlay:(id<MKOverlay>)overlay polyline:(MKPolyline*)polyline
  {
  self = [super initWithOverlay:overlay];
  if (self){
  \_snapshot = snapshot;
  \_polyline = polyline;
  \_coordinates = malloc(sizeof(CLLocationCoordinate2D) \* [_polyline pointCount]);
  [\_polyline getCoordinates:\_coordinates range:NSMakeRange(0, [_polyline pointCount])];
  }
  return self;
  }

- (void) dealloc
  {
  if (\_coordinates) free(\_coordinates);
  }

- (CGPoint) pointForIndex:(NSUInteger)index
  {
  if (\_snapshot != nil) {
  return [\_snapshot pointForCoordinate:\_coordinates[index]];
  }
  else {
  return [self pointForMapPoint:\_polyline.points[index]];
  }
  }

- (UIColor*) colorForIndex:(NSUInteger)index
  {
  if ((\_strokeColors == nil) || !\_strokeColors.count) return self.strokeColor;
  index = MIN(index, \_strokeColors.count - 1);
  UIColor* color = \_strokeColors[index];
  CGFloat pc_r,pc_g,pc_b,pc_a;
  [color getRed:&pc_r green:&pc_g blue:&pc_b alpha:&pc_a];
  return (pc_a == 0) ? nil : color;
  }

- (void) createPath
  {
  CGMutablePathRef path = CGPathCreateMutable();
  BOOL first = YES;
  for (NSUInteger i = 0, n = \_polyline.pointCount; i < n; i++){
  CGPoint point = [self pointForIndex:i];
  if (first) {
  CGPathMoveToPoint(path, nil, point.x, point.y);
  first = NO;
  } else {
  CGPathAddLineToPoint(path, nil, point.x, point.y);
  }
  }
  self.path = path;
  }

- (NSArray*) createSegments
  {
  NSMutableArray* segments = [NSMutableArray new];
  if (\_polyline.pointCount <= 1) return segments;
  AIRMapPolylineRendererSegment* segment = nil;
  for (NSUInteger i = 0, n = \_polyline.pointCount; i < n; i++){
  CGPoint point = [self pointForIndex:i];
  UIColor* color = [self colorForIndex:i];
  if (segment == nil) {

              // Start new segment
              segment = [[AIRMapPolylineRendererSegment alloc] initWithPoint:point color:color];
              [segments addObject:segment];
          }
          else if (((color == nil) && (segment.endColor == nil)) ||
                   ((color != nil) && [segment.startColor isEqual:color])) {

              // Append point to segment
              [segment addPoint:point color: color];
          }
          else {

              // Close the last segment if needed
              if (segment.endColor == nil) {
                  [segment addPoint:point color:color];
              }
              else {

                  // Add transition gradient
                  segment = [[AIRMapPolylineRendererSegment alloc] initWithPoint:segment.endPoint color:segment.endColor];
                  [segment addPoint:point color:color];
                  [segments addObject:segment];
              }

              // Start new segment
              if (i < (n - 1)) {
                  segment = [[AIRMapPolylineRendererSegment alloc] initWithPoint:point color:color];
                  [segments addObject:segment];
              }
          }
      }

      // Remove last segment in case it only contains a single path point
      if ((segment != nil) && (segment.endColor == nil)) {
          [segments removeLastObject];
      }

      return segments;

  }

- (void) setStrokeColors:(NSArray<UIColor _> _)strokeColors
  {
  if (\_strokeColors != strokeColors) {
  \_strokeColors = strokeColors;
  }
  }

- (void) setStrokeColor:(UIColor \*)strokeColor
  {
  if (super.strokeColor != strokeColor) {
  super.strokeColor = strokeColor;
  }
  }

- (void) drawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context
  {
  CGRect pointsRect = CGPathGetBoundingBox(self.path);
  CGRect mapRectCG = [self rectForMapRect:mapRect];
  if (!CGRectIntersectsRect(pointsRect, mapRectCG)) return;

      [self drawWithZoomScale:zoomScale inContext:context];

  }

- (void) drawWithZoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context
  {
  CGFloat lineWidth = (self.lineWidth / zoomScale) \* 2.0;
  CGContextSetLineWidth(context, lineWidth);
  CGContextSetLineCap(context, self.lineCap);
  CGContextSetLineJoin(context, self.lineJoin);
  CGContextSetFillColorWithColor(context, self.fillColor.CGColor);
  CGContextSetMiterLimit(context, self.miterLimit);
  CGFloat dashes[self.lineDashPattern.count];
  for (NSUInteger i = 0; i < self.lineDashPattern.count; i++) {
  dashes[i] = self.lineDashPattern[i].floatValue;
  }
  CGContextSetLineDash(context, self.lineDashPhase, dashes, self.lineDashPattern.count);
      NSArray* segments = [self createSegments];
      for (NSUInteger i = 0, n = segments.count; i < n; i++) {
          AIRMapPolylineRendererSegment* segment = segments[i];

          CGContextBeginPath(context);
          CGContextAddPath(context, segment.path);

          // When segment has two colors, draw it as a gradient
          if (![segment.startColor isEqual:segment.endColor]) {
              CGFloat pc_r,pc_g,pc_b,pc_a,
              cc_r,cc_g,cc_b,cc_a;
              [segment.startColor getRed:&pc_r green:&pc_g blue:&pc_b alpha:&pc_a];
              [segment.endColor getRed:&cc_r green:&cc_g blue:&cc_b alpha:&cc_a];
              CGFloat gradientColors[8] = {pc_r,pc_g,pc_b,pc_a,
                  cc_r,cc_g,cc_b,cc_a};
              CGFloat gradientLocation[2] = {0,1};
              CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
              CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, gradientColors, gradientLocation, 2);
              CGColorSpaceRelease(colorSpace);

              CGContextReplacePathWithStrokedPath(context);
              CGContextClip(context);
              CGContextDrawLinearGradient(
                                          context,
                                          gradient,
                                          segment.startPoint,
                                          segment.endPoint,
                                          kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation
                                          );
              CGGradientRelease(gradient);
              CGContextResetClip(context);
          }
          else {
              CGContextSetStrokeColorWithColor(context, segment.startColor.CGColor);
              CGContextStrokePath(context);
          }
      }
  }

@end
</file>

<file path="ios/AirMaps/AIRMapSnapshot.h">
//
//  AIRMapSnapshot.h
//  AirMaps
//
//  Created by Hein Rutjes on 26/09/16.
//  Copyright  2016 Christopher. All rights reserved.
//

#ifndef AIRMapSnapshot_h
#define AIRMapSnapshot_h

@protocol AIRMapSnapshot <NSObject>
@optional

- (void) drawToSnapshot:(MKMapSnapshot \*) snapshot context:(CGContextRef) context;
  @end

#endif /_ AIRMapSnapshot_h _/
</file>

<file path="ios/AirMaps/AIRMapUrlTile.h">
//
//  AIRUrlTileOverlay.h
//  AirMaps
//
//  Created by cascadian on 3/19/16.
//  Copyright  2016. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import <React/RCTComponent.h>
#import <React/RCTView.h>
#import "AIRMapCoordinate.h"
#import "AIRMap.h"
#import "RCTConvert+AirMap.h"
#import "AIRMapUrlTileCachedOverlay.h"

@interface AIRMapUrlTile : MKAnnotationView <MKOverlay> {
BOOL \_urlTemplateSet;
BOOL \_tileSizeSet;
BOOL \_flipYSet;
BOOL \_tileCachePathSet;
BOOL \_tileCacheMaxAgeSet;
BOOL \_maximumNativeZSet;
BOOL \_cachedOverlayCreated;
BOOL \_opacitySet;
}

@property (nonatomic, weak) AIRMap \*map;

@property (nonatomic, strong) AIRMapUrlTileCachedOverlay *tileOverlay;
@property (nonatomic, strong) MKTileOverlayRenderer *renderer;
@property (nonatomic, copy) NSString *urlTemplate;
@property NSInteger maximumZ;
@property NSInteger maximumNativeZ;
@property NSInteger minimumZ;
@property BOOL flipY;
@property BOOL shouldReplaceMapContent;
@property NSInteger tileSize;
@property (nonatomic, copy) NSString *tileCachePath;
@property NSInteger tileCacheMaxAge;
@property BOOL offlineMode;
@property CGFloat opacity;

- (void)updateProperties;
- (void)update;

#pragma mark MKOverlay protocol

@property(nonatomic, readonly) CLLocationCoordinate2D coordinate;
@property(nonatomic, readonly) MKMapRect boundingMapRect;
//- (BOOL)intersectsMapRect:(MKMapRect)mapRect;

- (BOOL)canReplaceMapContent;

@end
</file>

<file path="ios/AirMaps/AIRMapUrlTile.m">
//
//  AIRUrlTileOverlay.m
//  AirMaps
//
//  Created by cascadian on 3/19/16.
//  Copyright  2016. All rights reserved.
//

#import "AIRMapUrlTile.h"
#import <React/UIView+React.h>
#import "AIRMapUrlTileCachedOverlay.h"

@implementation AIRMapUrlTile

- (void)setShouldReplaceMapContent:(BOOL)shouldReplaceMapContent
  {
  \_shouldReplaceMapContent = shouldReplaceMapContent;
  if (self.tileOverlay) {
  self.tileOverlay.canReplaceMapContent = \_shouldReplaceMapContent;
  }
  [self update];
  }

- (void)setMaximumZ:(NSInteger)maximumZ
  {
  \_maximumZ = maximumZ;
  if (self.tileOverlay) {
  self.tileOverlay.maximumZ = \_maximumZ;
  }
  [self update];
  }

- (void)setMaximumNativeZ:(NSInteger)maximumNativeZ
  {
  \_maximumNativeZ = maximumNativeZ;
  \_maximumNativeZSet = YES;
  if (\_cachedOverlayCreated) {
  self.tileOverlay.maximumNativeZ = \_maximumNativeZ;
  } else {
  [self createTileOverlayAndRendererIfPossible];
  }
  [self update];
  }

- (void)setMinimumZ:(NSInteger)minimumZ
  {
  \_minimumZ = minimumZ;
  if (self.tileOverlay) {
  self.tileOverlay.minimumZ = \_minimumZ;
  }
  [self update];
  }

- (void)setFlipY:(BOOL)flipY
  {
  \_flipY = flipY;
  \_flipYSet = YES;
  if (self.tileOverlay) {
  self.tileOverlay.geometryFlipped = \_flipY;
  }
  [self update];
  }

- (void)setUrlTemplate:(NSString \*)urlTemplate
  {
  \_urlTemplate = urlTemplate;
  \_urlTemplateSet = YES;
  [self createTileOverlayAndRendererIfPossible];
  [self update];
  }

- (void)setTileSize:(NSInteger)tileSize
  {
  \_tileSize = tileSize;
  \_tileSizeSet = YES;
  [self createTileOverlayAndRendererIfPossible];
  [self update];
  }

- (void)setTileCachePath:(NSString \*)tileCachePath{
  if (!tileCachePath) return;
  \_tileCachePath = tileCachePath;
  \_tileCachePathSet = YES;
  [self createTileOverlayAndRendererIfPossible];
  [self update];
  }

- (void)setTileCacheMaxAge:(NSInteger)tileCacheMaxAge{
  \_tileCacheMaxAge = tileCacheMaxAge;
  \_tileCacheMaxAgeSet = YES;
  if (\_cachedOverlayCreated) {
  self.tileOverlay.tileCacheMaxAge = \_tileCacheMaxAge;
  } else {
  [self createTileOverlayAndRendererIfPossible];
  }
  [self update];
  }

- (void)setOfflineMode:(BOOL)offlineMode
  {
  \_offlineMode = offlineMode;
  if (\_cachedOverlayCreated) {
  self.tileOverlay.offlineMode = \_offlineMode;
  }
  if (self.renderer) [self.renderer reloadData];
  }

- (void)setOpacity:(CGFloat)opacity
  {
  \_opacity = opacity;
  \_opacitySet = YES;
  if (self.renderer) {
  self.renderer.alpha = opacity;
  } else {
  [self createTileOverlayAndRendererIfPossible];
  }
  [self update];
  }

- (void)createTileOverlayAndRendererIfPossible
  {
  if (!\_urlTemplateSet) return;
  if (\_tileCachePathSet || \_maximumNativeZSet) {
  NSLog(@"tileCache dir %@", \_tileCachePath);
  self.tileOverlay = [[AIRMapUrlTileCachedOverlay alloc] initWithURLTemplate:self.urlTemplate];
        _cachedOverlayCreated = YES;
        if (_tileCachePathSet) {
            NSURL *urlPath = [NSURL URLWithString:[self.tileCachePath stringByAppendingString:@"/"]];
  if (urlPath.fileURL) {
  self.tileOverlay.tileCachePath = urlPath;
  } else {
  NSURL \*filePath = [NSURL fileURLWithPath:self.tileCachePath isDirectory:YES];
  self.tileOverlay.tileCachePath = filePath;
  }

              if (_tileCacheMaxAgeSet) {
                  self.tileOverlay.tileCacheMaxAge = self.tileCacheMaxAge;
              }
          }
      } else {
          NSLog(@"tileCache normal overlay");
          self.tileOverlay = [[MKTileOverlay alloc] initWithURLTemplate:self.urlTemplate];
          _cachedOverlayCreated = NO;
      }

      [self updateProperties];

      self.renderer = [[MKTileOverlayRenderer alloc] initWithTileOverlay:self.tileOverlay];
      if (_opacitySet) {
          self.renderer.alpha = self.opacity;
      }

  }

- (void)updateProperties
  {
  self.tileOverlay.canReplaceMapContent = self.shouldReplaceMapContent;

      if(self.minimumZ) {
          self.tileOverlay.minimumZ = self.minimumZ;
      }
      if (self.maximumZ) {
          self.tileOverlay.maximumZ = self.maximumZ;
      }
      if (_cachedOverlayCreated && self.maximumNativeZ) {
          self.tileOverlay.maximumNativeZ = self.maximumNativeZ;
      }
      if (_flipYSet) {
          self.tileOverlay.geometryFlipped = self.flipY;
      }
      if (_tileSizeSet) {
          self.tileOverlay.tileSize = CGSizeMake(self.tileSize, self.tileSize);
      }
      if (_cachedOverlayCreated && self.offlineMode) {
          self.tileOverlay.offlineMode = self.offlineMode;
      }

  }

- (void)update
  {
  if (!\_renderer) return;
      if (_map == nil) return;
      [_map removeOverlay:self];
      [_map addOverlay:self level:MKOverlayLevelAboveLabels];
      for (id<MKOverlay> overlay in _map.overlays) {
          if ([overlay isKindOfClass:[AIRMapUrlTile class]]) {
              continue;
          }
          [_map removeOverlay:overlay];
          [_map addOverlay:overlay];
      }
  }

#pragma mark MKOverlay implementation

- (CLLocationCoordinate2D)coordinate
  {
  return self.tileOverlay.coordinate;
  }

- (MKMapRect)boundingMapRect
  {
  return self.tileOverlay.boundingMapRect;
  }

- (BOOL)canReplaceMapContent
  {
  return self.tileOverlay.canReplaceMapContent;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapUrlTileCachedOverlay.h">
//
//  AIRMapUrlTileCachedOverlay.h
//  Airmaps
//
//  Created by Markus Suomi on 10/04/2021.
//

#import <MapKit/MapKit.h>

@interface AIRMapUrlTileCachedOverlay : MKTileOverlay

@property NSInteger maximumNativeZ;
@property (nonatomic, copy) NSURL \*tileCachePath;
@property NSInteger tileCacheMaxAge;
@property BOOL offlineMode;

@end
</file>

<file path="ios/AirMaps/AIRMapUrlTileCachedOverlay.m">
//
//  AIRMapUrlTileCachedOverlay.m
//  Airmaps
//
//  Created by Markus Suomi on 10/04/2021.
//

#import "AIRMapUrlTileCachedOverlay.h"

@interface AIRMapUrlTileCachedOverlay ()

@end

@implementation AIRMapUrlTileCachedOverlay {
CIContext _\_ciContext;
CGColorSpaceRef \_colorspace;
NSURLSession _\_urlSession;
}

- (void)loadTileAtPath:(MKTileOverlayPath)path result:(void (^)(NSData _, NSError _))result
  {
  if (!result) return;

      NSInteger maximumZ = self.maximumNativeZ ? self.maximumNativeZ : path.z;
      [self scaleIfNeededLowerZoomTile:path maximumZ:maximumZ result:^(NSData *image, NSError *error) {
          if (!image && self.offlineMode && self.tileCachePath) {
              NSInteger zoomLevelToStart = (path.z > maximumZ) ? maximumZ - 1 : path.z - 1;
              NSInteger minimumZoomToSearch = self.minimumZ >= zoomLevelToStart - 3 ? self.minimumZ : zoomLevelToStart - 3;
              [self findLowerZoomTileAndScale:path tryZ:zoomLevelToStart minZ:minimumZoomToSearch result:result];
          } else {
              result(image, error);
          }
      }];

  }

- (void)scaleIfNeededLowerZoomTile:(MKTileOverlayPath)path maximumZ:(NSInteger)maximumZ result:(void (^)(NSData _, NSError _))result
  {
  NSInteger overZoomLevel = path.z - maximumZ;
  if (overZoomLevel <= 0) {
  [self getTileImage:path result:result];
  return;
  }

      NSInteger zoomFactor = 1 << overZoomLevel;

      MKTileOverlayPath parentTile;
      parentTile.x = path.x >> overZoomLevel;
      parentTile.y = path.y >> overZoomLevel;
      parentTile.z = path.z - overZoomLevel;
      parentTile.contentScaleFactor = path.contentScaleFactor;

      NSInteger xOffset = path.x % zoomFactor;
      NSInteger yOffset = path.y % zoomFactor;
      NSInteger subTileSize = self.tileSize.width / zoomFactor;

      if (!_ciContext) _ciContext = [CIContext context];
      if (!_colorspace) _colorspace = CGColorSpaceCreateDeviceRGB();

      [self getTileImage:parentTile result:^(NSData *image, NSError *error) {
          if (!image) {
              result(nil, nil);
              return;
          }

          CIImage* originalCIImage = [CIImage imageWithData:image];

          CGRect rect;
          rect.origin.x = xOffset * subTileSize;
          rect.origin.y = self.tileSize.width - (yOffset + 1) * subTileSize;
          rect.size.width = subTileSize;
          rect.size.height = subTileSize;
          CIVector *inputRect = [CIVector vectorWithCGRect:rect];
          CIFilter* cropFilter = [CIFilter filterWithName:@"CICrop"];
          [cropFilter setValue:originalCIImage forKey:@"inputImage"];
          [cropFilter setValue:inputRect forKey:@"inputRectangle"];

          CGAffineTransform trans = CGAffineTransformMakeScale(zoomFactor, zoomFactor);
          CIImage* scaledCIImage = [cropFilter.outputImage imageByApplyingTransform:trans];

          NSData *finalImage = [_ciContext PNGRepresentationOfImage:scaledCIImage format:kCIFormatABGR8 colorSpace:_colorspace options:nil];
          result(finalImage, nil);
      }];

  }

- (void)findLowerZoomTileAndScale:(MKTileOverlayPath)path tryZ:(NSInteger)tryZ minZ:(NSInteger)minZ result:(void (^)(NSData _, NSError _))result
  {
  [self scaleIfNeededLowerZoomTile:path maximumZ:tryZ result:^(NSData *image, NSError *error) {
  if (image) {
  result(image, error);
  } else if (tryZ >= minZ) {
  [self findLowerZoomTileAndScale:path tryZ:tryZ - 1 minZ:minZ result:result];
  } else {
  result(nil, nil);
  }
  }];
  }

- (void)getTileImage:(MKTileOverlayPath)path result:(void (^)(NSData _, NSError _))result
  {
  NSData *image;
  NSURL *tileCacheFileDirectory = [NSURL URLWithString:[NSString stringWithFormat:@"%d/%d/", (int)path.z, (int)path.x] relativeToURL:self.tileCachePath];
  NSURL \*tileCacheFilePath = [NSURL URLWithString:[NSString stringWithFormat:@"%d", (int)path.y] relativeToURL:tileCacheFileDirectory];

      if (self.tileCachePath) {
          image = [self readTileImage:path fromFilePath:tileCacheFilePath];
          if (image) {
              result(image, nil);
              if (!self.offlineMode && self.tileCacheMaxAge) {
                  [self checkForRefresh:path fromFilePath:tileCacheFilePath];
              }
          }
      }

      if (!image) {
          if (!self.offlineMode) {
              [self fetchTile:path result:^(NSData *image, NSError *error) {
                  result(image, error);
                  if (image && self.tileCachePath) {
                      [self writeTileImage:tileCacheFileDirectory withTileCacheFilePath:tileCacheFilePath withTileData:image];
                  }
              }];
          } else {
              result(nil, nil);
          }
      }

  }

- (NSData _)readTileImage:(MKTileOverlayPath)path fromFilePath:(NSURL _)tileCacheFilePath
  {
  NSError \*error;

      if ([[NSFileManager defaultManager] fileExistsAtPath:[tileCacheFilePath path]]) {
          if (!self.tileCacheMaxAge) {
              [[NSFileManager defaultManager] setAttributes:@{NSFileModificationDate:[NSDate date]}
                              ofItemAtPath:[tileCacheFilePath path]
                                      error:&error];
          }

          NSData *tile = [NSData dataWithContentsOfFile:[tileCacheFilePath path]];
          NSLog(@"tileCache HIT for %d_%d_%d", (int)path.z, (int)path.x, (int)path.y);
          NSLog(@"tileCache HIT, with max age set at %d", self.tileCacheMaxAge);
          return tile;
      } else {
          NSLog(@"tileCache MISS for %d_%d_%d", (int)path.z, (int)path.x, (int)path.y);
          return nil;
      }

  }

- (void)fetchTile:(MKTileOverlayPath)path result:(void (^)(NSData _, NSError _))result
  {
  if (!\_urlSession) [self createURLSession];

      [[_urlSession dataTaskWithURL:[self URLForTilePath:path]
          completionHandler:^(NSData *data,
                              NSURLResponse *response,
                              NSError *error) {
              result(data, error);
          }] resume];

  }

- (void)writeTileImage:(NSURL _)tileCacheFileDirectory withTileCacheFilePath:(NSURL _)tileCacheFilePath withTileData:(NSData *)data
  {
  NSError *error;

      if (![[NSFileManager defaultManager] fileExistsAtPath:[tileCacheFileDirectory path]]) {
          [[NSFileManager defaultManager] createDirectoryAtPath:[tileCacheFileDirectory path] withIntermediateDirectories:YES attributes:nil error:&error];
          if (error) {
              NSLog(@"Error: %@", error);
              return;
          }
      }

      [[NSFileManager defaultManager] createFileAtPath:[tileCacheFilePath path] contents:data attributes:nil];
      NSLog(@"tileCache SAVED tile %@", [tileCacheFilePath path]);

  }

- (void)createTileCacheDirectory
  {
  NSError *error;
  NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
  NSString *documentsDirectory = [paths objectAtIndex:0];
  NSString *tileCacheBaseDirectory = [NSString stringWithFormat:@"%@/tileCache", documentsDirectory];
  self.tileCachePath = [NSURL fileURLWithPath:tileCacheBaseDirectory isDirectory:YES];

      if (![[NSFileManager defaultManager] fileExistsAtPath:[self.tileCachePath path]])
          [[NSFileManager defaultManager] createDirectoryAtPath:[self.tileCachePath path] withIntermediateDirectories:NO attributes:nil error:&error];

  }

- (void)createURLSession
  {
  if (!\_urlSession) {
  \_urlSession = [NSURLSession sharedSession];
  }
  }

- (void)checkForRefresh:(MKTileOverlayPath)path fromFilePath:(NSURL \*)tileCacheFilePath
  {
  if ([self doesFileNeedRefresh:path fromFilePath:tileCacheFilePath withMaxAge:self.tileCacheMaxAge]) {
  dispatch_async(dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^ {
  // This code runs asynchronously!
  if ([self doesFileNeedRefresh:path fromFilePath:tileCacheFilePath withMaxAge:self.tileCacheMaxAge]) {
  if (!\_urlSession) [self createURLSession];

                  [[_urlSession dataTaskWithURL:[self URLForTilePath:path]
                      completionHandler:^(NSData *data,
                                          NSURLResponse *response,
                                          NSError *error) {
                      if (!error) {
                          [[NSFileManager defaultManager] createFileAtPath:[tileCacheFilePath path] contents:data attributes:nil];
                          NSLog(@"tileCache File refreshed at %@", [tileCacheFilePath path]);
                      }
                  }] resume];
              }
          });
      }

  }

- (BOOL)doesFileNeedRefresh:(MKTileOverlayPath)path fromFilePath:(NSURL *)tileCacheFilePath withMaxAge:(NSInteger)tileCacheMaxAge
  {
  NSError *error;
  NSDictionary<NSFileAttributeKey, id> \*fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:[tileCacheFilePath path] error:&error];

      if (fileAttributes) {
          NSDate *modificationDate = fileAttributes[@"NSFileModificationDate"];
          if (modificationDate) {
              if (-1 * (int)modificationDate.timeIntervalSinceNow > tileCacheMaxAge) {
                  return YES;
              }
          }
      }

      return NO;

  }

@end
</file>

<file path="ios/AirMaps/AIRMapUrlTileManager.h">
//
//  AIRMapUrlTileManager.h
//  AirMaps
//
//  Created by cascadian on 3/19/16.
//  Copyright  2016. All rights reserved.
//

#import <React/RCTViewManager.h>

@interface AIRMapUrlTileManager : RCTViewManager

@end
</file>

<file path="ios/AirMaps/AIRMapUrlTileManager.m">
//
//  AIRMapUrlTileManager.m
//  AirMaps
//
//  Created by cascadian on 3/19/16.
//  Copyright  2016. All rights reserved.
//

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "AIRMapMarker.h"
#import "AIRMapUrlTile.h"

#import "AIRMapUrlTileManager.h"

@interface AIRMapUrlTileManager()

@end

@implementation AIRMapUrlTileManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapUrlTile *tile = [AIRMapUrlTile new];
  return tile;
  }

RCT_EXPORT_VIEW_PROPERTY(urlTemplate, NSString)
RCT_EXPORT_VIEW_PROPERTY(maximumZ, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(maximumNativeZ, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(minimumZ, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(flipY, BOOL)
RCT_EXPORT_VIEW_PROPERTY(shouldReplaceMapContent, BOOL)
RCT_EXPORT_VIEW_PROPERTY(tileSize, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(tileCachePath, NSString)
RCT_EXPORT_VIEW_PROPERTY(tileCacheMaxAge, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(offlineMode, BOOL)
RCT_EXPORT_VIEW_PROPERTY(opacity, CGFloat)

@end
</file>

<file path="ios/AirMaps/AIRMapWMSTile.h">
//
//  AIRMapWMSTile.h
//  AirMaps
//
//  Created by nizam on 10/28/18.
//  Copyright  2018. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <MapKit/MapKit.h>
#import <UIKit/UIKit.h>

#import <React/RCTComponent.h>
#import <React/RCTView.h>
#import "AIRMapCoordinate.h"
#import "AIRMap.h"
#import "RCTConvert+AirMap.h"
#import "AIRMapUrlTile.h"
#import "AIRMapUrlTileCachedOverlay.h"

@interface AIRMapWMSTile : AIRMapUrlTile <MKOverlay>
@end

@interface AIRMapWMSTileOverlay : MKTileOverlay
@end

@interface AIRMapWMSTileCachedOverlay : AIRMapUrlTileCachedOverlay
@end

@interface AIRMapWMSTileHelper : NSObject

- (NSURL _)URLForTilePath:(MKTileOverlayPath)path withURLTemplate:(NSString _)URLTemplate withTileSize:(NSInteger)tileSize;

@end
</file>

<file path="ios/AirMaps/AIRMapWMSTile.m">
//
//  AIRMapWMSTile.m
//  AirMaps
//
//  Created by nizam on 10/28/18.
//  Copyright  2018. All rights reserved.
//

#import "AIRMapWMSTile.h"
#import <React/UIView+React.h>

@implementation AIRMapWMSTile

- (void)createTileOverlayAndRendererIfPossible
  {
  if (!\_urlTemplateSet) return;
  if (\_tileCachePathSet || \_maximumNativeZSet) {
  NSLog(@"tileCache new overlay dir %@", self.tileCachePath);
  NSLog(@"tileCache %d", \_tileCachePathSet);
  NSLog(@"tileCache %d", \_maximumNativeZSet);
  self.tileOverlay = [[AIRMapWMSTileCachedOverlay alloc] initWithURLTemplate:self.urlTemplate];
        _cachedOverlayCreated = YES;
        if (_tileCachePathSet) {
            NSURL *urlPath = [NSURL URLWithString:[self.tileCachePath stringByAppendingString:@"/"]];
  if (urlPath.fileURL) {
  self.tileOverlay.tileCachePath = urlPath;
  } else {
  NSURL \*filePath = [NSURL fileURLWithPath:self.tileCachePath isDirectory:YES];
  self.tileOverlay.tileCachePath = filePath;
  }

              if (_tileCacheMaxAgeSet) {
                  self.tileOverlay.tileCacheMaxAge = self.tileCacheMaxAge;
              }
          }
      } else {
          NSLog(@"tileCache normal overlay");
          self.tileOverlay = [[AIRMapWMSTileOverlay alloc] initWithURLTemplate:self.urlTemplate];
          _cachedOverlayCreated = NO;
      }

      [self updateProperties];

      self.renderer = [[MKTileOverlayRenderer alloc] initWithTileOverlay:self.tileOverlay];
      if (_opacitySet) {
          self.renderer.alpha = self.opacity;
      }

  }

@end

@implementation AIRMapWMSTileOverlay

- (id)initWithURLTemplate:(NSString \*)URLTemplate
  {
  self = [super initWithURLTemplate:URLTemplate];
  return self;
  }

- (NSURL \*)URLForTilePath:(MKTileOverlayPath)path
  {
  return [AIRMapWMSTileHelper URLForTilePath:path withURLTemplate:self.URLTemplate withTileSize:self.tileSize.width];
  }

@end

@implementation AIRMapWMSTileCachedOverlay

- (id)initWithURLTemplate:(NSString \*)URLTemplate
  {
  self = [super initWithURLTemplate:URLTemplate];
  return self;
  }

- (NSURL \*)URLForTilePath:(MKTileOverlayPath)path
  {
  return [AIRMapWMSTileHelper URLForTilePath:path withURLTemplate:self.URLTemplate withTileSize:self.tileSize.width];
  }

@end

@implementation AIRMapWMSTileHelper

- (NSURL _)URLForTilePath:(MKTileOverlayPath)path withURLTemplate:(NSString _)URLTemplate withTileSize:(NSInteger)tileSize
  {
  NSArray *bb = [self getBoundBox:path.x yAxis:path.y zoom:path.z];
  NSMutableString *url = [URLTemplate mutableCopy];
  [url replaceOccurrencesOfString: @"{minX}" withString:[NSString stringWithFormat:@"%@", bb[0]] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{minY}" withString:[NSString stringWithFormat:@"%@", bb[1]] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{maxX}" withString:[NSString stringWithFormat:@"%@", bb[2]] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{maxY}" withString:[NSString stringWithFormat:@"%@", bb[3]] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{width}" withString:[NSString stringWithFormat:@"%d", (int)tileSize] options:0 range:NSMakeRange(0, url.length)];
  [url replaceOccurrencesOfString: @"{height}" withString:[NSString stringWithFormat:@"%d", (int)tileSize] options:0 range:NSMakeRange(0, url.length)];
  return [NSURL URLWithString:url];
  }

- (NSArray _)getBoundBox:(NSInteger)x yAxis:(NSInteger)y zoom:(NSInteger)zoom
  {
  double MapX = -20037508.34789244;
  double MapY = 20037508.34789244;
  double FULL = 20037508.34789244 _ 2;
  double tile = FULL / pow(2.0, (double)zoom);
      NSArray *result  =[[NSArray alloc] initWithObjects:
                         [NSNumber numberWithDouble:MapX + (double)x * tile],
                         [NSNumber numberWithDouble:MapY - (double)(y + 1) * tile],
                         [NSNumber numberWithDouble:MapX + (double)(x + 1) * tile],
                         [NSNumber numberWithDouble:MapY - (double)y * tile],
                         nil];

      return result;
  }

@end
</file>

<file path="ios/AirMaps/AIRMapWMSTileManager.h">
//
//  AIRMapWMSTileManager.h
//  AirMaps
//
//  Created by nizam on 10/28/18.
//  Copyright  2018. All rights reserved.
//

#import <React/RCTViewManager.h>

@interface AIRMapWMSTileManager : RCTViewManager

@end
</file>

<file path="ios/AirMaps/AIRMapWMSTileManager.m">
//
//  AIRMapWMSTileManager.m
//  AirMaps
//
//  Created by nizam on 10/28/18.
//  Copyright  2018. All rights reserved.
//

#import <React/RCTBridge.h>
#import <React/RCTConvert.h>
#import <React/RCTConvert+CoreLocation.h>
#import <React/RCTEventDispatcher.h>
#import <React/RCTViewManager.h>
#import <React/UIView+React.h>
#import "AIRMapMarker.h"
#import "AIRMapWMSTile.h"

#import "AIRMapWMSTileManager.h"

@interface AIRMapWMSTileManager()

@end

@implementation AIRMapWMSTileManager

RCT_EXPORT_MODULE()

- (UIView *)view
  {
  AIRMapWMSTile *tile = [AIRMapWMSTile new];
  return tile;
  }

RCT_EXPORT_VIEW_PROPERTY(urlTemplate, NSString)
RCT_EXPORT_VIEW_PROPERTY(maximumZ, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(maximumNativeZ, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(minimumZ, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(shouldReplaceMapContent, BOOL)
RCT_EXPORT_VIEW_PROPERTY(tileSize, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(tileCachePath, NSString)
RCT_EXPORT_VIEW_PROPERTY(tileCacheMaxAge, NSInteger)
RCT_EXPORT_VIEW_PROPERTY(offlineMode, BOOL)
RCT_EXPORT_VIEW_PROPERTY(opacity, CGFloat)

@end
</file>

<file path="ios/AirMaps/AIRWeakMapReference.h">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import <Foundation/Foundation.h>
#import "AIRMap.h"

NS_ASSUME_NONNULL_BEGIN

@interface AIRWeakMapReference : NSObject

@property (nonatomic, weak) AIRMap \*mapView;

- (instancetype)initWithMapView:(AIRMap \*)mapView;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="ios/AirMaps/AIRWeakMapReference.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRWeakMapReference.h"

@implementation AIRWeakMapReference

- (instancetype)initWithMapView:(AIRMap \*)mapView {
  self = [super init];
  if (self) {
  \_mapView = mapView;
  }
  return self;
  }

@end
</file>

<file path="ios/AirMaps/AIRWeakTimerReference.h">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface AIRWeakTimerReference : NSObject

- (instancetype)initWithTarget:(id)target andSelector:(SEL)selector;
- (void)timerDidFire:(NSTimer \*)timer;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="ios/AirMaps/AIRWeakTimerReference.m">
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#import "AIRWeakTimerReference.h"

@implementation AIRWeakTimerReference
{
\_\_weak NSObject \*\_target;
SEL \_selector;
}

- (instancetype)initWithTarget:(id)target andSelector:(SEL)selector {
  self = [super init];
  if (self) {
  \_target = target;
  \_selector = selector;
  }
  return self;
  }

- (void)timerDidFire:(NSTimer \*)timer
  {
  if(\_target)
  {
  [_target performSelector:_selector withObject:timer];
  }
  else
  {
  [timer invalidate];
  }
  }

@end
</file>

<file path="ios/AirMaps/RCTComponentData+Maps.h">
//
//  RCTComponentData+Maps.h
//  AirMaps
//
//  Created by Salah Ghanim on 24.12.23.
//  Copyright  2023 Christopher. All rights reserved.
//

#import <React/RCTComponentData.h>

@interface RCTComponentData (Maps)

@end
</file>

<file path="ios/AirMaps/RCTComponentData+Maps.m">
//
//  RCTComponentData+Maps.m
//  AirMaps
//
//  Created by Salah Ghanim on 24.12.23.
//  Copyright  2023 Christopher. All rights reserved.
//

#import "RCTComponentData+Maps.h"
#import <objc/runtime.h>
#import <Foundation/NSObjCRuntime.h>

@implementation RCTComponentData (Maps)

- (void) myCustom_setProps:(NSDictionary<NSString _, id> _)props forShadowView:(RCTShadowView \*)shadowView{
  // Pass initialProps to any manager that supports initialProps
  id manager = [self manager];
  if ([manager respondsToSelector:@selector(setInitialProps:)]) {
  [manager performSelector:@selector(setInitialProps:) withObject:props];
  }

      // Call the original method
      [self myCustom_setProps:props forShadowView:shadowView];

  }

* (void)load {
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
  Class class = [RCTComponentData class]; // Or the class where the method is defined

          SEL originalSelector = @selector(setProps:forShadowView:);
          SEL swizzledSelector = @selector(myCustom_setProps:forShadowView:);

          Method originalMethod = class_getInstanceMethod(class, originalSelector);
          Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

          BOOL didAddMethod = class_addMethod(class,
                                              originalSelector,
                                              method_getImplementation(swizzledMethod),
                                              method_getTypeEncoding(swizzledMethod));

          if (didAddMethod) {
              class_replaceMethod(class,
                                  swizzledSelector,
                                  method_getImplementation(originalMethod),
                                  method_getTypeEncoding(originalMethod));
          } else {
              method_exchangeImplementations(originalMethod, swizzledMethod);
          }
      });

  }

@end
</file>

<file path="ios/AirMaps/RCTConvert+AirMap.h">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import <CoreLocation/CoreLocation.h>
#import <MapKit/MapKit.h>
#import <React/RCTConvert.h>

@interface RCTConvert (AirMap)

- (MKCoordinateSpan)MKCoordinateSpan:(id)json;
- (MKCoordinateRegion)MKCoordinateRegion:(id)json;
- (MKMapCamera\*)MKMapCamera:(id)json;
- (MKMapCamera*)MKMapCameraWithDefaults:(id)json existingCamera:(MKMapCamera*)camera;
- (MKMapType)MKMapType:(id)json;

@end
</file>

<file path="ios/AirMaps/RCTConvert+AirMap.m">
//
// Created by Leland Richardson on 12/27/15.
// Copyright (c) 2015 Facebook. All rights reserved.
//

#import "RCTConvert+AirMap.h"

#import <React/RCTConvert+CoreLocation.h>
#import "AIRMapCoordinate.h"

@implementation RCTConvert (AirMap)

- (MKCoordinateSpan)MKCoordinateSpan:(id)json
  {
  json = [self NSDictionary:json];
  return (MKCoordinateSpan){
  [self CLLocationDegrees:json[@"latitudeDelta"]],
  [self CLLocationDegrees:json[@"longitudeDelta"]]
  };
  }

- (MKCoordinateRegion)MKCoordinateRegion:(id)json
  {
  return (MKCoordinateRegion){
  [self CLLocationCoordinate2D:json],
  [self MKCoordinateSpan:json]
  };
  }

- (MKMapCamera\*)MKMapCamera:(id)json
  {
  json = [self NSDictionary:json];
  return [RCTConvert MKMapCameraWithDefaults:json existingCamera:nil];
  }

- (MKMapCamera*)MKMapCameraWithDefaults:(id)json existingCamera:(MKMapCamera*)camera
  {
  json = [self NSDictionary:json];
  if (camera == nil) {
  camera = [[MKMapCamera alloc] init];
    } else {
        camera = [camera copy];
    }
    if (json[@"center"]) {
        camera.centerCoordinate = [self CLLocationCoordinate2D:json[@"center"]];
  }
  if (json[@"pitch"]) {
  camera.pitch = [self double:json[@"pitch"]];
  }
  if (json[@"altitude"]) {
  camera.altitude = [self double:json[@"altitude"]];
  }
  if (json[@"heading"]) {
  camera.heading = [self double:json[@"heading"]];
  }
  return camera;
  }

RCT_ENUM_CONVERTER(MKMapType, (@{
@"standard": @(MKMapTypeStandard),
@"satellite": @(MKMapTypeSatellite),
@"hybrid": @(MKMapTypeHybrid),
@"satelliteFlyover": @(MKMapTypeSatelliteFlyover),
@"hybridFlyover": @(MKMapTypeHybridFlyover),
@"mutedStandard": @(MKMapTypeMutedStandard)
}), MKMapTypeStandard, integerValue)

// NOTE(lmr):
// This is a bit of a hack, but I'm using this class to simply wrap
// around a `CLLocationCoordinate2D`, since I was unable to figure out
// how to handle an array of structs like CLLocationCoordinate2D. Would love
// to get rid of this if someone can show me how...

- (AIRMapCoordinate *)AIRMapCoordinate:(id)json
  {
  AIRMapCoordinate *coord = [AIRMapCoordinate new];
  coord.coordinate = [self CLLocationCoordinate2D:json];
  return coord;
  }

RCT_ARRAY_CONVERTER(AIRMapCoordinate)

- (NSArray<NSArray<AIRMapCoordinate _> _> \*)AIRMapCoordinateArrayArray:(id)json
  {
  return RCTConvertArrayValue(@selector(AIRMapCoordinateArray:), json);
  }

@end
</file>

<file path="ios/AirMaps.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 63;
	objects = {

/_ Begin PBXBuildFile section _/
1125B2DA1C4AD3DA007D0023 /_ AIRMap.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2BE1C4AD3DA007D0023 /_ AIRMap.m _/; };
1125B2DB1C4AD3DA007D0023 /_ AIRMapCallout.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2C01C4AD3DA007D0023 /_ AIRMapCallout.m _/; };
1125B2DC1C4AD3DA007D0023 /_ AIRMapCalloutManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2C21C4AD3DA007D0023 /_ AIRMapCalloutManager.m _/; };
1125B2DD1C4AD3DA007D0023 /_ AIRMapCircle.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2C41C4AD3DA007D0023 /_ AIRMapCircle.m _/; };
1125B2DE1C4AD3DA007D0023 /_ AIRMapCircleManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2C61C4AD3DA007D0023 /_ AIRMapCircleManager.m _/; };
1125B2DF1C4AD3DA007D0023 /_ AIRMapCoordinate.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2C81C4AD3DA007D0023 /_ AIRMapCoordinate.m _/; };
1125B2E01C4AD3DA007D0023 /_ AIRMapManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2CA1C4AD3DA007D0023 /_ AIRMapManager.m _/; };
1125B2E11C4AD3DA007D0023 /_ AIRMapMarker.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2CC1C4AD3DA007D0023 /_ AIRMapMarker.m _/; };
1125B2E21C4AD3DA007D0023 /_ AIRMapMarkerManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2CE1C4AD3DA007D0023 /_ AIRMapMarkerManager.m _/; };
1125B2E31C4AD3DA007D0023 /_ AIRMapPolygon.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2D01C4AD3DA007D0023 /_ AIRMapPolygon.m _/; };
1125B2E41C4AD3DA007D0023 /_ AIRMapPolygonManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2D21C4AD3DA007D0023 /_ AIRMapPolygonManager.m _/; };
1125B2E51C4AD3DA007D0023 /_ AIRMapPolyline.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2D41C4AD3DA007D0023 /_ AIRMapPolyline.m _/; };
1125B2E61C4AD3DA007D0023 /_ AIRMapPolylineManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2D61C4AD3DA007D0023 /_ AIRMapPolylineManager.m _/; };
1125B2F21C4AD445007D0023 /_ SMCalloutView.m in Sources _/ = {isa = PBXBuildFile; fileRef = 1125B2F11C4AD445007D0023 /_ SMCalloutView.m _/; };
19DABC7F1E7C9D3C00F41150 /_ RCTConvert+AirMap.m in Sources _/ = {isa = PBXBuildFile; fileRef = 19DABC7E1E7C9D3C00F41150 /_ RCTConvert+AirMap.m _/; };
2163AA501FEAEDD100BBEC95 /_ AIRMapPolylineRenderer.m in Sources _/ = {isa = PBXBuildFile; fileRef = 2163AA4F1FEAEDD100BBEC95 /_ AIRMapPolylineRenderer.m _/; };
4C99C9DE2226CF2800A8693E /_ AIRWeakTimerReference.m in Sources _/ = {isa = PBXBuildFile; fileRef = 4C99C9DD2226CF2800A8693E /_ AIRWeakTimerReference.m _/; };
4C99C9E12226D8C400A8693E /_ AIRWeakMapReference.m in Sources _/ = {isa = PBXBuildFile; fileRef = 4C99C9E02226D8C400A8693E /_ AIRWeakMapReference.m _/; };
4E0CFBDE2B388F2B0017E126 /_ RCTComponentData+Maps.m in Sources _/ = {isa = PBXBuildFile; fileRef = 4E0CFBDD2B388F2B0017E126 /_ RCTComponentData+Maps.m _/; };
53D31636202E723B00B55447 /_ AIRMapOverlayManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 53D31635202E723B00B55447 /_ AIRMapOverlayManager.m _/; };
53D3163A202E72FC00B55447 /_ AIRMapOverlay.m in Sources _/ = {isa = PBXBuildFile; fileRef = 53D31639202E72FC00B55447 /_ AIRMapOverlay.m _/; };
53D3163D202E734F00B55447 /_ AIRMapOverlayRenderer.m in Sources _/ = {isa = PBXBuildFile; fileRef = 53D3163C202E734F00B55447 /_ AIRMapOverlayRenderer.m _/; };
628F81201FD16DF80058313A /_ AIRMapLocalTile.m in Sources _/ = {isa = PBXBuildFile; fileRef = 628F811F1FD16DF80058313A /_ AIRMapLocalTile.m _/; };
628F81231FD16EFA0058313A /_ AIRMapLocalTileManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 628F81221FD16EFA0058313A /_ AIRMapLocalTileManager.m _/; };
62AEC4D41FD5A0AA003225E0 /_ AIRMapLocalTileOverlay.m in Sources _/ = {isa = PBXBuildFile; fileRef = 62AEC4D31FD5A0AA003225E0 /_ AIRMapLocalTileOverlay.m _/; };
8B19A3C82257BBDF00BB8735 /_ AIRMapCalloutSubview.m in Sources _/ = {isa = PBXBuildFile; fileRef = 8B19A3C42257BBDE00BB8735 /_ AIRMapCalloutSubview.m _/; };
8B19A3C92257BBDF00BB8735 /_ AIRMapCalloutSubviewManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 8B19A3C72257BBDF00BB8735 /_ AIRMapCalloutSubviewManager.m _/; };
8BC85FB02107CFEC0006CEA5 /_ AIRGoogleMapOverlay.m in Sources _/ = {isa = PBXBuildFile; fileRef = 8BC85FAF2107CFEC0006CEA5 /_ AIRGoogleMapOverlay.m _/; };
9B9498CA2017EFB800158761 /_ AIRGoogleMapUrlTile.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498A62017EFB400158761 /_ AIRGoogleMapUrlTile.m _/; };
9B9498CB2017EFB800158761 /_ AIRGoogleMapURLTileManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498A72017EFB400158761 /_ AIRGoogleMapURLTileManager.m _/; };
9B9498CC2017EFB800158761 /_ AIRGMSPolygon.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498A82017EFB400158761 /_ AIRGMSPolygon.m _/; };
9B9498CD2017EFB800158761 /_ AIRGoogleMapCallout.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498AC2017EFB400158761 /_ AIRGoogleMapCallout.m _/; };
9B9498CE2017EFB800158761 /_ AIRGMSMarker.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498AE2017EFB500158761 /_ AIRGMSMarker.m _/; };
9B9498CF2017EFB800158761 /_ AIRGMSPolyline.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498AF2017EFB500158761 /_ AIRGMSPolyline.m _/; };
9B9498D02017EFB800158761 /_ AIRGoogleMapPolylineManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498B12017EFB500158761 /_ AIRGoogleMapPolylineManager.m _/; };
9B9498D12017EFB800158761 /_ AIRGoogleMapCircle.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498B32017EFB500158761 /_ AIRGoogleMapCircle.m _/; };
9B9498D22017EFB800158761 /_ AIRGoogleMapMarkerManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498B52017EFB500158761 /_ AIRGoogleMapMarkerManager.m _/; };
9B9498D32017EFB800158761 /_ AIRGoogleMap.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498B72017EFB500158761 /_ AIRGoogleMap.m _/; };
9B9498D42017EFB800158761 /_ RCTConvert+GMSMapViewType.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498B92017EFB600158761 /_ RCTConvert+GMSMapViewType.m _/; };
9B9498D52017EFB800158761 /_ AIRGoogleMapPolyline.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498BB2017EFB600158761 /_ AIRGoogleMapPolyline.m _/; };
9B9498D62017EFB800158761 /_ AIRGoogleMapCircleManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498BC2017EFB600158761 /_ AIRGoogleMapCircleManager.m _/; };
9B9498D72017EFB800158761 /_ AIRGoogleMapManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498BD2017EFB600158761 /_ AIRGoogleMapManager.m _/; };
9B9498D92017EFB800158761 /_ AIRGoogleMapCalloutManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498C42017EFB700158761 /_ AIRGoogleMapCalloutManager.m _/; };
9B9498DA2017EFB800158761 /_ AIRGoogleMapPolygon.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498C62017EFB800158761 /_ AIRGoogleMapPolygon.m _/; };
9B9498DB2017EFB800158761 /_ AIRGoogleMapMarker.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498C72017EFB800158761 /_ AIRGoogleMapMarker.m _/; };
9B9498DC2017EFB800158761 /_ AIRGoogleMapPolygonManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = 9B9498C92017EFB800158761 /_ AIRGoogleMapPolygonManager.m _/; };
A8494E28218891020092506D /_ AIRMapWMSTileManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = A8494E24218891020092506D /_ AIRMapWMSTileManager.m _/; };
A8494E29218891020092506D /_ AIRMapWMSTile.m in Sources _/ = {isa = PBXBuildFile; fileRef = A8494E27218891020092506D /_ AIRMapWMSTile.m _/; };
A8494E2E218891180092506D /_ AIRGoogleMapWMSTileManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = A8494E2A218891180092506D /_ AIRGoogleMapWMSTileManager.m _/; };
A8494E2F218891180092506D /_ AIRGoogleMapWMSTile.m in Sources _/ = {isa = PBXBuildFile; fileRef = A8494E2D218891180092506D /_ AIRGoogleMapWMSTile.m _/; };
B5EA3BA92098E22B000E7AFD /_ AIRDummyView.m in Sources _/ = {isa = PBXBuildFile; fileRef = B5EA3BA72098E22B000E7AFD /_ AIRDummyView.m _/; };
BE2E4EC92621F63C00CC7F2E /_ AIRMapUrlTileCachedOverlay.m in Sources _/ = {isa = PBXBuildFile; fileRef = BE2E4EC82621F63C00CC7F2E /_ AIRMapUrlTileCachedOverlay.m _/; };
DA6C26381C9E2AFE0035349F /_ AIRMapUrlTile.m in Sources _/ = {isa = PBXBuildFile; fileRef = DA6C26371C9E2AFE0035349F /_ AIRMapUrlTile.m _/; };
DA6C263E1C9E324A0035349F /_ AIRMapUrlTileManager.m in Sources _/ = {isa = PBXBuildFile; fileRef = DA6C263D1C9E324A0035349F /_ AIRMapUrlTileManager.m _/; };
/_ End PBXBuildFile section _/

/_ Begin PBXCopyFilesBuildPhase section _/
11FA5C4F1C4A1296003AC2EE /_ CopyFiles _/ = {
isa = PBXCopyFilesBuildPhase;
buildActionMask = 2147483647;
dstPath = "include/$(PRODUCT_NAME)";
dstSubfolderSpec = 16;
files = (
);
runOnlyForDeploymentPostprocessing = 0;
};
/_ End PBXCopyFilesBuildPhase section _/

/_ Begin PBXFileReference section _/
1125B2BD1C4AD3DA007D0023 /_ AIRMap.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMap.h; path = AirMaps/AIRMap.h; sourceTree = SOURCE_ROOT; };
1125B2BE1C4AD3DA007D0023 /_ AIRMap.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMap.m; path = AirMaps/AIRMap.m; sourceTree = SOURCE_ROOT; };
1125B2BF1C4AD3DA007D0023 /_ AIRMapCallout.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapCallout.h; path = AirMaps/AIRMapCallout.h; sourceTree = SOURCE_ROOT; };
1125B2C01C4AD3DA007D0023 /_ AIRMapCallout.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapCallout.m; path = AirMaps/AIRMapCallout.m; sourceTree = SOURCE_ROOT; };
1125B2C11C4AD3DA007D0023 /_ AIRMapCalloutManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapCalloutManager.h; path = AirMaps/AIRMapCalloutManager.h; sourceTree = SOURCE_ROOT; };
1125B2C21C4AD3DA007D0023 /_ AIRMapCalloutManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapCalloutManager.m; path = AirMaps/AIRMapCalloutManager.m; sourceTree = SOURCE_ROOT; };
1125B2C31C4AD3DA007D0023 /_ AIRMapCircle.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapCircle.h; path = AirMaps/AIRMapCircle.h; sourceTree = SOURCE_ROOT; };
1125B2C41C4AD3DA007D0023 /_ AIRMapCircle.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapCircle.m; path = AirMaps/AIRMapCircle.m; sourceTree = SOURCE_ROOT; };
1125B2C51C4AD3DA007D0023 /_ AIRMapCircleManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapCircleManager.h; path = AirMaps/AIRMapCircleManager.h; sourceTree = SOURCE_ROOT; };
1125B2C61C4AD3DA007D0023 /_ AIRMapCircleManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapCircleManager.m; path = AirMaps/AIRMapCircleManager.m; sourceTree = SOURCE_ROOT; };
1125B2C71C4AD3DA007D0023 /_ AIRMapCoordinate.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapCoordinate.h; path = AirMaps/AIRMapCoordinate.h; sourceTree = SOURCE_ROOT; };
1125B2C81C4AD3DA007D0023 /_ AIRMapCoordinate.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapCoordinate.m; path = AirMaps/AIRMapCoordinate.m; sourceTree = SOURCE_ROOT; };
1125B2C91C4AD3DA007D0023 /_ AIRMapManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapManager.h; path = AirMaps/AIRMapManager.h; sourceTree = SOURCE_ROOT; };
1125B2CA1C4AD3DA007D0023 /_ AIRMapManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapManager.m; path = AirMaps/AIRMapManager.m; sourceTree = SOURCE_ROOT; };
1125B2CB1C4AD3DA007D0023 /_ AIRMapMarker.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapMarker.h; path = AirMaps/AIRMapMarker.h; sourceTree = SOURCE_ROOT; };
1125B2CC1C4AD3DA007D0023 /_ AIRMapMarker.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapMarker.m; path = AirMaps/AIRMapMarker.m; sourceTree = SOURCE_ROOT; };
1125B2CD1C4AD3DA007D0023 /_ AIRMapMarkerManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapMarkerManager.h; path = AirMaps/AIRMapMarkerManager.h; sourceTree = SOURCE_ROOT; };
1125B2CE1C4AD3DA007D0023 /_ AIRMapMarkerManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapMarkerManager.m; path = AirMaps/AIRMapMarkerManager.m; sourceTree = SOURCE_ROOT; };
1125B2CF1C4AD3DA007D0023 /_ AIRMapPolygon.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapPolygon.h; path = AirMaps/AIRMapPolygon.h; sourceTree = SOURCE_ROOT; };
1125B2D01C4AD3DA007D0023 /_ AIRMapPolygon.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapPolygon.m; path = AirMaps/AIRMapPolygon.m; sourceTree = SOURCE_ROOT; };
1125B2D11C4AD3DA007D0023 /_ AIRMapPolygonManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapPolygonManager.h; path = AirMaps/AIRMapPolygonManager.h; sourceTree = SOURCE_ROOT; };
1125B2D21C4AD3DA007D0023 /_ AIRMapPolygonManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapPolygonManager.m; path = AirMaps/AIRMapPolygonManager.m; sourceTree = SOURCE_ROOT; };
1125B2D31C4AD3DA007D0023 /_ AIRMapPolyline.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapPolyline.h; path = AirMaps/AIRMapPolyline.h; sourceTree = SOURCE_ROOT; };
1125B2D41C4AD3DA007D0023 /_ AIRMapPolyline.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapPolyline.m; path = AirMaps/AIRMapPolyline.m; sourceTree = SOURCE_ROOT; };
1125B2D51C4AD3DA007D0023 /_ AIRMapPolylineManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapPolylineManager.h; path = AirMaps/AIRMapPolylineManager.h; sourceTree = SOURCE_ROOT; };
1125B2D61C4AD3DA007D0023 /_ AIRMapPolylineManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapPolylineManager.m; path = AirMaps/AIRMapPolylineManager.m; sourceTree = SOURCE_ROOT; };
1125B2F01C4AD445007D0023 /_ SMCalloutView.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SMCalloutView.h; path = AirMaps/Callout/SMCalloutView.h; sourceTree = SOURCE_ROOT; };
1125B2F11C4AD445007D0023 /_ SMCalloutView.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = SMCalloutView.m; path = AirMaps/Callout/SMCalloutView.m; sourceTree = SOURCE_ROOT; };
11FA5C511C4A1296003AC2EE /_ libAirMaps.a _/ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libAirMaps.a; sourceTree = BUILT_PRODUCTS_DIR; };
19DABC7D1E7C9D3C00F41150 /_ RCTConvert+AirMap.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "RCTConvert+AirMap.h"; sourceTree = "<group>"; };
19DABC7E1E7C9D3C00F41150 /_ RCTConvert+AirMap.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "RCTConvert+AirMap.m"; sourceTree = "<group>"; };
2163AA4E1FEAEDD100BBEC95 /_ AIRMapPolylineRenderer.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AIRMapPolylineRenderer.h; sourceTree = "<group>"; };
2163AA4F1FEAEDD100BBEC95 /_ AIRMapPolylineRenderer.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AIRMapPolylineRenderer.m; sourceTree = "<group>"; };
4C99C9DC2226CF2800A8693E /_ AIRWeakTimerReference.h _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AIRWeakTimerReference.h; sourceTree = "<group>"; };
4C99C9DD2226CF2800A8693E /_ AIRWeakTimerReference.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AIRWeakTimerReference.m; sourceTree = "<group>"; };
4C99C9DF2226D8C400A8693E /_ AIRWeakMapReference.h _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AIRWeakMapReference.h; sourceTree = "<group>"; };
4C99C9E02226D8C400A8693E /_ AIRWeakMapReference.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AIRWeakMapReference.m; sourceTree = "<group>"; };
4E0A36142BFB4CF3009FCCE4 /_ Resources _/ = {isa = PBXFileReference; lastKnownFileType = folder; name = Resources; path = AirGoogleMaps/Resources; sourceTree = "<group>"; };
4E0A36152BFB4E76009FCCE4 /_ PrivacyInfo.xcprivacy _/ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = PrivacyInfo.xcprivacy; sourceTree = "<group>"; };
4E0CFBDC2B388F2B0017E126 /_ RCTComponentData+Maps.h _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "RCTComponentData+Maps.h"; sourceTree = "<group>"; };
4E0CFBDD2B388F2B0017E126 /_ RCTComponentData+Maps.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = "RCTComponentData+Maps.m"; sourceTree = "<group>"; };
53D31635202E723B00B55447 /_ AIRMapOverlayManager.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AIRMapOverlayManager.m; sourceTree = "<group>"; };
53D31637202E725E00B55447 /_ AIRMapOverlayManager.h _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AIRMapOverlayManager.h; sourceTree = "<group>"; };
53D31638202E72D500B55447 /_ AIRMapOverlay.h _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AIRMapOverlay.h; sourceTree = "<group>"; };
53D31639202E72FC00B55447 /_ AIRMapOverlay.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AIRMapOverlay.m; sourceTree = "<group>"; };
53D3163B202E732300B55447 /_ AIRMapOverlayRenderer.h _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AIRMapOverlayRenderer.h; sourceTree = "<group>"; };
53D3163C202E734F00B55447 /_ AIRMapOverlayRenderer.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AIRMapOverlayRenderer.m; sourceTree = "<group>"; };
628F811E1FD16D780058313A /_ AIRMapLocalTile.h _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AIRMapLocalTile.h; sourceTree = "<group>"; };
628F811F1FD16DF80058313A /_ AIRMapLocalTile.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AIRMapLocalTile.m; sourceTree = "<group>"; };
628F81211FD16EAB0058313A /_ AIRMapLocalTileManager.h _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AIRMapLocalTileManager.h; sourceTree = "<group>"; };
628F81221FD16EFA0058313A /_ AIRMapLocalTileManager.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AIRMapLocalTileManager.m; sourceTree = "<group>"; };
62AEC4D31FD5A0AA003225E0 /_ AIRMapLocalTileOverlay.m _/ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; name = AIRMapLocalTileOverlay.m; path = AirMaps/AIRMapLocalTileOverlay.m; sourceTree = "<group>"; };
8B19A3C42257BBDE00BB8735 /_ AIRMapCalloutSubview.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AIRMapCalloutSubview.m; sourceTree = "<group>"; };
8B19A3C52257BBDE00BB8735 /_ AIRMapCalloutSubviewManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AIRMapCalloutSubviewManager.h; sourceTree = "<group>"; };
8B19A3C62257BBDF00BB8735 /_ AIRMapCalloutSubview.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AIRMapCalloutSubview.h; sourceTree = "<group>"; };
8B19A3C72257BBDF00BB8735 /_ AIRMapCalloutSubviewManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AIRMapCalloutSubviewManager.m; sourceTree = "<group>"; };
8BC85FAD2107C0BD0006CEA5 /_ User.xcconfig _/ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = User.xcconfig; sourceTree = "<group>"; };
8BC85FAE2107CFD80006CEA5 /_ AIRGoogleMapOverlay.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapOverlay.h; path = AirGoogleMaps/AIRGoogleMapOverlay.h; sourceTree = "<group>"; };
8BC85FAF2107CFEC0006CEA5 /_ AIRGoogleMapOverlay.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapOverlay.m; path = AirGoogleMaps/AIRGoogleMapOverlay.m; sourceTree = "<group>"; };
9B9498A42017EFB400158761 /_ AIRGoogleMapCallout.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapCallout.h; path = AirGoogleMaps/AIRGoogleMapCallout.h; sourceTree = "<group>"; };
9B9498A52017EFB400158761 /_ AIRGoogleMapPolygonManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapPolygonManager.h; path = AirGoogleMaps/AIRGoogleMapPolygonManager.h; sourceTree = "<group>"; };
9B9498A62017EFB400158761 /_ AIRGoogleMapUrlTile.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapUrlTile.m; path = AirGoogleMaps/AIRGoogleMapUrlTile.m; sourceTree = "<group>"; };
9B9498A72017EFB400158761 /_ AIRGoogleMapURLTileManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapURLTileManager.m; path = AirGoogleMaps/AIRGoogleMapURLTileManager.m; sourceTree = "<group>"; };
9B9498A82017EFB400158761 /_ AIRGMSPolygon.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGMSPolygon.m; path = AirGoogleMaps/AIRGMSPolygon.m; sourceTree = "<group>"; };
9B9498A92017EFB400158761 /_ RCTConvert+GMSMapViewType.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "RCTConvert+GMSMapViewType.h"; path = "AirGoogleMaps/RCTConvert+GMSMapViewType.h"; sourceTree = "<group>"; };
9B9498AA2017EFB400158761 /_ AIRGoogleMap.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMap.h; path = AirGoogleMaps/AIRGoogleMap.h; sourceTree = "<group>"; };
9B9498AB2017EFB400158761 /_ AIRGoogleMapMarkerManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapMarkerManager.h; path = AirGoogleMaps/AIRGoogleMapMarkerManager.h; sourceTree = "<group>"; };
9B9498AC2017EFB400158761 /_ AIRGoogleMapCallout.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapCallout.m; path = AirGoogleMaps/AIRGoogleMapCallout.m; sourceTree = "<group>"; };
9B9498AD2017EFB400158761 /_ AIRGoogleMapUrlTileManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapUrlTileManager.h; path = AirGoogleMaps/AIRGoogleMapUrlTileManager.h; sourceTree = "<group>"; };
9B9498AE2017EFB500158761 /_ AIRGMSMarker.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGMSMarker.m; path = AirGoogleMaps/AIRGMSMarker.m; sourceTree = "<group>"; };
9B9498AF2017EFB500158761 /_ AIRGMSPolyline.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGMSPolyline.m; path = AirGoogleMaps/AIRGMSPolyline.m; sourceTree = "<group>"; };
9B9498B02017EFB500158761 /_ AIRGoogleMapCircleManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapCircleManager.h; path = AirGoogleMaps/AIRGoogleMapCircleManager.h; sourceTree = "<group>"; };
9B9498B12017EFB500158761 /_ AIRGoogleMapPolylineManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapPolylineManager.m; path = AirGoogleMaps/AIRGoogleMapPolylineManager.m; sourceTree = "<group>"; };
9B9498B32017EFB500158761 /_ AIRGoogleMapCircle.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapCircle.m; path = AirGoogleMaps/AIRGoogleMapCircle.m; sourceTree = "<group>"; };
9B9498B42017EFB500158761 /_ AIRGMSPolyline.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGMSPolyline.h; path = AirGoogleMaps/AIRGMSPolyline.h; sourceTree = "<group>"; };
9B9498B52017EFB500158761 /_ AIRGoogleMapMarkerManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapMarkerManager.m; path = AirGoogleMaps/AIRGoogleMapMarkerManager.m; sourceTree = "<group>"; };
9B9498B62017EFB500158761 /_ AIRGoogleMapPolylineManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapPolylineManager.h; path = AirGoogleMaps/AIRGoogleMapPolylineManager.h; sourceTree = "<group>"; };
9B9498B72017EFB500158761 /_ AIRGoogleMap.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMap.m; path = AirGoogleMaps/AIRGoogleMap.m; sourceTree = "<group>"; };
9B9498B82017EFB600158761 /_ AIRGoogleMapPolyline.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapPolyline.h; path = AirGoogleMaps/AIRGoogleMapPolyline.h; sourceTree = "<group>"; };
9B9498B92017EFB600158761 /_ RCTConvert+GMSMapViewType.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = "RCTConvert+GMSMapViewType.m"; path = "AirGoogleMaps/RCTConvert+GMSMapViewType.m"; sourceTree = "<group>"; };
9B9498BA2017EFB600158761 /_ AIRGMSPolygon.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGMSPolygon.h; path = AirGoogleMaps/AIRGMSPolygon.h; sourceTree = "<group>"; };
9B9498BB2017EFB600158761 /_ AIRGoogleMapPolyline.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapPolyline.m; path = AirGoogleMaps/AIRGoogleMapPolyline.m; sourceTree = "<group>"; };
9B9498BC2017EFB600158761 /_ AIRGoogleMapCircleManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapCircleManager.m; path = AirGoogleMaps/AIRGoogleMapCircleManager.m; sourceTree = "<group>"; };
9B9498BD2017EFB600158761 /_ AIRGoogleMapManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapManager.m; path = AirGoogleMaps/AIRGoogleMapManager.m; sourceTree = "<group>"; };
9B9498BE2017EFB600158761 /_ AIRGoogleMapManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapManager.h; path = AirGoogleMaps/AIRGoogleMapManager.h; sourceTree = "<group>"; };
9B9498C02017EFB700158761 /_ AIRGoogleMapMarker.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapMarker.h; path = AirGoogleMaps/AIRGoogleMapMarker.h; sourceTree = "<group>"; };
9B9498C12017EFB700158761 /_ AIRGMSMarker.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGMSMarker.h; path = AirGoogleMaps/AIRGMSMarker.h; sourceTree = "<group>"; };
9B9498C22017EFB700158761 /_ AIRGoogleMapCircle.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapCircle.h; path = AirGoogleMaps/AIRGoogleMapCircle.h; sourceTree = "<group>"; };
9B9498C32017EFB700158761 /_ AIRGoogleMapPolygon.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapPolygon.h; path = AirGoogleMaps/AIRGoogleMapPolygon.h; sourceTree = "<group>"; };
9B9498C42017EFB700158761 /_ AIRGoogleMapCalloutManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapCalloutManager.m; path = AirGoogleMaps/AIRGoogleMapCalloutManager.m; sourceTree = "<group>"; };
9B9498C52017EFB800158761 /_ AIRGoogleMapCalloutManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapCalloutManager.h; path = AirGoogleMaps/AIRGoogleMapCalloutManager.h; sourceTree = "<group>"; };
9B9498C62017EFB800158761 /_ AIRGoogleMapPolygon.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapPolygon.m; path = AirGoogleMaps/AIRGoogleMapPolygon.m; sourceTree = "<group>"; };
9B9498C72017EFB800158761 /_ AIRGoogleMapMarker.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapMarker.m; path = AirGoogleMaps/AIRGoogleMapMarker.m; sourceTree = "<group>"; };
9B9498C82017EFB800158761 /_ AIRGoogleMapUrlTile.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapUrlTile.h; path = AirGoogleMaps/AIRGoogleMapUrlTile.h; sourceTree = "<group>"; };
9B9498C92017EFB800158761 /_ AIRGoogleMapPolygonManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapPolygonManager.m; path = AirGoogleMaps/AIRGoogleMapPolygonManager.m; sourceTree = "<group>"; };
A8494E24218891020092506D /_ AIRMapWMSTileManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AIRMapWMSTileManager.m; sourceTree = "<group>"; };
A8494E25218891020092506D /_ AIRMapWMSTile.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AIRMapWMSTile.h; sourceTree = "<group>"; };
A8494E26218891020092506D /_ AIRMapWMSTileManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AIRMapWMSTileManager.h; sourceTree = "<group>"; };
A8494E27218891020092506D /_ AIRMapWMSTile.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AIRMapWMSTile.m; sourceTree = "<group>"; };
A8494E2A218891180092506D /_ AIRGoogleMapWMSTileManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapWMSTileManager.m; path = AirGoogleMaps/AIRGoogleMapWMSTileManager.m; sourceTree = "<group>"; };
A8494E2B218891180092506D /_ AIRGoogleMapWMSTile.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapWMSTile.h; path = AirGoogleMaps/AIRGoogleMapWMSTile.h; sourceTree = "<group>"; };
A8494E2C218891180092506D /_ AIRGoogleMapWMSTileManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRGoogleMapWMSTileManager.h; path = AirGoogleMaps/AIRGoogleMapWMSTileManager.h; sourceTree = "<group>"; };
A8494E2D218891180092506D /_ AIRGoogleMapWMSTile.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRGoogleMapWMSTile.m; path = AirGoogleMaps/AIRGoogleMapWMSTile.m; sourceTree = "<group>"; };
B5EA3BA72098E22B000E7AFD /_ AIRDummyView.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRDummyView.m; path = AirGoogleMaps/AIRDummyView.m; sourceTree = "<group>"; };
B5EA3BA82098E22B000E7AFD /_ AIRDummyView.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRDummyView.h; path = AirGoogleMaps/AIRDummyView.h; sourceTree = "<group>"; };
BE2E4EC72621F63C00CC7F2E /_ AIRMapUrlTileCachedOverlay.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AIRMapUrlTileCachedOverlay.h; path = AirMaps/AIRMapUrlTileCachedOverlay.h; sourceTree = SOURCE_ROOT; };
BE2E4EC82621F63C00CC7F2E /_ AIRMapUrlTileCachedOverlay.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = AIRMapUrlTileCachedOverlay.m; path = AirMaps/AIRMapUrlTileCachedOverlay.m; sourceTree = SOURCE_ROOT; };
DA6C26361C9E2AFE0035349F /_ AIRMapUrlTile.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AIRMapUrlTile.h; sourceTree = "<group>"; };
DA6C26371C9E2AFE0035349F /_ AIRMapUrlTile.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AIRMapUrlTile.m; sourceTree = "<group>"; };
DA6C263C1C9E324A0035349F /_ AIRMapUrlTileManager.h _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AIRMapUrlTileManager.h; sourceTree = "<group>"; };
DA6C263D1C9E324A0035349F /_ AIRMapUrlTileManager.m _/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AIRMapUrlTileManager.m; sourceTree = "<group>"; };
/_ End PBXFileReference section _/

/_ Begin PBXFrameworksBuildPhase section _/
11FA5C4E1C4A1296003AC2EE /_ Frameworks _/ = {
isa = PBXFrameworksBuildPhase;
buildActionMask = 2147483647;
files = (
);
runOnlyForDeploymentPostprocessing = 0;
};
/_ End PBXFrameworksBuildPhase section _/

/_ Begin PBXGroup section _/
11FA5C481C4A1296003AC2EE = {
isa = PBXGroup;
children = (
4E0A36152BFB4E76009FCCE4 /_ PrivacyInfo.xcprivacy _/,
9B9498A32017EF9D00158761 /_ AirGoogleMaps _/,
62AEC4D31FD5A0AA003225E0 /_ AIRMapLocalTileOverlay.m _/,
11FA5C531C4A1296003AC2EE /_ AirMaps _/,
11FA5C521C4A1296003AC2EE /_ Products _/,
8BC85FAD2107C0BD0006CEA5 /_ User.xcconfig _/,
);
sourceTree = "<group>";
};
11FA5C521C4A1296003AC2EE /_ Products _/ = {
isa = PBXGroup;
children = (
11FA5C511C4A1296003AC2EE /_ libAirMaps.a _/,
);
name = Products;
sourceTree = "<group>";
};
11FA5C531C4A1296003AC2EE /_ AirMaps _/ = {
isa = PBXGroup;
children = (
4E0CFBDC2B388F2B0017E126 /_ RCTComponentData+Maps.h _/,
4E0CFBDD2B388F2B0017E126 /_ RCTComponentData+Maps.m _/,
BE2E4EC72621F63C00CC7F2E /_ AIRMapUrlTileCachedOverlay.h _/,
BE2E4EC82621F63C00CC7F2E /_ AIRMapUrlTileCachedOverlay.m _/,
1125B2BD1C4AD3DA007D0023 /_ AIRMap.h _/,
1125B2BE1C4AD3DA007D0023 /_ AIRMap.m _/,
1125B2BF1C4AD3DA007D0023 /_ AIRMapCallout.h _/,
1125B2C01C4AD3DA007D0023 /_ AIRMapCallout.m _/,
1125B2C11C4AD3DA007D0023 /_ AIRMapCalloutManager.h _/,
1125B2C21C4AD3DA007D0023 /_ AIRMapCalloutManager.m _/,
8B19A3C62257BBDF00BB8735 /_ AIRMapCalloutSubview.h _/,
8B19A3C42257BBDE00BB8735 /_ AIRMapCalloutSubview.m _/,
8B19A3C52257BBDE00BB8735 /_ AIRMapCalloutSubviewManager.h _/,
8B19A3C72257BBDF00BB8735 /_ AIRMapCalloutSubviewManager.m _/,
1125B2C31C4AD3DA007D0023 /_ AIRMapCircle.h _/,
1125B2C41C4AD3DA007D0023 /_ AIRMapCircle.m _/,
1125B2C51C4AD3DA007D0023 /_ AIRMapCircleManager.h _/,
1125B2C61C4AD3DA007D0023 /_ AIRMapCircleManager.m _/,
1125B2D41C4AD3DA007D0023 /_ AIRMapPolyline.m _/,
1125B2C71C4AD3DA007D0023 /_ AIRMapCoordinate.h _/,
1125B2C81C4AD3DA007D0023 /_ AIRMapCoordinate.m _/,
1125B2C91C4AD3DA007D0023 /_ AIRMapManager.h _/,
1125B2CA1C4AD3DA007D0023 /_ AIRMapManager.m _/,
1125B2CB1C4AD3DA007D0023 /_ AIRMapMarker.h _/,
1125B2CD1C4AD3DA007D0023 /_ AIRMapMarkerManager.h _/,
1125B2CE1C4AD3DA007D0023 /_ AIRMapMarkerManager.m _/,
1125B2CF1C4AD3DA007D0023 /_ AIRMapPolygon.h _/,
1125B2D01C4AD3DA007D0023 /_ AIRMapPolygon.m _/,
1125B2D11C4AD3DA007D0023 /_ AIRMapPolygonManager.h _/,
1125B2D21C4AD3DA007D0023 /_ AIRMapPolygonManager.m _/,
1125B2D31C4AD3DA007D0023 /_ AIRMapPolyline.h _/,
1125B2D51C4AD3DA007D0023 /_ AIRMapPolylineManager.h _/,
1125B2D61C4AD3DA007D0023 /_ AIRMapPolylineManager.m _/,
2163AA4E1FEAEDD100BBEC95 /_ AIRMapPolylineRenderer.h _/,
2163AA4F1FEAEDD100BBEC95 /_ AIRMapPolylineRenderer.m _/,
1125B2F01C4AD445007D0023 /_ SMCalloutView.h _/,
1125B2F11C4AD445007D0023 /_ SMCalloutView.m _/,
19DABC7D1E7C9D3C00F41150 /_ RCTConvert+AirMap.h _/,
19DABC7E1E7C9D3C00F41150 /_ RCTConvert+AirMap.m _/,
DA6C26361C9E2AFE0035349F /_ AIRMapUrlTile.h _/,
DA6C26371C9E2AFE0035349F /_ AIRMapUrlTile.m _/,
DA6C263C1C9E324A0035349F /_ AIRMapUrlTileManager.h _/,
DA6C263D1C9E324A0035349F /_ AIRMapUrlTileManager.m _/,
A8494E25218891020092506D /_ AIRMapWMSTile.h _/,
A8494E27218891020092506D /_ AIRMapWMSTile.m _/,
A8494E26218891020092506D /_ AIRMapWMSTileManager.h _/,
A8494E24218891020092506D /_ AIRMapWMSTileManager.m _/,
1125B2CC1C4AD3DA007D0023 /_ AIRMapMarker.m _/,
628F811E1FD16D780058313A /_ AIRMapLocalTile.h _/,
628F811F1FD16DF80058313A /_ AIRMapLocalTile.m _/,
628F81211FD16EAB0058313A /_ AIRMapLocalTileManager.h _/,
628F81221FD16EFA0058313A /_ AIRMapLocalTileManager.m _/,
53D31638202E72D500B55447 /_ AIRMapOverlay.h _/,
53D31639202E72FC00B55447 /_ AIRMapOverlay.m _/,
53D31637202E725E00B55447 /_ AIRMapOverlayManager.h _/,
53D31635202E723B00B55447 /_ AIRMapOverlayManager.m _/,
53D3163B202E732300B55447 /_ AIRMapOverlayRenderer.h _/,
53D3163C202E734F00B55447 /_ AIRMapOverlayRenderer.m _/,
4C99C9DC2226CF2800A8693E /_ AIRWeakTimerReference.h _/,
4C99C9DD2226CF2800A8693E /_ AIRWeakTimerReference.m _/,
4C99C9DF2226D8C400A8693E /_ AIRWeakMapReference.h _/,
4C99C9E02226D8C400A8693E /_ AIRWeakMapReference.m _/,
);
path = AirMaps;
sourceTree = "<group>";
};
9B9498A32017EF9D00158761 /_ AirGoogleMaps _/ = {
isa = PBXGroup;
children = (
4E0A36142BFB4CF3009FCCE4 /_ Resources _/,
B5EA3BA82098E22B000E7AFD /_ AIRDummyView.h _/,
B5EA3BA72098E22B000E7AFD /_ AIRDummyView.m _/,
9B9498C12017EFB700158761 /_ AIRGMSMarker.h _/,
9B9498AE2017EFB500158761 /_ AIRGMSMarker.m _/,
9B9498BA2017EFB600158761 /_ AIRGMSPolygon.h _/,
9B9498A82017EFB400158761 /_ AIRGMSPolygon.m _/,
9B9498B42017EFB500158761 /_ AIRGMSPolyline.h _/,
9B9498AF2017EFB500158761 /_ AIRGMSPolyline.m _/,
9B9498AA2017EFB400158761 /_ AIRGoogleMap.h _/,
9B9498B72017EFB500158761 /_ AIRGoogleMap.m _/,
9B9498A42017EFB400158761 /_ AIRGoogleMapCallout.h _/,
9B9498AC2017EFB400158761 /_ AIRGoogleMapCallout.m _/,
9B9498C52017EFB800158761 /_ AIRGoogleMapCalloutManager.h _/,
9B9498C42017EFB700158761 /_ AIRGoogleMapCalloutManager.m _/,
9B9498C22017EFB700158761 /_ AIRGoogleMapCircle.h _/,
9B9498B32017EFB500158761 /_ AIRGoogleMapCircle.m _/,
9B9498B02017EFB500158761 /_ AIRGoogleMapCircleManager.h _/,
9B9498BC2017EFB600158761 /_ AIRGoogleMapCircleManager.m _/,
9B9498BE2017EFB600158761 /_ AIRGoogleMapManager.h _/,
9B9498BD2017EFB600158761 /_ AIRGoogleMapManager.m _/,
9B9498C02017EFB700158761 /_ AIRGoogleMapMarker.h _/,
9B9498C72017EFB800158761 /_ AIRGoogleMapMarker.m _/,
9B9498AB2017EFB400158761 /_ AIRGoogleMapMarkerManager.h _/,
9B9498B52017EFB500158761 /_ AIRGoogleMapMarkerManager.m _/,
9B9498C32017EFB700158761 /_ AIRGoogleMapPolygon.h _/,
9B9498C62017EFB800158761 /_ AIRGoogleMapPolygon.m _/,
9B9498A52017EFB400158761 /_ AIRGoogleMapPolygonManager.h _/,
9B9498C92017EFB800158761 /_ AIRGoogleMapPolygonManager.m _/,
9B9498B82017EFB600158761 /_ AIRGoogleMapPolyline.h _/,
9B9498BB2017EFB600158761 /_ AIRGoogleMapPolyline.m _/,
8BC85FAE2107CFD80006CEA5 /_ AIRGoogleMapOverlay.h _/,
8BC85FAF2107CFEC0006CEA5 /_ AIRGoogleMapOverlay.m _/,
9B9498B62017EFB500158761 /_ AIRGoogleMapPolylineManager.h _/,
9B9498B12017EFB500158761 /_ AIRGoogleMapPolylineManager.m _/,
9B9498C82017EFB800158761 /_ AIRGoogleMapUrlTile.h _/,
9B9498A62017EFB400158761 /_ AIRGoogleMapUrlTile.m _/,
9B9498AD2017EFB400158761 /_ AIRGoogleMapUrlTileManager.h _/,
9B9498A72017EFB400158761 /_ AIRGoogleMapURLTileManager.m _/,
A8494E2B218891180092506D /_ AIRGoogleMapWMSTile.h _/,
A8494E2D218891180092506D /_ AIRGoogleMapWMSTile.m _/,
A8494E2C218891180092506D /_ AIRGoogleMapWMSTileManager.h _/,
A8494E2A218891180092506D /_ AIRGoogleMapWMSTileManager.m _/,
9B9498A92017EFB400158761 /_ RCTConvert+GMSMapViewType.h _/,
9B9498B92017EFB600158761 /_ RCTConvert+GMSMapViewType.m _/,
);
name = AirGoogleMaps;
sourceTree = "<group>";
};
/_ End PBXGroup section _/

/_ Begin PBXNativeTarget section _/
11FA5C501C4A1296003AC2EE /_ AirMaps _/ = {
isa = PBXNativeTarget;
buildConfigurationList = 11FA5C5A1C4A1296003AC2EE /_ Build configuration list for PBXNativeTarget "AirMaps" _/;
buildPhases = (
11FA5C4D1C4A1296003AC2EE /_ Sources _/,
11FA5C4E1C4A1296003AC2EE /_ Frameworks _/,
11FA5C4F1C4A1296003AC2EE /_ CopyFiles _/,
);
buildRules = (
);
dependencies = (
);
name = AirMaps;
productName = AirMaps;
productReference = 11FA5C511C4A1296003AC2EE /_ libAirMaps.a _/;
productType = "com.apple.product-type.library.static";
};
/_ End PBXNativeTarget section _/

/_ Begin PBXProject section _/
11FA5C491C4A1296003AC2EE /_ Project object _/ = {
isa = PBXProject;
attributes = {
LastUpgradeCheck = 0940;
ORGANIZATIONNAME = "react-native-maps";
TargetAttributes = {
11FA5C501C4A1296003AC2EE = {
CreatedOnToolsVersion = 7.2;
};
};
};
buildConfigurationList = 11FA5C4C1C4A1296003AC2EE /_ Build configuration list for PBXProject "AirMaps" _/;
compatibilityVersion = "Xcode 15.3";
developmentRegion = English;
hasScannedForEncodings = 0;
knownRegions = (
English,
en,
);
mainGroup = 11FA5C481C4A1296003AC2EE;
productRefGroup = 11FA5C521C4A1296003AC2EE /_ Products _/;
projectDirPath = "";
projectRoot = "";
targets = (
11FA5C501C4A1296003AC2EE /_ AirMaps _/,
);
};
/_ End PBXProject section _/

/_ Begin PBXSourcesBuildPhase section _/
11FA5C4D1C4A1296003AC2EE /_ Sources _/ = {
isa = PBXSourcesBuildPhase;
buildActionMask = 2147483647;
files = (
62AEC4D41FD5A0AA003225E0 /_ AIRMapLocalTileOverlay.m in Sources _/,
9B9498DC2017EFB800158761 /_ AIRGoogleMapPolygonManager.m in Sources _/,
1125B2E31C4AD3DA007D0023 /_ AIRMapPolygon.m in Sources _/,
4C99C9DE2226CF2800A8693E /_ AIRWeakTimerReference.m in Sources _/,
1125B2E41C4AD3DA007D0023 /_ AIRMapPolygonManager.m in Sources _/,
A8494E2F218891180092506D /_ AIRGoogleMapWMSTile.m in Sources _/,
9B9498CB2017EFB800158761 /_ AIRGoogleMapURLTileManager.m in Sources _/,
A8494E28218891020092506D /_ AIRMapWMSTileManager.m in Sources _/,
1125B2DB1C4AD3DA007D0023 /_ AIRMapCallout.m in Sources _/,
53D31636202E723B00B55447 /_ AIRMapOverlayManager.m in Sources _/,
4E0CFBDE2B388F2B0017E126 /_ RCTComponentData+Maps.m in Sources _/,
1125B2E01C4AD3DA007D0023 /_ AIRMapManager.m in Sources _/,
1125B2E61C4AD3DA007D0023 /_ AIRMapPolylineManager.m in Sources _/,
9B9498DA2017EFB800158761 /_ AIRGoogleMapPolygon.m in Sources _/,
9B9498D12017EFB800158761 /_ AIRGoogleMapCircle.m in Sources _/,
1125B2DD1C4AD3DA007D0023 /_ AIRMapCircle.m in Sources _/,
9B9498CE2017EFB800158761 /_ AIRGMSMarker.m in Sources _/,
9B9498D72017EFB800158761 /_ AIRGoogleMapManager.m in Sources _/,
19DABC7F1E7C9D3C00F41150 /_ RCTConvert+AirMap.m in Sources _/,
A8494E2E218891180092506D /_ AIRGoogleMapWMSTileManager.m in Sources _/,
8B19A3C82257BBDF00BB8735 /_ AIRMapCalloutSubview.m in Sources _/,
1125B2E51C4AD3DA007D0023 /_ AIRMapPolyline.m in Sources _/,
4C99C9E12226D8C400A8693E /_ AIRWeakMapReference.m in Sources _/,
9B9498D52017EFB800158761 /_ AIRGoogleMapPolyline.m in Sources _/,
9B9498CF2017EFB800158761 /_ AIRGMSPolyline.m in Sources _/,
9B9498D42017EFB800158761 /_ RCTConvert+GMSMapViewType.m in Sources _/,
9B9498D32017EFB800158761 /_ AIRGoogleMap.m in Sources _/,
BE2E4EC92621F63C00CC7F2E /_ AIRMapUrlTileCachedOverlay.m in Sources _/,
DA6C263E1C9E324A0035349F /_ AIRMapUrlTileManager.m in Sources _/,
9B9498DB2017EFB800158761 /_ AIRGoogleMapMarker.m in Sources _/,
628F81201FD16DF80058313A /_ AIRMapLocalTile.m in Sources _/,
9B9498D92017EFB800158761 /_ AIRGoogleMapCalloutManager.m in Sources _/,
53D3163A202E72FC00B55447 /_ AIRMapOverlay.m in Sources _/,
53D3163D202E734F00B55447 /_ AIRMapOverlayRenderer.m in Sources _/,
1125B2DA1C4AD3DA007D0023 /_ AIRMap.m in Sources _/,
1125B2DF1C4AD3DA007D0023 /_ AIRMapCoordinate.m in Sources _/,
9B9498D62017EFB800158761 /_ AIRGoogleMapCircleManager.m in Sources _/,
8BC85FB02107CFEC0006CEA5 /_ AIRGoogleMapOverlay.m in Sources _/,
1125B2F21C4AD445007D0023 /_ SMCalloutView.m in Sources _/,
2163AA501FEAEDD100BBEC95 /_ AIRMapPolylineRenderer.m in Sources _/,
9B9498D02017EFB800158761 /_ AIRGoogleMapPolylineManager.m in Sources _/,
1125B2E11C4AD3DA007D0023 /_ AIRMapMarker.m in Sources _/,
A8494E29218891020092506D /_ AIRMapWMSTile.m in Sources _/,
9B9498CA2017EFB800158761 /_ AIRGoogleMapUrlTile.m in Sources _/,
8B19A3C92257BBDF00BB8735 /_ AIRMapCalloutSubviewManager.m in Sources _/,
B5EA3BA92098E22B000E7AFD /_ AIRDummyView.m in Sources _/,
9B9498CD2017EFB800158761 /_ AIRGoogleMapCallout.m in Sources _/,
1125B2E21C4AD3DA007D0023 /_ AIRMapMarkerManager.m in Sources _/,
DA6C26381C9E2AFE0035349F /_ AIRMapUrlTile.m in Sources _/,
628F81231FD16EFA0058313A /_ AIRMapLocalTileManager.m in Sources _/,
9B9498D22017EFB800158761 /_ AIRGoogleMapMarkerManager.m in Sources _/,
9B9498CC2017EFB800158761 /_ AIRGMSPolygon.m in Sources _/,
1125B2DE1C4AD3DA007D0023 /_ AIRMapCircleManager.m in Sources _/,
1125B2DC1C4AD3DA007D0023 /_ AIRMapCalloutManager.m in Sources _/,
);
runOnlyForDeploymentPostprocessing = 0;
};
/_ End PBXSourcesBuildPhase section _/

/_ Begin XCBuildConfiguration section _/
11FA5C581C4A1296003AC2EE /_ Debug _/ = {
isa = XCBuildConfiguration;
buildSettings = {
ALWAYS_SEARCH_USER_PATHS = NO;
CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
CLANG_CXX_LIBRARY = "libc++";
CLANG_ENABLE_MODULES = YES;
CLANG_ENABLE_OBJC_ARC = YES;
CLANG_WARN_BOOL_CONVERSION = YES;
CLANG_WARN_CONSTANT_CONVERSION = YES;
CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
CLANG_WARN_EMPTY_BODY = YES;
CLANG_WARN_ENUM_CONVERSION = YES;
CLANG_WARN_INT_CONVERSION = YES;
CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
CLANG_WARN_UNREACHABLE_CODE = YES;
CLANG_WARN**DUPLICATE_METHOD_MATCH = YES;
"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
COPY_PHASE_STRIP = NO;
DEBUG_INFORMATION_FORMAT = dwarf;
ENABLE_STRICT_OBJC_MSGSEND = YES;
ENABLE_TESTABILITY = YES;
GCC_C_LANGUAGE_STANDARD = gnu99;
GCC_DYNAMIC_NO_PIC = NO;
GCC_NO_COMMON_BLOCKS = YES;
GCC_OPTIMIZATION_LEVEL = 0;
GCC_PREPROCESSOR_DEFINITIONS = (
"DEBUG=1",
"$(inherited)",
);
GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
GCC_WARN_UNDECLARED_SELECTOR = YES;
GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
GCC_WARN_UNUSED_FUNCTION = YES;
GCC_WARN_UNUSED_VARIABLE = YES;
HEADER_SEARCH_PATHS = "";
IPHONEOS_DEPLOYMENT_TARGET = 9.2;
MTL_ENABLE_DEBUG_INFO = YES;
ONLY_ACTIVE_ARCH = YES;
SDKROOT = iphoneos;
};
name = Debug;
};
11FA5C591C4A1296003AC2EE /_ Release _/ = {
isa = XCBuildConfiguration;
buildSettings = {
ALWAYS_SEARCH_USER_PATHS = NO;
CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
CLANG_CXX_LIBRARY = "libc++";
CLANG_ENABLE_MODULES = YES;
CLANG_ENABLE_OBJC_ARC = YES;
CLANG_WARN_BOOL_CONVERSION = YES;
CLANG_WARN_CONSTANT_CONVERSION = YES;
CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
CLANG_WARN_EMPTY_BODY = YES;
CLANG_WARN_ENUM_CONVERSION = YES;
CLANG_WARN_INT_CONVERSION = YES;
CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
CLANG_WARN_UNREACHABLE_CODE = YES;
CLANG_WARN**DUPLICATE_METHOD_MATCH = YES;
"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
COPY_PHASE_STRIP = NO;
DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
ENABLE_NS_ASSERTIONS = NO;
ENABLE_STRICT_OBJC_MSGSEND = YES;
GCC_C_LANGUAGE_STANDARD = gnu99;
GCC_NO_COMMON_BLOCKS = YES;
GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
GCC_WARN_UNDECLARED_SELECTOR = YES;
GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
GCC_WARN_UNUSED_FUNCTION = YES;
GCC_WARN_UNUSED_VARIABLE = YES;
HEADER_SEARCH_PATHS = "";
IPHONEOS_DEPLOYMENT_TARGET = 9.2;
MTL_ENABLE_DEBUG_INFO = NO;
SDKROOT = iphoneos;
VALIDATE_PRODUCT = YES;
};
name = Release;
};
11FA5C5B1C4A1296003AC2EE /_ Debug _/ = {
isa = XCBuildConfiguration;
baseConfigurationReference = 8BC85FAD2107C0BD0006CEA5 /_ User.xcconfig _/;
buildSettings = {
HEADER_SEARCH_PATHS = (
"$(SRCROOT)/../../react-native/React/**",
					"$(SRCROOT)/../../react-native/Libraries/Image",
);
IPHONEOS_DEPLOYMENT_TARGET = 7.0;
OTHER_LDFLAGS = "-ObjC";
PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
			};
			name = Debug;
		};
		11FA5C5C1C4A1296003AC2EE /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 8BC85FAD2107C0BD0006CEA5 /* User.xcconfig */;
			buildSettings = {
				HEADER_SEARCH_PATHS = (
					"$(SRCROOT)/../../react-native/React/\*_",
"$(SRCROOT)/../../react-native/Libraries/Image",
				);
				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
				OTHER_LDFLAGS = "-ObjC";
				PRODUCT_NAME = "$(TARGET_NAME)";
SKIP_INSTALL = YES;
};
name = Release;
};
/_ End XCBuildConfiguration section \*/

/_ Begin XCConfigurationList section _/
11FA5C4C1C4A1296003AC2EE /_ Build configuration list for PBXProject "AirMaps" _/ = {
isa = XCConfigurationList;
buildConfigurations = (
11FA5C581C4A1296003AC2EE /_ Debug _/,
11FA5C591C4A1296003AC2EE /_ Release _/,
);
defaultConfigurationIsVisible = 0;
defaultConfigurationName = Release;
};
11FA5C5A1C4A1296003AC2EE /_ Build configuration list for PBXNativeTarget "AirMaps" _/ = {
isa = XCConfigurationList;
buildConfigurations = (
11FA5C5B1C4A1296003AC2EE /_ Debug _/,
11FA5C5C1C4A1296003AC2EE /_ Release _/,
);
defaultConfigurationIsVisible = 0;
defaultConfigurationName = Release;
};
/_ End XCConfigurationList section _/
};
rootObject = 11FA5C491C4A1296003AC2EE /_ Project object _/;
}
</file>

<file path="ios/PrivacyInfo.xcprivacy">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSPrivacyTracking</key>
    <false/>
    <key>NSPrivacyTrackingDomains</key>
    <array>
    </array>
    <key>NSPrivacyCollectedDataTypes</key>
    <array>
        <dict>
            <key>NSPrivacyCollectedDataType</key>
            <string>NSPrivacyCollectedDataTypePreciseLocation</string>
            <key>NSPrivacyCollectedDataTypeLinked</key>
            <false/>
            <key>NSPrivacyCollectedDataTypeTracking</key>
            <false/>
            <key>NSPrivacyCollectedDataTypePurposes</key>
            <array>
                <string>NSPrivacyCollectedDataTypePurposeAppFunctionality</string>
            </array>
        </dict>
    </array>
    <key>NSPrivacyAccessedAPITypes</key>
    <array>
        <dict>
            <key>NSPrivacyAccessedAPIType</key>
            <string>NSPrivacyAccessedAPICategoryFileTimestamp</string>
            <key>NSPrivacyAccessedAPITypeReasons</key>
            <array>
                <string>C617.1</string>
            </array>
        </dict>
    </array>
</dict>
</plist>
</file>

<file path="src/AnimatedRegion.ts">
import {Animated} from 'react-native';
import {Region} from './sharedTypes';

const AnimatedWithChildren = Object.getPrototypeOf(Animated.ValueXY);
if (**DEV**) {
if (AnimatedWithChildren.name !== 'AnimatedWithChildren') {
console.error(
'AnimatedRegion could not obtain AnimatedWithChildren base class',
);
}
}

const configTypes: (keyof Region)[] = [
'latitude',
'longitude',
'latitudeDelta',
'longitudeDelta',
];

const defaultValues = {
// probably want to come up with better defaults
latitude: 0,
longitude: 0,
latitudeDelta: 0,
longitudeDelta: 0,
};

let \_uniqueId = 1;

type TValueIn = number | Animated.Value | undefined;

type Props = Partial<Region> | undefined;

const getAnimatedValue = (valueIn: TValueIn, fallback: number) => {
if (valueIn instanceof Animated.Value) {
return valueIn;
} else if (typeof valueIn === 'number') {
return new Animated.Value(valueIn);
}
return new Animated.Value(fallback);
};

export default class AnimatedMapRegion extends AnimatedWithChildren {
constructor(valueIn: Props = {}) {
super();
this.latitude = getAnimatedValue(valueIn.latitude, defaultValues.latitude);
this.longitude = getAnimatedValue(
valueIn.longitude,
defaultValues.longitude,
);
this.latitudeDelta = getAnimatedValue(
valueIn.latitudeDelta,
defaultValues.latitudeDelta,
);
this.longitudeDelta = getAnimatedValue(
valueIn.longitudeDelta,
defaultValues.longitudeDelta,
);
this.\_regionListeners = {};
}

setValue(value: Region) {
this.latitude.\_value = value.latitude;
this.longitude.\_value = value.longitude;
this.latitudeDelta.\_value = value.latitudeDelta;
this.longitudeDelta.\_value = value.longitudeDelta;
}

setOffset(offset: Region) {
this.latitude.setOffset(offset.latitude);
this.longitude.setOffset(offset.longitude);
this.latitudeDelta.setOffset(offset.latitudeDelta);
this.longitudeDelta.setOffset(offset.longitudeDelta);
}

flattenOffset() {
this.latitude.flattenOffset();
this.longitude.flattenOffset();
this.latitudeDelta.flattenOffset();
this.longitudeDelta.flattenOffset();
}

private **getValue() {
return {
latitude: this.latitude.**getValue(),
longitude: this.longitude.**getValue(),
latitudeDelta: this.latitudeDelta.**getValue(),
longitudeDelta: this.longitudeDelta.\_\_getValue(),
};
}

private **attach() {
this.latitude.**addChild(this);
this.longitude.**addChild(this);
this.latitudeDelta.**addChild(this);
this.longitudeDelta.\_\_addChild(this);
}

private **detach() {
this.latitude.**removeChild(this);
this.longitude.**removeChild(this);
this.latitudeDelta.**removeChild(this);
this.longitudeDelta.\_\_removeChild(this);
}

stopAnimation(callback: (region: Region) => void) {
this.latitude.stopAnimation();
this.longitude.stopAnimation();
this.latitudeDelta.stopAnimation();
this.longitudeDelta.stopAnimation();
callback && callback(this.\_\_getValue());
}

addListener(callback: (region: Region) => void) {
const id = String(\_uniqueId++);
const jointCallback = () => /_{value}_/ callback(this.\_\_getValue());
this.\_regionListeners[id] = {
latitude: this.latitude.addListener(jointCallback),
longitude: this.longitude.addListener(jointCallback),
latitudeDelta: this.latitudeDelta.addListener(jointCallback),
longitudeDelta: this.longitudeDelta.addListener(jointCallback),
};
return id;
}

removeListener(id: string) {
this.latitude.removeListener(this.\_regionListeners[id].latitude);
this.longitude.removeListener(this.\_regionListeners[id].longitude);
this.latitudeDelta.removeListener(this.\_regionListeners[id].latitudeDelta);
this.longitudeDelta.removeListener(
this.\_regionListeners[id].longitudeDelta,
);
delete this.\_regionListeners[id];
}

spring(config: Animated.SpringAnimationConfig & Region) {
const animations = [];
for (const type of configTypes) {
if (config.hasOwnProperty(type)) {
animations.push(
Animated.spring(this[type], {
...config,
toValue: config[type],
// may help to eliminate some dev warnings and perf issues
useNativeDriver: !!config?.useNativeDriver,
}),
);
}
}
return Animated.parallel(animations);
}

timing(config: Animated.TimingAnimationConfig & Region) {
const animations = [];
for (const type of configTypes) {
if (config.hasOwnProperty(type)) {
animations.push(
Animated.timing(this[type], {
...config,
toValue: config[type],
// may help to eliminate some dev warnings and perf issues
useNativeDriver: !!config?.useNativeDriver,
}),
);
}
}
return Animated.parallel(animations);
}
}
</file>

<file path="src/decorateMapComponent.ts">
import {createContext} from 'react';
import {
  requireNativeComponent,
  NativeModules,
  Platform,
  UIManager,
  HostComponent,
} from 'react-native';
import {PROVIDER_DEFAULT, PROVIDER_GOOGLE} from './ProviderConstants';
import {Provider} from './sharedTypes';
import {MapCallout} from './MapCallout';
import {MapOverlay} from './MapOverlay';
import {MapCalloutSubview} from './MapCalloutSubview';
import {MapCircle} from './MapCircle';
import {MapHeatmap} from './MapHeatmap';
import {MapLocalTile} from './MapLocalTile';
import {MapMarker} from './MapMarker';
import {MapPolygon} from './MapPolygon';
import {MapPolyline} from './MapPolyline';
import {MapUrlTile} from './MapUrlTile';
import {MapWMSTile} from './MapWMSTile';
import {Commands} from './MapViewNativeComponent';

export const SUPPORTED: ImplementationStatus = 'SUPPORTED';
export const USES_DEFAULT_IMPLEMENTATION: ImplementationStatus =
'USES_DEFAULT_IMPLEMENTATION';
export const NOT_SUPPORTED: ImplementationStatus = 'NOT_SUPPORTED';

export const ProviderContext = createContext<Provider>(undefined);

export function getNativeMapName(provider: Provider) {
if (Platform.OS === 'android') {
return 'AIRMap';
}
if (provider === PROVIDER_GOOGLE) {
return 'AIRGoogleMap';
}
return 'AIRMap';
}

function getNativeComponentName(provider: Provider, component: ComponentName) {
return `${getNativeMapName(provider)}${component}`;
}

export const createNotSupportedComponent = (message: string) => () => {
console.error(message);
return null;
};

export const googleMapIsInstalled = !!UIManager.hasViewManagerConfig(
getNativeMapName(PROVIDER_GOOGLE),
);

export default function decorateMapComponent<Type extends Component>(
Component: Type,
componentName: ComponentName,
providers: Providers,
): Type {
const components: {
[key: string]: NativeComponent;
} = {};

const getDefaultComponent = () =>
requireNativeComponent(getNativeComponentName(undefined, componentName));

Component.contextType = ProviderContext;

Component.prototype.getNativeComponent =
function getNativeComponent(): NativeComponent {
const provider = this.context;
const key = provider || 'default';
if (components[key]) {
return components[key];
}

      if (provider === PROVIDER_DEFAULT) {
        components[key] = getDefaultComponent();
        return components[key];
      }

      const providerInfo = providers[provider];
      // quick fix. Previous code assumed android | ios
      if (Platform.OS !== 'android' && Platform.OS !== 'ios') {
        throw new Error(`react-native-maps doesn't support ${Platform.OS}`);
      }
      const platformSupport = providerInfo[Platform.OS];
      const nativeComponentName = getNativeComponentName(
        provider,
        componentName,
      );
      if (platformSupport === NOT_SUPPORTED) {
        components[key] = createNotSupportedComponent(
          `react-native-maps: ${nativeComponentName} is not supported on ${Platform.OS}`,
        );
      } else if (platformSupport === SUPPORTED) {
        if (
          provider !== PROVIDER_GOOGLE ||
          (Platform.OS === 'ios' && googleMapIsInstalled)
        ) {
          components[key] = requireNativeComponent(nativeComponentName);
        }
      } else {
        // (platformSupport === USES_DEFAULT_IMPLEMENTATION)
        if (!components.default) {
          components.default = getDefaultComponent();
        }
        components[key] = components.default;
      }

      return components[key];
    };

Component.prototype.getUIManagerCommand = function getUIManagerCommand(
name: string,
): UIManagerCommand {
const nativeComponentName = getNativeComponentName(
this.context,
componentName,
);
return UIManager.getViewManagerConfig(nativeComponentName).Commands[name];
};

Component.prototype.getMapManagerCommand = function getMapManagerCommand(
name: string,
): MapManagerCommand {
const nativeComponentName = `${getNativeComponentName(
      this.context,
      componentName,
    )}Manager`;
return NativeModules[nativeComponentName][name];
};

return Component;
}

type ImplementationStatus =
| 'SUPPORTED'
| 'USES_DEFAULT_IMPLEMENTATION'
| 'NOT_SUPPORTED';

type Providers = {
google: {
ios: ImplementationStatus;
android: ImplementationStatus;
};
};

export type UIManagerCommand = number;

export type MapManagerCommand = keyof typeof Commands;

export type NativeComponent<H = unknown> =
| HostComponent<H>
| ReturnType<typeof createNotSupportedComponent>;

type Component =
| typeof MapCallout
| typeof MapCalloutSubview
| typeof MapCircle
| typeof MapHeatmap
| typeof MapLocalTile
| typeof MapMarker
| typeof MapOverlay
| typeof MapPolygon
| typeof MapPolyline
| typeof MapUrlTile
| typeof MapWMSTile;

type ComponentName =
| 'Callout'
| 'CalloutSubview'
| 'Circle'
| 'Heatmap'
| 'LocalTile'
| 'Marker'
| 'Overlay'
| 'Polygon'
| 'Polyline'
| 'UrlTile'
| 'WMSTile';
</file>

<file path="src/Geojson.tsx">
import * as React from 'react';
import {
  Feature,
  FeatureCollection,
  Point,
  Position,
  MultiPoint,
  LineString,
  MultiLineString,
  Polygon,
  MultiPolygon,
} from 'geojson';
import Marker, {MapMarkerProps as MarkerProps} from './MapMarker';
import {MapPolygonProps as PolygonProps} from './MapPolygon';
import {MapPolylineProps as PolylineProps} from './MapPolyline';
import Polyline from './MapPolyline';
import MapPolygon from './MapPolygon';
import {LatLng} from './sharedTypes';

export type GeojsonProps = {
/\*\*

- Sets the anchor point for the marker.
- The anchor specifies the point in the icon image that is anchored to the marker's position on the Earth's surface.
-
- The anchor point is specified in the continuous space [0.0, 1.0] x [0.0, 1.0],
- where (0, 0) is the top-left corner of the image, and (1, 1) is the bottom-right corner.
-
- The anchoring point in a W x H image is the nearest discrete grid point in a (W + 1) x (H + 1) grid, obtained by scaling the then rounding.
- For example, in a 4 x 2 image, the anchor point (0.7, 0.6) resolves to the grid point at (3, 1).
-
- @default {x: 0.5, y: 1.0}
- @platform iOS: Google Maps only. For Apple Maps, see the `centerOffset` prop
- @platform Android: Supported
  \*/
  anchor?: MarkerProps['anchor'];

/\*\*

- The offset (in points) at which to display the annotation view.
-
- By default, the center point of an annotation view is placed at the coordinate point of the associated annotation.
-
- Positive offset values move the annotation view down and to the right, while negative values move it up and to the left.
-
- @default {x: 0.0, y: 0.0}
- @platform iOS: Apple Maps only. For Google Maps, see the `anchor` prop
- @platform Android: Not supported. See see the `anchor` prop
  \*/
  centerOffset?: MarkerProps['centerOffset'];

/\*\*

- The pincolor used on markers
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  color?: MarkerProps['pinColor'];

/\*\*

- The fill color to use for the path.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  fillColor?: PolygonProps['fillColor'];

/\*\*

- [Geojson](https://geojson.org/) description of object.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  geojson: FeatureCollection;

/\*\*

- A custom image to be used as the marker's icon. Only local image resources are allowed to be
- used.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  image?: MarkerProps['image'];

/\*\*

- The line cap style to apply to the open ends of the path.
- The default style is `round`.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  lineCap?: PolylineProps['lineCap'];

/\*\*

- An array of numbers specifying the dash pattern to use for the path.
-
- The array contains one or more numbers that indicate the lengths (measured in points) of the
- line segments and gaps in the pattern. The values in the array alternate, starting with the
- first line segment length, followed by the first gap length, followed by the second line
- segment length, and so on.
-
- This property is set to `null` by default, which indicates no line dash pattern.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  lineDashPattern?:
  | PolygonProps['lineDashPattern']
  | PolylineProps['lineDashPattern'];

/\*\*

- The offset (in points) at which to start drawing the dash pattern.
-
- Use this property to start drawing a dashed line partway through a segment or gap. For
- example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the
- middle of the first gap.
-
- The default value of this property is 0.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineDashPhase?: PolylineProps['lineDashPhase'];

/\*\*

- The line join style to apply to corners of the path.
- The default style is `round`.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineJoin?: PolylineProps['lineJoin'];

/\*\*

- Component to render in place of the default marker when the overlay type is a `point`
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  markerComponent?: MarkerProps['children'];

/\*\*

- The limiting value that helps avoid spikes at junctions between connected line segments.
- The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If
- the ratio of the miter lengththat is, the diagonal length of the miter jointo the line
- thickness exceeds the miter limit, the joint is converted to a bevel join. The default
- miter limit is 10, which results in the conversion of miters whose angle at the joint
- is less than 11 degrees.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  miterLimit?: PolylineProps['miterLimit'];

/\*\*

- Callback that is called when the user presses any of the overlays
  \*/
  onPress?: (event: OverlayPressEvent) => void;

/\*\*

- The stroke color to use for the path.
-
- @platform  iOS: Supported
- @platform  Android: Supported
  \*/
  strokeColor?: PolygonProps['strokeColor'] | PolylineProps['strokeColor'];

/\*\*

- The stroke width to use for the path.
-
- @platform  iOS: Supported
- @platform  Android: Supported
  \*/
  strokeWidth?: PolygonProps['strokeWidth'] | PolylineProps['strokeWidth'];

/\*\*

- Make the `Polygon` or `Polyline` tappable
-
- @platform  iOS: Google Maps only
- @platform  Android: Supported
  \*/
  tappable?: PolygonProps['tappable'] | PolylineProps['tappable'];

/\*\*

- The title of the marker. This is only used if the <Marker /> component has no children that
- are a `<Callout />`, in which case the default callout behavior will be used, which
- will show both the `title` and the `description`, if provided.
-
- @platform  iOS: Supported
- @platform  Android: Supported
  \*/
  title?: MarkerProps['title'];

/\*\*

- Sets whether this marker should track view changes.
- It's recommended to turn it off whenever it's possible to improve custom marker performance.
- This is the default value for all point markers in your geojson data. It can be overriden
- on a per point basis by adding a `trackViewChanges` property to the `properties` object on the point.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  tracksViewChanges?: boolean;

/\*\*

- The order in which this tile overlay is drawn with respect to other overlays. An overlay
- with a larger z-index is drawn over overlays with smaller z-indices. The order of overlays
- with the same z-index is arbitrary. The default zIndex is 0.
-
- @platform iOS: Apple Maps: [Marker], Google Maps: [Marker, Polygon, Polyline]
- @platform Android: Supported
  \*/
  zIndex?:
  | MarkerProps['zIndex']
  | PolygonProps['zIndex']
  | PolylineProps['zIndex'];
  };

const Geojson = (props: GeojsonProps) => {
const {
anchor,
centerOffset,
geojson,
strokeColor,
fillColor,
strokeWidth,
color,
title,
image,
zIndex,
onPress,
lineCap,
lineJoin,
tappable,
tracksViewChanges,
miterLimit,
lineDashPhase,
lineDashPattern,
markerComponent,
} = props;
const pointOverlays = makePointOverlays(geojson.features);
const lineOverlays = makeLineOverlays(geojson.features);
const polygonOverlays = makePolygonOverlays(geojson.features);
return (
<React.Fragment>
{pointOverlays.map((overlay, index) => {
const markerColor = getColor(color, overlay, 'marker-color');
const pointOverlayTracksViewChanges =
overlay.feature.properties?.tracksViewChanges || tracksViewChanges;
return (
<Marker
key={index}
coordinate={overlay.coordinates}
tracksViewChanges={pointOverlayTracksViewChanges}
image={image}
title={title}
pinColor={markerColor}
zIndex={zIndex}
anchor={anchor}
centerOffset={centerOffset}
onPress={() => onPress && onPress(overlay)}>
{markerComponent}
</Marker>
);
})}
{lineOverlays.map((overlay, index) => {
const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');
const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);

        return (
          <Polyline
            key={index}
            coordinates={overlay.coordinates}
            strokeColor={lineStrokeColor}
            strokeWidth={lineStrokeWidth}
            lineDashPhase={lineDashPhase}
            lineDashPattern={lineDashPattern}
            lineCap={lineCap}
            lineJoin={lineJoin}
            miterLimit={miterLimit}
            zIndex={zIndex}
            tappable={tappable}
            onPress={() => onPress && onPress(overlay)}
          />
        );
      })}
      {polygonOverlays.map((overlay, index) => {
        const polygonFillColor = getColor(fillColor, overlay, 'fill');
        const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');
        const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);

        return (
          <MapPolygon
            key={index}
            coordinates={overlay.coordinates}
            holes={overlay.holes}
            strokeColor={lineStrokeColor}
            fillColor={polygonFillColor}
            strokeWidth={lineStrokeWidth}
            lineDashPhase={lineDashPhase}
            lineDashPattern={lineDashPattern}
            lineCap={lineCap}
            lineJoin={lineJoin}
            miterLimit={miterLimit}
            tappable={tappable}
            onPress={() => onPress && onPress(overlay)}
            zIndex={zIndex}
          />
        );
      })}
    </React.Fragment>

);
};

export default Geojson;

const makePointOverlays = (features: Feature[]): AnyPointOverlay[] => {
return features
.filter(isAnyPointFeature)
.map(feature =>
makeCoordinatesForAnyPoint(feature.geometry).map(coordinates =>
makeOverlayForAnyPoint(coordinates, feature),
),
)
.reduce((prev, curr) => prev.concat(curr), [])
.map(overlay => ({...overlay, type: 'point'}));
};

const makeLineOverlays = (features: Feature[]): AnyLineStringOverlay[] => {
return features
.filter(isAnyLineStringFeature)
.map(feature =>
makeCoordinatesForAnyLine(feature.geometry).map(coordinates =>
makeOverlayForAnyLine(coordinates, feature),
),
)
.reduce((prev, curr) => prev.concat(curr), [])
.map(overlay => ({...overlay, type: 'polyline'}));
};

const makePolygonOverlays = (features: Feature[]): AnyPolygonOverlay[] => {
const multipolygons: AnyPolygonOverlay[] = features
.filter(isMultiPolygonFeature)
.map(feature =>
makeCoordinatesForMultiPolygon(feature.geometry).map(coordinates =>
makeOverlayForAnyPolygon(coordinates, feature),
),
)
.reduce((prev, curr) => prev.concat(curr), [])
.map(overlay => ({...overlay, type: 'polygon'}));

const polygons: AnyPolygonOverlay[] = features
.filter(isPolygonFeature)
.map(feature =>
makeOverlayForAnyPolygon(
makeCoordinatesForPolygon(feature.geometry),
feature,
),
)
.reduce<Omit<AnyPolygonOverlay, 'type'>[]>(
(prev, curr) => prev.concat(curr),
[],
)
.map(overlay => ({...overlay, type: 'polygon'}));

return polygons.concat(multipolygons);
};

const makeOverlayForAnyPoint = (
coordinates: LatLng,
feature: Feature<Point | MultiPoint>,
): Omit<AnyPointOverlay, 'type'> => {
return {feature, coordinates};
};

const makeOverlayForAnyLine = (
coordinates: LatLng[],
feature: Feature<LineString | MultiLineString>,
): Omit<AnyLineStringOverlay, 'type'> => {
return {feature, coordinates};
};

const makeOverlayForAnyPolygon = (
coordinates: LatLng[][],
feature: Feature<Polygon | MultiPolygon>,
): Omit<AnyPolygonOverlay, 'type'> => {
return {
feature,
coordinates: coordinates[0],
holes: coordinates.length > 1 ? coordinates.slice(1) : undefined,
};
};

const makePoint = (c: Position): LatLng => ({
latitude: c[1],
longitude: c[0],
});

const makeLine = (l: Position[]) => l.map(makePoint);

const makeCoordinatesForAnyPoint = (geometry: Point | MultiPoint) => {
if (geometry.type === 'Point') {
return [makePoint(geometry.coordinates)];
}
return geometry.coordinates.map(makePoint);
};

const makeCoordinatesForAnyLine = (geometry: LineString | MultiLineString) => {
if (geometry.type === 'LineString') {
return [makeLine(geometry.coordinates)];
}
return geometry.coordinates.map(makeLine);
};

const makeCoordinatesForPolygon = (geometry: Polygon) => {
return geometry.coordinates.map(makeLine);
};

const makeCoordinatesForMultiPolygon = (geometry: MultiPolygon) => {
return geometry.coordinates.map(p => p.map(makeLine));
};

const getRgbaFromHex = (hex: string, alpha: number = 1) => {
const matchArray = hex.match(/\w\w/g);
if (!matchArray || matchArray.length < 3) {
throw new Error('Invalid hex string');
}
const [r, g, b] = matchArray.map(x => {
const subColor = parseInt(x, 16);
if (Number.isNaN(subColor)) {
throw new Error('Invalid hex string');
}
return subColor;
});
return `rgba(${r},${g},${b},${alpha})`;
};

const getColor = (
prop: string | undefined,
overlay: Overlay,
colorType: string,
) => {
if (prop) {
return prop;
}
let color = overlay.feature.properties?.[colorType];
if (color) {
const opacityProperty = colorType + '-opacity';
const alpha = overlay.feature.properties?.[opacityProperty];
if (alpha && alpha !== '0' && color[0] === '#') {
color = getRgbaFromHex(color, alpha);
}
return color;
}
return undefined;
};

const getStrokeWidth = (
prop: GeojsonProps['strokeWidth'],
overlay: Overlay,
) => {
if (prop) {
return prop;
}
return overlay.feature.properties?.['stroke-width'];
};

// GeoJSON.Feature type-guards
const isPointFeature = (feature: Feature): feature is Feature<Point> =>
feature.geometry.type === 'Point';

const isMultiPointFeature = (
feature: Feature,
): feature is Feature<MultiPoint> => feature.geometry.type === 'MultiPoint';

const isAnyPointFeature = (
feature: Feature,
): feature is Feature<Point> | Feature<MultiPoint> =>
isPointFeature(feature) || isMultiPointFeature(feature);

const isLineStringFeature = (
feature: Feature,
): feature is Feature<LineString> => feature.geometry.type === 'LineString';

const isMultiLineStringFeature = (
feature: Feature,
): feature is Feature<MultiLineString> =>
feature.geometry.type === 'MultiLineString';

const isAnyLineStringFeature = (
feature: Feature,
): feature is Feature<LineString> | Feature<MultiLineString> =>
isLineStringFeature(feature) || isMultiLineStringFeature(feature);

const isPolygonFeature = (feature: Feature): feature is Feature<Polygon> =>
feature.geometry.type === 'Polygon';

const isMultiPolygonFeature = (
feature: Feature,
): feature is Feature<MultiPolygon> => feature.geometry.type === 'MultiPolygon';

type OverlayPressEvent = {
type:
| AnyPointOverlay['type']
| AnyLineStringOverlay['type']
| AnyPolygonOverlay['type'];
feature:
| AnyPointOverlay['feature']
| AnyLineStringOverlay['feature']
| AnyPolygonOverlay['feature'];
coordinates:
| AnyPointOverlay['coordinates']
| AnyLineStringOverlay['coordinates']
| AnyPolygonOverlay['coordinates'];
holes?: AnyPolygonOverlay['holes'];
};

type AnyPointOverlay = {
type: 'point';
feature: Feature<Point | MultiPoint>;
coordinates: LatLng;
};

type AnyLineStringOverlay = {
type: 'polyline';
feature: Feature<LineString | MultiLineString>;
coordinates: LatLng[];
};

type AnyPolygonOverlay = {
type: 'polygon';
feature: Feature<Polygon | MultiPolygon>;
coordinates: LatLng[];
holes?: LatLng[][];
};

type Overlay = {
type: 'point' | 'polyline' | 'polygon';
feature: Feature;
coordinates: LatLng | LatLng[];
holes?: LatLng[][];
};
</file>

<file path="src/index.ts">
import MapView, {
  AnimatedMapView as Animated,
  MAP_TYPES,
  MapViewProps,
} from './MapView';

import Marker from './MapMarker';
export {MapMarker} from './MapMarker';
export type {MapMarkerProps} from './MapMarker';

import Overlay from './MapOverlay';
export {MapOverlay} from './MapOverlay';
export type {MapOverlayProps} from './MapOverlay';

export {default as Polyline, MapPolyline} from './MapPolyline';
export type {MapPolylineProps} from './MapPolyline';
export {default as Heatmap, MapHeatmap} from './MapHeatmap';
export type {MapHeatmapProps} from './MapHeatmap';
export {default as Polygon, MapPolygon} from './MapPolygon';
export type {MapPolygonProps} from './MapPolygon';
export {default as Circle, MapCircle} from './MapCircle';
export type {MapCircleProps} from './MapCircle';
export {default as UrlTile, MapUrlTile} from './MapUrlTile';
export type {MapUrlTileProps} from './MapUrlTile';
export {default as WMSTile, MapWMSTile} from './MapWMSTile';
export type {MapWMSTileProps} from './MapWMSTile';
export {default as LocalTile, MapLocalTile} from './MapLocalTile';
export type {MapLocalTileProps} from './MapLocalTile';
export {default as Callout, MapCallout} from './MapCallout';
export type {MapCalloutProps} from './MapCallout';
export {
default as CalloutSubview,
MapCalloutSubview,
} from './MapCalloutSubview';
export type {MapCalloutSubviewProps} from './MapCalloutSubview';
export {default as AnimatedRegion} from './AnimatedRegion';
export {default as Geojson} from './Geojson';
export type {GeojsonProps} from './Geojson';

export {Marker, Overlay};
export type {MapViewProps};
export {Animated, MAP_TYPES};

export _ from './ProviderConstants';
export _ from './MapView.types';
export _ from './MapPolygon.types';
export _ from './sharedTypes';

export const MarkerAnimated = Marker.Animated;
export const OverlayAnimated = Overlay.Animated;

export default MapView;
</file>

<file path="src/MapCallout.tsx">
import * as React from 'react';
import {StyleSheet, ViewProps} from 'react-native';
import decorateMapComponent, {
  MapManagerCommand,
  NativeComponent,
  ProviderContext,
  SUPPORTED,
  UIManagerCommand,
  USES_DEFAULT_IMPLEMENTATION,
} from './decorateMapComponent';
import {CalloutPressEvent} from './sharedTypes';

export type MapCalloutProps = ViewProps & {
/\*\*

- If `true`, clicks on transparent areas in callout will be passed to map.
-
- @default false
- @platform iOS: Supported
- @platform Android: Not supported
  \*/
  alphaHitTest?: boolean;

/\*\*

- Callback that is called when the user presses on the callout
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onPress?: (event: CalloutPressEvent) => void;

/\*\*

- If `false`, a default "tooltip" bubble window will be drawn around this callouts children.
- If `true`, the child views can fully customize their appearance, including any "bubble" like styles.
-
- @default false
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  tooltip?: boolean;
  };

type NativeProps = MapCalloutProps;

export class MapCallout extends React.Component<MapCalloutProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

render() {
const {tooltip = false, alphaHitTest = false} = this.props;
const AIRMapCallout = this.getNativeComponent();
return (
<AIRMapCallout
{...this.props}
tooltip={tooltip}
alphaHitTest={alphaHitTest}
style={[styles.callout, this.props.style]}
/>
);
}
}

const styles = StyleSheet.create({
callout: {
position: 'absolute',
},
});

export default decorateMapComponent(MapCallout, 'Callout', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});
</file>

<file path="src/MapCalloutSubview.tsx">
import * as React from 'react';
import {NativeSyntheticEvent, StyleSheet, ViewProps} from 'react-native';
import decorateMapComponent, {
  SUPPORTED,
  NOT_SUPPORTED,
  ProviderContext,
  NativeComponent,
  MapManagerCommand,
  UIManagerCommand,
} from './decorateMapComponent';
import {Frame, Point} from './sharedTypes';

export type MapCalloutSubviewProps = ViewProps & {
/\*\*

- Callback that is called when the user presses on this subview inside callout
-
- @platform iOS: Supported
- @platform Android: Not supported
  \*/
  onPress?: (event: CalloutSubviewPressEvent) => void;
  };

type NativeProps = MapCalloutSubviewProps;

export class MapCalloutSubview extends React.Component<MapCalloutSubviewProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;
render() {
const AIRMapCalloutSubview = this.getNativeComponent();
return (
<AIRMapCalloutSubview
{...this.props}
style={[styles.calloutSubview, this.props.style]}
/>
);
}
}

const styles = StyleSheet.create({
calloutSubview: {},
});

export default decorateMapComponent(MapCalloutSubview, 'CalloutSubview', {
google: {
ios: SUPPORTED,
android: NOT_SUPPORTED,
},
});

type CalloutSubviewPressEvent = NativeSyntheticEvent<{
/\*\*

- Apple Maps: `callout-inside-press`
-
- Google Maps: `marker-inside-overlay-press`
  \*/
  action: 'callout-inside-press' | 'marker-inside-overlay-press';
  frame: Frame;
  id: string;
  point: Point;
  }>;
  </file>

<file path="src/MapCircle.tsx">
import * as React from 'react';
import {View, ViewProps} from 'react-native';
import decorateMapComponent, {
  USES_DEFAULT_IMPLEMENTATION,
  SUPPORTED,
  ProviderContext,
  NativeComponent,
  MapManagerCommand,
  UIManagerCommand,
} from './decorateMapComponent';
import {LatLng, LineCapType, LineJoinType} from './sharedTypes';

export type MapCircleProps = ViewProps & {
/\*\*

- The coordinates of the center of the circle.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  center: LatLng;

/\*\*

- The fill color to use for the path.
-
- @default `#000`, `rgba(r,g,b,0.5)`
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  fillColor?: string;

/\*\*

- The line cap style to apply to the open ends of the path
-
- @default `round`
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineCap?: LineCapType;

/\*\*

- An array of numbers specifying the dash pattern to use for the path.
- The array contains one or more numbers that indicate the lengths (measured in points)
- of the line segments and gaps in the pattern.
- The values in the array alternate, starting with the first line segment length,
- followed by the first gap length, followed by the second line segment length, and so on.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineDashPattern?: number[];

/\*\*

- The offset (in points) at which to start drawing the dash pattern.
- Use this property to start drawing a dashed line partway through a segment or gap.
- For example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the middle of the first gap.
-
- @default 0
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineDashPhase?: number;

/\*\*

- The line join style to apply to corners of the path.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineJoin?: LineJoinType;

/\*\*

- The limiting value that helps avoid spikes at junctions between connected line segments.
- The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style.
- If the ratio of the miter lengththat is, the diagonal length of the miter jointo the line thickness exceeds the miter limit,
- the joint is converted to a bevel join.
- The default miter limit is 10, which results in the conversion of miters whose angle at the joint is less than 11 degrees.
-
- @default 10
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  miterLimit?: number;

/\*\*

- The radius of the circle to be drawn (in meters)
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  radius: number;

/\*\*

- The stroke color to use for the path.
-
- @default `#000`, `rgba(r,g,b,0.5)`
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  strokeColor?: string;

/\*\*

- The stroke width to use for the path.
-
- @default 1
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  strokeWidth?: number;

/\*\*

- The order in which this tile overlay is drawn with respect to other overlays.
- An overlay with a larger z-index is drawn over overlays with smaller z-indices.
- The order of overlays with the same z-index is arbitrary.
-
- @default 0
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  zIndex?: number;
  };

type NativeProps = MapCircleProps & {ref: React.RefObject<View>};

export class MapCircle extends React.Component<MapCircleProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

private circle: NativeProps['ref'];

constructor(props: MapCircleProps) {
super(props);
this.circle = React.createRef<View>();
}

setNativeProps(props: Partial<NativeProps>) {
this.circle.current?.setNativeProps(props);
}

render() {
const {strokeColor = '#000', strokeWidth = 1} = this.props;
const AIRMapCircle = this.getNativeComponent();
return (
<AIRMapCircle
{...this.props}
strokeColor={strokeColor}
strokeWidth={strokeWidth}
ref={this.circle}
/>
);
}
}

export default decorateMapComponent(MapCircle, 'Circle', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});
</file>

<file path="src/MapHeatmap.tsx">
import * as React from 'react';
import {processColor, ProcessedColorValue, View, ViewProps} from 'react-native';
import decorateMapComponent, {
  MapManagerCommand,
  NativeComponent,
  ProviderContext,
  SUPPORTED,
  UIManagerCommand,
  USES_DEFAULT_IMPLEMENTATION,
} from './decorateMapComponent';
import {LatLng} from './sharedTypes';
import {Modify} from './sharedTypesInternal';

export type MapHeatmapProps = ViewProps & {
gradient?: {
/\*\*
_ Resolution of color map -- number corresponding to the number of steps colors are interpolated into.
_
_ @default 256
_ @platform iOS: Google Maps only
_ @platform Android: Supported
_/
colorMapSize: number;

    /**
     * Colors (one or more) to used for gradient.
     *
     * @platform iOS: Google Maps only
     * @platform Android: Supported
     */
    colors: string[];

    /**
     * Array of floating point values from 0 to 1 representing where each color starts.
     *
     * Array length must be equal to `colors` array length.
     *
     * @platform iOS: Google Maps only
     * @platform Android: Supported
     */
    startPoints: number[];

};

/\*\*

- The opacity of the heatmap.
-
- @default 0.7
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  opacity?: number;

/\*\*

- Array of heatmap entries to apply towards density.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  points?: WeightedLatLng[];

/\*\*

- The radius of the heatmap points in pixels, between 10 and 50.
-
- @default 20
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  radius?: number;
  };

type NativeProps = Modify<
MapHeatmapProps,
{
gradient?: Modify<
MapHeatmapProps['gradient'],
{colors: (ProcessedColorValue | null | undefined)[]} >;
}

> & {
> ref: React.RefObject<View>;
> };

export class MapHeatmap extends React.Component<MapHeatmapProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

private heatmap: NativeProps['ref'];

constructor(props: MapHeatmapProps) {
super(props);
this.heatmap = React.createRef<View>();
}

setNativeProps(props: Partial<NativeProps>) {
this.heatmap.current?.setNativeProps(props);
}

render() {
const AIRMapHeatmap = this.getNativeComponent();
const propGradient = this.props.gradient;
let gradient: NativeProps['gradient'];
if (propGradient) {
const colors = propGradient.colors.map(c => processColor(c));
gradient = {...propGradient, colors};
}
return (
<AIRMapHeatmap {...this.props} gradient={gradient} ref={this.heatmap} />
);
}
}

export default decorateMapComponent(MapHeatmap, 'Heatmap', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});

type WeightedLatLng = LatLng & {
weight?: number;
};
</file>

<file path="src/MapLocalTile.tsx">
import * as React from 'react';
import {ViewProps} from 'react-native';

import decorateMapComponent, {
USES_DEFAULT_IMPLEMENTATION,
SUPPORTED,
ProviderContext,
NativeComponent,
MapManagerCommand,
UIManagerCommand,
} from './decorateMapComponent';

export type MapLocalTileProps = ViewProps & {
/\*\*

- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  pathTemplate: string;

/\*\*

- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  tileSize?: number;

/\*\*

- Set to true to use pathTemplate to open files from Android's AssetManager. The default is false.
- @platform android
  \*/
  useAssets?: boolean;

/\*\*

- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  zIndex?: number;
  };

type NativeProps = MapLocalTileProps;

export class MapLocalTile extends React.Component<MapLocalTileProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

render() {
const AIRMapLocalTile = this.getNativeComponent();
return <AIRMapLocalTile {...this.props} />;
}
}

export default decorateMapComponent(MapLocalTile, 'LocalTile', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});
</file>

<file path="src/MapMarker.tsx">
import * as React from 'react';
import {
  StyleSheet,
  Animated,
  Image,
  ViewProps,
  ImageURISource,
  ImageRequireSource,
} from 'react-native';

import decorateMapComponent, {
MapManagerCommand,
NativeComponent,
ProviderContext,
SUPPORTED,
UIManagerCommand,
USES_DEFAULT_IMPLEMENTATION,
} from './decorateMapComponent';
import {
Commands,
MapMarkerNativeComponentType,
} from './MapMarkerNativeComponent';
import {
CalloutPressEvent,
LatLng,
MarkerDeselectEvent,
MarkerDragEvent,
MarkerDragStartEndEvent,
MarkerPressEvent,
MarkerSelectEvent,
Point,
} from './sharedTypes';
import {Modify} from './sharedTypesInternal';

type AppleMarkerVisibility = 'hidden' | 'adaptive' | 'visible';

export type MapMarkerProps = ViewProps & {
/\*\*

- Sets the anchor point for the marker.
- The anchor specifies the point in the icon image that is anchored to the marker's position on the Earth's surface.
-
- The anchor point is specified in the continuous space [0.0, 1.0] x [0.0, 1.0],
- where (0, 0) is the top-left corner of the image, and (1, 1) is the bottom-right corner.
-
- The anchoring point in a W x H image is the nearest discrete grid point in a (W + 1) x (H + 1) grid, obtained by scaling the then rounding.
- For example, in a 4 x 2 image, the anchor point (0.7, 0.6) resolves to the grid point at (3, 1).
-
- @default {x: 0.5, y: 1.0}
- @platform iOS: Google Maps only. For Apple Maps, see the `centerOffset` prop
- @platform Android: Supported
  \*/
  anchor?: Point;

/\*\*

- Specifies the point in the marker image at which to anchor the callout when it is displayed.
- This is specified in the same coordinate system as the anchor.
-
- See the `anchor` prop for more details.
-
- @default {x: 0.5, y: 0.0}
- @platform iOS: Google Maps only. For Apple Maps, see the `calloutOffset` prop
- @platform Android: Supported
  \*/
  calloutAnchor?: Point;

/\*\*

- The offset (in points) at which to place the callout bubble.
- When this property is set to (0, 0),
- the anchor point of the callout bubble is placed on the top-center point of the marker views frame.
-
- Specifying positive offset values moves the callout bubble down and to the right,
- while specifying negative values moves it up and to the left
-
- @default {x: 0.0, y: 0.0}
- @platform iOS: Apple Maps only. For Google Maps, see the `calloutAnchor` prop
- @platform Android: Not supported. See see the `calloutAnchor` prop
  \*/
  calloutOffset?: Point;

/\*\*

- The offset (in points) at which to display the annotation view.
-
- By default, the center point of an annotation view is placed at the coordinate point of the associated annotation.
-
- Positive offset values move the annotation view down and to the right, while negative values move it up and to the left.
-
- @default {x: 0.0, y: 0.0}
- @platform iOS: Apple Maps only. For Google Maps, see the `anchor` prop
- @platform Android: Not supported. See see the `anchor` prop
  \*/
  centerOffset?: Point;

/\*\*

- The coordinate for the marker.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  coordinate: LatLng;

/\*\*

- The description of the marker.
-
- This is only used if the <Marker /> component has no children that are a `<Callout />`,
- in which case the default callout behavior will be used,
- which will show both the `title` and the `description`, if provided.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  description?: string;

/\*\*

- if `true` allows the marker to be draggable (re-positioned).
-
- @default false
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  draggable?: boolean;

/\*\*

- Sets whether this marker should be flat against the map true or a billboard facing the camera.
-
- @default false
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  flat?: boolean;

/\*\*

- Marker icon to render (equivalent to `icon` property of GMSMarker Class).
- Only local image resources are allowed to be used.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  icon?: ImageURISource | ImageRequireSource;

/\*\*

- A string that can be used to identify this marker.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  identifier?: string;

/\*\*

- A custom image to be used as the marker's icon. Only local image resources are allowed to be used.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  image?: ImageURISource | ImageRequireSource;

/\*\*

- When true, the marker will be pre-selected.
- Setting this to true allows the user to drag the marker without needing to tap on it first to focus it.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  isPreselected?: boolean;

/\*\*

- Callback that is called when the user taps the callout view.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onCalloutPress?: (event: CalloutPressEvent) => void;

/\*\*

- Callback that is called when the marker is deselected, before the callout is hidden.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  onDeselect?: (event: MarkerDeselectEvent) => void;

/\*\*

- Callback called continuously as the marker is dragged
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onDrag?: (event: MarkerDragEvent) => void;

/\*\*

- Callback that is called when a drag on the marker finishes.
- This is usually the point you will want to setState on the marker's coordinate again
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onDragEnd?: (event: MarkerDragStartEndEvent) => void;

/\*\*

- Callback that is called when the user initiates a drag on the marker (if it is draggable)
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onDragStart?: (event: MarkerDragStartEndEvent) => void;

/\*\*

- Callback that is called when the marker is tapped by the user.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onPress?: (event: MarkerPressEvent) => void;

/\*\*

- Callback that is called when the marker becomes selected.
- This will be called when the callout for that marker is about to be shown.
-
- @platform iOS: Supported.
- @platform Android: Supported
  \*/
  onSelect?: (event: MarkerSelectEvent) => void;

/\*\*

- The marker's opacity between 0.0 and 1.0.
-
- @default 1.0
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  opacity?: number;

/\*\*

- If no custom marker view or custom image is provided, the platform default pin will be used, which can be customized by this color.
- Ignored if a custom marker is being used.<br/><br/>
- For Android, the set of available colors is limited. Unsupported colors will fall back to red.
- See [#887](https://github.com/react-community/react-native-maps/issues/887) for more information.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  pinColor?: string;

/\*\*

- A float number indicating marker's rotation angle, in degrees.
-
- @default 0
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  rotation?: number;

/\*\*

- Sets whether this marker should propagate `onPress` events.
- Enabling it will stop the parent `MapView`'s `onPress` from being called.
-
- Android does not propagate `onPress` events.
-
- See [#1132](https://github.com/react-community/react-native-maps/issues/1132) for more information.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  stopPropagation?: boolean;

/\*\*

- Sets whether marker should be tappable.
- If set to false, the marker will not have onPress events.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Not supported
  \*/
  tappable?: boolean;

/\*\*

- The title of the marker.
- This is only used if the <Marker /> component has no `<Callout />` children.
-
- If the marker has <Callout /> children, default callout behavior will be used,
- which will show both the `title` and the `description`, if provided.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  title?: string;

/\*\*

- Sets whether this marker should track view changes in info window.
- Enabling it will let marker change content of info window after first render pass, but will lead to decreased performance,
- so it's recommended to disable it whenever you don't need it.
- **Note**: iOS Google Maps only.
-
- @default false
- @platform iOS: Google Maps only
- @platform Android: Not supported
  \*/
  tracksInfoWindowChanges?: boolean;

/\*\*

- Sets whether this marker should track view changes.
- It's recommended to turn it off whenever it's possible to improve custom marker performance.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  tracksViewChanges?: boolean;

/\*\*

- The order in which this tile overlay is drawn with respect to other overlays.
- An overlay with a larger z-index is drawn over overlays with smaller z-indices.
- The order of overlays with the same z-index is arbitrary.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  zIndex?: number;

/\*\*

- Visibility of the title text rendered beneath Marker balloon
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  titleVisibility?: AppleMarkerVisibility;

/\*\*

- Visibility of the subtitle text rendered beneath Marker balloon
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  subtitleVisibility?: AppleMarkerVisibility;

/\*\*

- Indicate type of default markers if it's true MKPinAnnotationView will be used and MKMarkerAnnotationView if it's false
- It doesn't change anything if you are using custom Markers
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  useLegacyPinView?: boolean;
  };

type OmittedProps = Omit<MapMarkerProps, 'stopPropagation'>;

export type NativeProps = Modify<
OmittedProps,
{icon?: string; image?: MapMarkerProps['image'] | string}

> & {
> ref: React.RefObject<MapMarkerNativeComponentType>;
> };

export class MapMarker extends React.Component<MapMarkerProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

static Animated: Animated.AnimatedComponent<typeof MapMarker>;

private marker: NativeProps['ref'];

constructor(props: MapMarkerProps) {
super(props);

    this.marker = React.createRef<MapMarkerNativeComponentType>();
    this.showCallout = this.showCallout.bind(this);
    this.hideCallout = this.hideCallout.bind(this);
    this.setCoordinates = this.setCoordinates.bind(this);
    this.redrawCallout = this.redrawCallout.bind(this);
    this.animateMarkerToCoordinate = this.animateMarkerToCoordinate.bind(this);

}

setNativeProps(props: Partial<NativeProps>) {
// @ts-ignore
this.marker.current?.setNativeProps(props);
}

showCallout() {
if (this.marker.current) {
Commands.showCallout(this.marker.current);
}
}

hideCallout() {
if (this.marker.current) {
Commands.hideCallout(this.marker.current);
}
}

setCoordinates(coordinate: LatLng) {
if (this.marker.current) {
Commands.setCoordinates(this.marker.current, coordinate);
}
}

redrawCallout() {
if (this.marker.current) {
Commands.redrawCallout(this.marker.current);
}
}

animateMarkerToCoordinate(coordinate: LatLng, duration: number = 500) {
if (this.marker.current) {
Commands.animateMarkerToCoordinate(
this.marker.current,
coordinate,
duration,
);
}
}

redraw() {
if (this.marker.current) {
Commands.redraw(this.marker.current);
}
}

render() {
const {stopPropagation = false} = this.props;
let image;
if (this.props.image) {
image = Image.resolveAssetSource(this.props.image) || {};
image = image.uri || this.props.image;
}

    let icon;
    if (this.props.icon) {
      icon = Image.resolveAssetSource(this.props.icon) || {};
      icon = icon.uri;
    }

    const AIRMapMarker = this.getNativeComponent();

    return (
      <AIRMapMarker
        {...this.props}
        ref={this.marker}
        image={image}
        icon={icon}
        style={[styles.marker, this.props.style]}
        onPress={event => {
          if (stopPropagation) {
            event.stopPropagation();
          }
          if (this.props.onPress) {
            this.props.onPress(event);
          }
        }}
      />
    );

}
}

const styles = StyleSheet.create({
marker: {
position: 'absolute',
backgroundColor: 'transparent',
},
});

MapMarker.Animated = Animated.createAnimatedComponent(MapMarker);

export default decorateMapComponent(MapMarker, 'Marker', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});
</file>

<file path="src/MapMarkerNativeComponent.ts">
import type {HostComponent} from 'react-native';
import codegenNativeCommands from 'react-native/Libraries/Utilities/codegenNativeCommands';
import {NativeProps} from './MapMarker';
import {LatLng} from './sharedTypes';

export type MapMarkerNativeComponentType = HostComponent<NativeProps>;

interface NativeCommands {
showCallout: (
viewRef: NonNullable<
React.RefObject<MapMarkerNativeComponentType>['current'] >,
) => void;
hideCallout: (
viewRef: NonNullable<
React.RefObject<MapMarkerNativeComponentType>['current'] >,
) => void;
setCoordinates: (
viewRef: NonNullable<
React.RefObject<MapMarkerNativeComponentType>['current'] >,
coordinate: LatLng,
) => void;
redrawCallout: (
viewRef: NonNullable<
React.RefObject<MapMarkerNativeComponentType>['current'] >,
) => void;
animateMarkerToCoordinate: (
viewRef: NonNullable<
React.RefObject<MapMarkerNativeComponentType>['current'] >,
coordinate: LatLng,
duration: number,
) => void;
redraw: (
viewRef: NonNullable<
React.RefObject<MapMarkerNativeComponentType>['current'] >,
) => void;
}

export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({
supportedCommands: [
'showCallout',
'hideCallout',
'redrawCallout',
'animateMarkerToCoordinate',
'redraw',
'setCoordinates',
],
});
</file>

<file path="src/MapOverlay.tsx">
import * as React from 'react';
import {
  StyleSheet,
  Image,
  Animated,
  ViewProps,
  ImageURISource,
  ImageRequireSource,
  NativeSyntheticEvent,
} from 'react-native';

import decorateMapComponent, {
MapManagerCommand,
NativeComponent,
ProviderContext,
SUPPORTED,
UIManagerCommand,
USES_DEFAULT_IMPLEMENTATION,
} from './decorateMapComponent';
import {LatLng, Point} from './sharedTypes';
import {Modify} from './sharedTypesInternal';

export type MapOverlayProps = ViewProps & {
/\*\*

- The bearing in degrees clockwise from north. Values outside the range [0, 360) will be normalized.
-
- @default 0
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  bearing?: number;

/\*\*

- The coordinates for the image (left-top corner, right-bottom corner). ie.`[[lat, long], [lat, long]]`
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  bounds: [Coordinate, Coordinate];

/\*\*

- A custom image to be used as the overlay.
- Only required local image resources and uri (as for images located in the net) are allowed to be used.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  image: ImageURISource | ImageRequireSource;

/\*\*

- Callback that is called when the user presses on the overlay
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onPress?: (event: OverlayPressEvent) => void;

/\*\*

- The opacity of the overlay.
-
- @default 1
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  opacity?: number;

/\*\*

- Boolean to allow an overlay to be tappable and use the onPress function.
-
- @default false
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  tappable?: boolean;
  };

type NativeProps = Modify<MapOverlayProps, {image?: string}>;

export class MapOverlay extends React.Component<MapOverlayProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

static Animated: Animated.AnimatedComponent<typeof MapOverlay>;

render() {
const {opacity = 1.0} = this.props;
let image: string | undefined;
if (
typeof this.props.image !== 'number' &&
this.props.image.uri?.startsWith('http')
) {
image = this.props.image.uri;
} else {
const sourceAsset = Image.resolveAssetSource(this.props.image) || {};
image = sourceAsset.uri;
}

    const AIRMapOverlay = this.getNativeComponent();

    return (
      <AIRMapOverlay
        {...this.props}
        opacity={opacity}
        image={image}
        style={[styles.overlay, this.props.style]}
      />
    );

}
}

type Coordinate = [number, number];

type OverlayPressEvent = NativeSyntheticEvent<{
/\*\*

- @platform iOS: Apple Maps: `image-overlay-press`
- @platform Android: `overlay-press`
  \*/
  action: 'overlay-press' | 'image-overlay-press';

/\*\*

- @platform iOS: Apple maps
  \*/
  name?: string;

/\*\*

- @platform iOS: Apple Maps
- @platform Android
  \*/
  coordinate?: LatLng;

/\*\*

- @platform Android
  \*/
  position?: Point;
  }>;

const styles = StyleSheet.create({
overlay: {
position: 'absolute',
backgroundColor: 'transparent',
},
});

MapOverlay.Animated = Animated.createAnimatedComponent(MapOverlay);

export default decorateMapComponent(MapOverlay, 'Overlay', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});
</file>

<file path="src/MapPolygon.tsx">
import * as React from 'react';
import {View, ViewProps} from 'react-native';
import decorateMapComponent, {
  USES_DEFAULT_IMPLEMENTATION,
  SUPPORTED,
  ProviderContext,
  NativeComponent,
  MapManagerCommand,
  UIManagerCommand,
} from './decorateMapComponent';
import {PolygonPressEvent} from './MapPolygon.types';
import {LatLng, LineCapType, LineJoinType} from './sharedTypes';

export type MapPolygonProps = ViewProps & {
/\*\*

- An array of coordinates to describe the polygon
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  coordinates: LatLng[];

/\*\*

- The fill color to use for the path.
-
- @default `#000`, `rgba(r,g,b,0.5)`
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  fillColor?: string;

/\*\*

- Boolean to indicate whether to draw each segment of the line as a geodesic as opposed to straight lines on the Mercator projection.
- A geodesic is the shortest path between two points on the Earth's surface.
- The geodesic curve is constructed assuming the Earth is a sphere.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  geodesic?: boolean;

/\*\*

- A 2d array of coordinates to describe holes of the polygon where each hole has at least 3 points.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  holes?: LatLng[][];

/\*\*

- The line cap style to apply to the open ends of the path
-
- @default `round`
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineCap?: LineCapType;

/\*\*

- An array of numbers specifying the dash pattern to use for the path.
- The array contains one or more numbers that indicate the lengths (measured in points)
- of the line segments and gaps in the pattern.
- The values in the array alternate, starting with the first line segment length,
- followed by the first gap length, followed by the second line segment length, and so on.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  lineDashPattern?: number[];

/\*\*

- The offset (in points) at which to start drawing the dash pattern.
- Use this property to start drawing a dashed line partway through a segment or gap.
- For example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the middle of the first gap.
-
- @default 0
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineDashPhase?: number;

/\*\*

- The line join style to apply to corners of the path.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineJoin?: LineJoinType;

/\*\*

- The limiting value that helps avoid spikes at junctions between connected line segments.
- The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style.
- If the ratio of the miter lengththat is, the diagonal length of the miter jointo the line thickness exceeds the miter limit,
- the joint is converted to a bevel join.
- The default miter limit is 10, which results in the conversion of miters whose angle at the joint is less than 11 degrees.
-
- @default 10
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  miterLimit?: number;

/\*\*

- Callback that is called when the user presses on the polygon
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onPress?: (event: PolygonPressEvent) => void;

/\*\*

- The stroke color to use for the path.
-
- @default `#000`, `rgba(r,g,b,0.5)`
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  strokeColor?: string;

/\*\*

- The stroke width to use for the path.
-
- @default 1
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  strokeWidth?: number;

/\*\*

- Boolean to allow a polygon to be tappable and use the onPress function.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  tappable?: boolean;

/\*\*

- The order in which this tile overlay is drawn with respect to other overlays.
- An overlay with a larger z-index is drawn over overlays with smaller z-indices.
- The order of overlays with the same z-index is arbitrary.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  zIndex?: number;
  };

type NativeProps = MapPolygonProps & {ref: React.RefObject<View>};

export class MapPolygon extends React.Component<MapPolygonProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

private polygon: NativeProps['ref'];

constructor(props: MapPolygonProps) {
super(props);
this.polygon = React.createRef<View>();
}

setNativeProps(props: Partial<MapPolygonProps>) {
this.polygon.current?.setNativeProps(props);
}

render() {
const {strokeColor = '#000', strokeWidth = 1} = this.props;
const AIRMapPolygon = this.getNativeComponent();
return (
<AIRMapPolygon
{...this.props}
strokeColor={strokeColor}
strokeWidth={strokeWidth}
ref={this.polygon}
/>
);
}
}

export default decorateMapComponent(MapPolygon, 'Polygon', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});
</file>

<file path="src/MapPolygon.types.ts">
import {NativeSyntheticEvent} from 'react-native';
import {LatLng, Point} from './sharedTypes';

// All types in this file are directly exported with the package for external
// use.

export type PolygonPressEvent = NativeSyntheticEvent<{
action: 'polygon-press';

/\*\*

- @platform iOS: Google Maps
  \*/
  id?: string;

/\*\*

- @platform iOS: Apple Maps
- @platform Android
  \*/
  coordinate?: LatLng;

/\*\*

- @platform Android
  \*/
  position?: Point;
  }>;
  </file>

<file path="src/MapPolyline.tsx">
import * as React from 'react';
import {NativeSyntheticEvent, View, ViewProps} from 'react-native';
import decorateMapComponent, {
  USES_DEFAULT_IMPLEMENTATION,
  SUPPORTED,
  ProviderContext,
  NativeComponent,
  MapManagerCommand,
  UIManagerCommand,
} from './decorateMapComponent';
import {LatLng, LineCapType, LineJoinType, Point} from './sharedTypes';

export type MapPolylineProps = ViewProps & {
/\*\*

- An array of coordinates to describe the polyline
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  coordinates: LatLng[];

/\*\*

- The fill color to use for the path.
-
- @default `#000`, `rgba(r,g,b,0.5)`
- @platform iOS: Supported
- @platform Android: Not supported
  \*/
  fillColor?: string;

/\*\*

- Boolean to indicate whether to draw each segment of the line as a geodesic as opposed to straight lines on the Mercator projection.
- A geodesic is the shortest path between two points on the Earth's surface.
- The geodesic curve is constructed assuming the Earth is a sphere.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  geodesic?: boolean;

/\*\*

- The line cap style to apply to the open ends of the path
-
- @default `round`
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  lineCap?: LineCapType;

/\*\*

- An array of numbers specifying the dash pattern to use for the path.
- The array contains one or more numbers that indicate the lengths (measured in points)
- of the line segments and gaps in the pattern.
- The values in the array alternate, starting with the first line segment length,
- followed by the first gap length, followed by the second line segment length, and so on.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  lineDashPattern?: number[];

/\*\*

- The offset (in points) at which to start drawing the dash pattern.
- Use this property to start drawing a dashed line partway through a segment or gap.
- For example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the middle of the first gap.
-
- @default 0
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineDashPhase?: number;

/\*\*

- The line join style to apply to corners of the path.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  lineJoin?: LineJoinType;

/\*\*

- The limiting value that helps avoid spikes at junctions between connected line segments.
- The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style.
- If the ratio of the miter lengththat is, the diagonal length of the miter jointo the line thickness exceeds the miter limit,
- the joint is converted to a bevel join.
- The default miter limit is 10, which results in the conversion of miters whose angle at the joint is less than 11 degrees.
-
- @default 10
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  miterLimit?: number;

/\*\*

- Callback that is called when the user presses on the polyline
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onPress?: (event: PolylinePressEvent) => void;

/\*\*

- The stroke color to use for the path.
-
- @default `#000`, `rgba(r,g,b,0.5)`
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  strokeColor?: string;

/\*\*

- The stroke colors to use for the path.
-
- Must be the same length as `coordinates`
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  strokeColors?: string[];

/\*\*

- The stroke width to use for the path.
-
- @default 1
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  strokeWidth?: number;

/\*\*

- Boolean to allow the polyline to be tappable and use the onPress function.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  tappable?: boolean;

/\*\*

- The order in which this tile overlay is drawn with respect to other overlays.
- An overlay with a larger z-index is drawn over overlays with smaller z-indices.
- The order of overlays with the same z-index is arbitrary.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  zIndex?: number;
  };

type NativeProps = MapPolylineProps & {ref: React.RefObject<View>};

export class MapPolyline extends React.Component<MapPolylineProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

private polyline: NativeProps['ref'];

constructor(props: MapPolylineProps) {
super(props);
this.polyline = React.createRef<View>();
}

setNativeProps(props: Partial<NativeProps>) {
this.polyline.current?.setNativeProps(props);
}

render() {
const {
strokeColor = '#000',
strokeWidth = 1,
lineJoin = 'round',
lineCap = 'round',
} = this.props;
const AIRMapPolyline = this.getNativeComponent();
return (
<AIRMapPolyline
{...this.props}
strokeColor={strokeColor}
strokeWidth={strokeWidth}
lineJoin={lineJoin}
lineCap={lineCap}
ref={this.polyline}
/>
);
}
}

export default decorateMapComponent(MapPolyline, 'Polyline', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});

export type PolylinePressEvent = NativeSyntheticEvent<{
action: 'polyline-press';

/\*\*

- @platform iOS: Google Maps
  \*/
  id?: string;

/\*\*

- @platform Android
  \*/
  coordinate?: LatLng;

/\*\*

- @platform Android
  \*/
  position?: Point;
  }>;
  </file>

<file path="src/MapUrlTile.tsx">
import * as React from 'react';

import decorateMapComponent, {
USES_DEFAULT_IMPLEMENTATION,
SUPPORTED,
ProviderContext,
NativeComponent,
MapManagerCommand,
UIManagerCommand,
} from './decorateMapComponent';
import {ViewProps} from 'react-native';

export type MapUrlTileProps = ViewProps & {
/\*\*

- Doubles tile size from 256 to 512 utilising higher zoom levels
- i.e loading 4 higher zoom level tiles and combining them for one high-resolution tile.
- iOS does this automatically, even if it is not desirable always.
- NB! using this makes text labels smaller than in the original map style.
-
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  doubleTileSize?: boolean;

/\*\*

- Allow tiles using the TMS coordinate system (origin bottom left) to be used,
- and displayed at their correct coordinates.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  flipY?: boolean;

/\*\*

- The maximum native zoom level for this tile overlay i.e. the highest zoom level that the tile server provides.
- Tiles are auto-scaled for higher zoom levels.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  maximumNativeZ?: number;

/\*\*

- The maximum zoom level for this tile overlay.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  maximumZ?: number;

/\*\*

- The minimum zoom level for this tile overlay.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  minimumZ?: number;

/\*\*

- In offline-mode tiles are not fetched from the tile servers, rather only tiles stored in the cache directory are used.
- Furthermore automated tile scaling is activated: if tile at a desired zoom level is not found from the cache directory,
- then lower zoom level tile is used (up to 4 levels lower) and scaled.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  offlineMode?: boolean;

/\*\*

- Map layer opacity. Value between 0 - 1, with 0 meaning fully transparent.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  opacity?: number;

/\*\*

- Corresponds to MKTileOverlay canReplaceMapContent i.e. if true then underlying iOS basemap is not shown.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  shouldReplaceMapContent?: boolean;

/\*\*

- Defines maximum age in seconds for a cached tile before it's refreshed.
-
- NB! Refresh logic is "serve-stale-while-refresh"
- i.e. to ensure map availability a stale (over max age) tile is served
- while a tile refresh process is started in the background.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  tileCacheMaxAge?: number;

/\*\*

- Enable caching of tiles in the specified directory.
- Directory can be specified either as a normal path or in URL format (`file://`).
-
- Tiles are stored in tileCachePath directory as `/{z}/{x}/{y}` i.e. in sub-directories 2-levels deep,
- filename is tile y-coordinate without any filetype-extension.
-
- NB! All cache management needs to be implemented by client e.g. deleting tiles to manage use of storage space etc.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  tileCachePath?: string;

/\*\*

- Tile size, default size is 256 (for tiles of 256 \_ 256 pixels).
- High-res (aka 'retina') tiles are 512 (tiles of 512 \_ 512 pixels)
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  tileSize?: number;

/\*\*

- The url template of the map tileserver.
- (URLTile) The patterns {x} {y} {z} will be replaced at runtime.
- For example, http://c.tile.openstreetmap.org/{z}/{x}/{y}.png.
-
- It is also possible to refer to tiles in local filesystem with file:///top-level-directory/sub-directory/{z}/{x}/{y}.png URL-format.
- (WMSTile) The patterns {minX} {maxX} {minY} {maxY} {width} {height} will be replaced at runtime according to EPSG:900913 specification bounding box.
- For example, https://demo.geo-solutions.it/geoserver/tiger/wms?service=WMS&version=1.1.0&request=GetMap&layers=tiger:poi&styles=&bbox={minX},{minY},{maxX},{maxY}&width={width}&height={height}&srs=EPSG:900913&format=image/png&transparent=true&format_options=dpi:213.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/

urlTemplate: string;

/\*\*

- The order in which this tile overlay is drawn with respect to other overlays.
- An overlay with a larger z-index is drawn over overlays with smaller z-indices.
- The order of overlays with the same z-index is arbitrary.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  zIndex?: number;
  };

type NativeProps = MapUrlTileProps;

export class MapUrlTile extends React.Component<MapUrlTileProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

render() {
const AIRMapUrlTile = this.getNativeComponent();
return <AIRMapUrlTile {...this.props} />;
}
}

export default decorateMapComponent(MapUrlTile, 'UrlTile', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});
</file>

<file path="src/MapView.tsx">
import * as React from 'react';
import {
  Animated as RNAnimated,
  Animated,
  findNodeHandle,
  HostComponent,
  NativeModules,
  NativeSyntheticEvent,
  Platform,
  requireNativeComponent,
  ViewProps,
} from 'react-native';
import {
  createNotSupportedComponent,
  getNativeMapName,
  googleMapIsInstalled,
  NativeComponent,
  ProviderContext,
} from './decorateMapComponent';
import * as ProviderConstants from './ProviderConstants';
import {
  CalloutPressEvent,
  ClickEvent,
  Frame,
  LatLng,
  MarkerDeselectEvent,
  MarkerDragEvent,
  MarkerDragStartEndEvent,
  MarkerPressEvent,
  MarkerSelectEvent,
  Point,
  Provider,
  Region,
} from './sharedTypes';
import {
  Address,
  BoundingBox,
  Camera,
  CameraZoomRange,
  ChangeEvent,
  Details,
  EdgePadding,
  FitToOptions,
  IndoorBuildingEvent,
  IndoorLevelActivatedEvent,
  KmlMapEvent,
  LongPressEvent,
  MapPressEvent,
  MapStyleElement,
  MapType,
  MapTypes,
  NativeCommandName,
  PanDragEvent,
  PoiClickEvent,
  SnapshotOptions,
  UserLocationChangeEvent,
} from './MapView.types';
import {Modify} from './sharedTypesInternal';
import {Commands, MapViewNativeComponentType} from './MapViewNativeComponent';
import AnimatedRegion from './AnimatedRegion';

export const MAP_TYPES: MapTypes = {
STANDARD: 'standard',
SATELLITE: 'satellite',
HYBRID: 'hybrid',
TERRAIN: 'terrain',
NONE: 'none',
MUTEDSTANDARD: 'mutedStandard',
SATELLITE_FLYOVER: 'satelliteFlyover',
HYBRID_FLYOVER: 'hybridFlyover',
};

const GOOGLE_MAPS_ONLY_TYPES: MapType[] = [MAP_TYPES.TERRAIN, MAP_TYPES.NONE];

export type MapViewProps = ViewProps & {
/\*\*

- If `true` map will be cached and displayed as an image instead of being interactable, for performance usage.
-
- @default false
- @platform iOS: Apple maps only
- @platform Android: Supported
  \*/
  cacheEnabled?: boolean;

/\*\*

- The camera view the map should display.
-
- Use the camera system, instead of the region system, if you need control over
- the pitch or heading. Using this will ignore the `region` property.
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  camera?: Camera;

/\*\*

- If set, changes the position of the compass.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  compassOffset?: Point;

/\*\*

- Adds custom styling to the map component.
- See [README](https://github.com/react-native-maps/react-native-maps#customizing-the-map-style) for more information.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  customMapStyle?: MapStyleElement[];

/\*\*

- If `true` the map will focus on the user's location.
- This only works if `showsUserLocation` is true and the user has shared their location.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  followsUserLocation?: boolean;

/\*\*

- If `false` the map will not capture PoI clicks
- This can improve click handling on the map for android
-
- @default true
- @platform iOS: Not supported
- @platform Android: supported
  \*/
  poiClickEnabled?: boolean;

/\*\*

- The initial camera view the map should use. Use this prop instead of `camera`
- only if you don't want to control the camera of the map besides the initial view.
-
- Use the camera system, instead of the region system, if you need control over
- the pitch or heading.
-
- Changing this prop after the component has mounted will not result in a camera change.
-
- This is similar to the `initialValue` prop of a text input.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  initialCamera?: Camera;

/\*\*

- The initial region to be displayed by the map. Use this prop instead of `region`
- only if you don't want to control the viewport of the map besides the initial region.
-
- Changing this prop after the component has mounted will not result in a region change.
-
- This is similar to the `initialValue` prop of a text input.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  initialRegion?: Region;

/\*\*

- The URL for KML file.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  kmlSrc?: string;

/\*\*

- If set, changes the position of the "Legal" label link in Apple maps.
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  legalLabelInsets?: EdgePadding;

/\*\*

- Enables lite mode on Android
-
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  liteMode?: boolean;

/\*\*

- https://developers.google.com/maps/documentation/get-map-id
- google cloud mapId to enable cloud styling and more
  \*/
  googleMapId?: string;

/\*\*

- https://developers.google.com/maps/documentation/android-sdk/renderer
- google maps renderer
- @default `LATEST`
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  googleRenderer?: 'LATEST' | 'LEGACY';

/\*\*

- Sets loading background color.
-
- @default `#FFFFFF`
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  loadingBackgroundColor?: string;

/\*\*

- If `true` a loading indicator will show while the map is loading.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  loadingEnabled?: boolean;

/\*\*

- Sets loading indicator color.
-
- @default `#606060`
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  loadingIndicatorColor?: string;

/\*\*

- Adds custom padding to each side of the map. Useful when map elements/markers are obscured.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  mapPadding?: EdgePadding;

/\*\*

- The map type to be displayed
-
- @default `standard`
- @platform iOS: hybrid | mutedStandard | satellite | standard | terrain | hybridFlyover | satelliteFlyover
- @platform Android: hybrid | none | satellite | standard | terrain
  \*/
  mapType?: MapType;

/\*\*

- TODO: Add documentation
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  maxDelta?: number;

/\*\*

- Maximum zoom value for the map, must be between 0 and 20
-
- @default 20
- @platform iOS: Supported
- @platform Android: Supported
- @deprecated on Apple Maps, use `cameraZoomRange` instead
  \*/
  maxZoomLevel?: number;

/\*\*

- TODO: Add documentation
-
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  minDelta?: number;

/\*\*

- Minimum zoom value for the map, must be between 0 and 20
-
- @default 0
- @platform iOS: Supported
- @platform Android: Supported
- @deprecated on Apple Maps, use `cameraZoomRange` instead
  \*/
  minZoomLevel?: number;

/\*\*

- If `false` the map won't move to the marker when pressed.
-
- @default true
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  moveOnMarkerPress?: boolean;

/\*\*

- Callback that is called when a callout is tapped by the user.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onCalloutPress?: (event: CalloutPressEvent) => void;

/\*\*

- Callback that is called when user double taps on the map.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onDoublePress?: (event: ClickEvent) => void;

/\*\*

- Callback that is called when an indoor building is focused/unfocused
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  onIndoorBuildingFocused?: (event: IndoorBuildingEvent) => void;

/\*\*

- Callback that is called when a level on indoor building is activated
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  onIndoorLevelActivated?: (event: IndoorLevelActivatedEvent) => void;

/\*\*

- Callback that is called once the kml is fully loaded.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  onKmlReady?: (event: KmlMapEvent) => void;

/\*\*

- Callback that is called when user makes a "long press" somewhere on the map.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onLongPress?: (event: LongPressEvent) => void;

/\*\*

- Callback that is called when the map has finished rendering all tiles.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  onMapLoaded?: (event: NativeSyntheticEvent<{}>) => void;

/\*\*

- Callback that is called once the map is ready.
-
- Event is optional, as the first onMapReady callback is intercepted
- on Android, and the event is not passed on.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onMapReady?: (event?: NativeSyntheticEvent<{}>) => void;

/\*\*

- Callback that is called when a marker on the map becomes deselected.
- This will be called when the callout for that marker is about to be hidden.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onMarkerDeselect?: (event: MarkerDeselectEvent) => void;

/\*\*

- Callback called continuously as a marker is dragged
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onMarkerDrag?: (event: MarkerDragEvent) => void;

/\*\*

- Callback that is called when a drag on a marker finishes.
- This is usually the point you will want to setState on the marker's coordinate again
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onMarkerDragEnd?: (event: MarkerDragStartEndEvent) => void;

/\*\*

- Callback that is called when the user initiates a drag on a marker (if it is draggable)
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  onMarkerDragStart?: (event: MarkerDragStartEndEvent) => void;

/\*\*

- Callback that is called when a marker on the map is tapped by the user.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onMarkerPress?: (event: MarkerPressEvent) => void;

/\*\*

- Callback that is called when a marker on the map becomes selected.
- This will be called when the callout for that marker is about to be shown.
-
- @platform iOS: Supported.
- @platform Android: Supported
  \*/
  onMarkerSelect?: (event: MarkerSelectEvent) => void;

/\*\*

- Callback that is called when user presses and drags the map.
- **NOTE**: for iOS `scrollEnabled` should be set to false to trigger the event
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onPanDrag?: (event: PanDragEvent) => void;

/\*\*

- Callback that is called when user click on a POI.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  onPoiClick?: (event: PoiClickEvent) => void;

/\*\*

- Callback that is called when user taps on the map.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onPress?: (event: MapPressEvent) => void;

/\*\*

- Callback that is called once before the region changes, such as when the user starts moving the map.
- `isGesture` property indicates if the move was from the user (true) or an animation (false).
- **Note**: `isGesture` is supported by Google Maps only.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onRegionChangeStart?: (event: NativeSyntheticEvent<Details>) => void;

/\*\*

- Callback that is called continuously when the region changes, such as when a user is dragging the map.
- `isGesture` property indicates if the move was from the user (true) or an animation (false).
- **Note**: `isGesture` is supported by Google Maps only.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onRegionChange?: (region: Region, details: Details) => void;

/\*\*

- Callback that is called once when the region changes, such as when the user is done moving the map.
- `isGesture` property indicates if the move was from the user (true) or an animation (false).
- **Note**: `isGesture` is supported by Google Maps only.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onRegionChangeComplete?: (region: Region, details: Details) => void;

/\*\*

- Callback that is called when the underlying map figures our users current location
- (coordinate also includes isFromMockProvider value for Android API 18 and above).
- Make sure **showsUserLocation** is set to _true_.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  onUserLocationChange?: (event: UserLocationChangeEvent) => void;

/\*\*

- Indicates how/when to affect padding with safe area insets
-
- @platform iOS: Google Maps only
- @platform Android: Not supported
  \*/
  paddingAdjustmentBehavior?: 'always' | 'automatic' | 'never';

/\*\*

- If `false` the user won't be able to adjust the cameras pitch angle.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  pitchEnabled?: boolean;

/\*\*

- The map framework to use.
- Either `"google"` for GoogleMaps, otherwise `undefined` to use the native map framework (`MapKit` in iOS and `GoogleMaps` in android).
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  provider?: Provider;

/\*\*

- The region to be displayed by the map.
- The region is defined by the center coordinates and the span of coordinates to display.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  region?: Region | AnimatedRegion;

/\*\*

- If `false` the user won't be able to adjust the cameras pitch angle.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  rotateEnabled?: boolean;

/\*\*

- If `false` the map will stay centered while rotating or zooming.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  scrollDuringRotateOrZoomEnabled?: boolean;

/\*\*

- If `false` the user won't be able to change the map region being displayed.
-
- @default true
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  scrollEnabled?: boolean;

/\*\*

- A Boolean indicating whether the map displays extruded building information.
-
- @default true
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  showsBuildings?: boolean;

/\*\*

- If `false` compass won't be displayed on the map.
-
- @default true
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  showsCompass?: boolean;

/\*\*

- A Boolean indicating whether indoor level picker should be enabled.
-
- @default false
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  showsIndoorLevelPicker?: boolean;

/\*\*

- A Boolean indicating whether indoor maps should be enabled.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  showsIndoors?: boolean;

/\*\*

- If `false` hide the button to move map to the current user's location.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  showsMyLocationButton?: boolean;

/\*\*

- If `false` points of interest won't be displayed on the map.
- TODO: DEPRECATED? Doesn't seem to do anything
-
- @default true
- @platform iOS: Maybe Apple Maps?
- @platform Android: Not supported
  \*/
  showsPointsOfInterest?: boolean;

/\*\*

- A Boolean indicating whether the map shows scale information.
-
- @default true
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  showsScale?: boolean;

/\*\*

- A Boolean value indicating whether the map displays traffic information.
- TODO: Look into android support
-
- @default false
- @platform iOS: Supported
- @platform Android: Not supported?
  \*/
  showsTraffic?: boolean;

/\*\*

- If `true` the users location will be displayed on the map.
-
- This will cause iOS to ask for location permissions.
- For iOS see: [DOCS](https://github.com/react-native-maps/react-native-maps/blob/master/docs/installation.md#set-the-usage-description-property)
- @default false
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  showsUserLocation?: boolean;

/\*\*

- Sets the tint color of the map. (Changes the color of the position indicator)
-
- @default System Blue
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  tintColor?: string;

/\*\*

- If `false` will hide 'Navigate' and 'Open in Maps' buttons on marker press
-
- @default true
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  toolbarEnabled?: boolean;

/\*\*

- Sets the map to the style selected.
-
- @default System setting
- @platform iOS: Apple Maps only (iOS >= 13.0)
- @platform Android: Not supported
  \*/
  userInterfaceStyle?: 'light' | 'dark';

/\*\*

- The title of the annotation for current user location.
-
- This only works if `showsUserLocation` is true.
-
- @default `My Location`
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  userLocationAnnotationTitle?: string;

/\*\*

- If `true` clicking user location will show the default callout for userLocation annotation.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  userLocationCalloutEnabled?: boolean;

/\*\*

- Fastest interval the application will actively acquire locations.
-
- See [Google APIs documentation](https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest.html)
-
- @default 5000
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  userLocationFastestInterval?: number;

/\*\*

- Set power priority of user location tracking.
-
- See [Google APIs documentation](https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest.html)
-
- @default `high`
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  userLocationPriority?: 'balanced' | 'high' | 'low' | 'passive';

/\*\*

- Interval of user location updates in milliseconds.
-
- See [Google APIs documentation](https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest.html)
-
- @default 5000
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  userLocationUpdateInterval?: number;

/\*\*

- If `false` the zoom control at the bottom right of the map won't be visible.
-
- @default true
- @platform iOS: Not supported
- @platform Android: Supported
  \*/
  zoomControlEnabled?: boolean;

/\*\*

- If `false` the user won't be able to pinch/zoom the map.
-
- TODO: Why is the Android reactprop defaultvalue set to false?
-
- @default true
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  zoomEnabled?: boolean;

/\*\*

- If `false` the user won't be able to double tap to zoom the map.
- **Note:** But it will greatly decrease delay of tap gesture recognition.
-
- @default true
- @platform iOS: Google Maps only
- @platform Android: Not supported
  \*/
  zoomTapEnabled?: boolean;

/\*\*

- Map camera distance limits. `minCenterCoordinateDistance` for minimum distance, `maxCenterCoordinateDistance` for maximum.
- `animated` for animated zoom changes.
- Takes precedence if conflicting with `minZoomLevel`, `maxZoomLevel`.
-
- @platform iOS: 13.0+
- @platform Android: Not supported
  \*/
  cameraZoomRange?: CameraZoomRange;
  };

type ModifiedProps = Modify<
MapViewProps,
{
region?: MapViewProps['region'] | null;
initialRegion?: MapViewProps['initialRegion'] | null;
}

> ;

export type NativeProps = Omit<
ModifiedProps,
'customMapStyle' | 'onRegionChange' | 'onRegionChangeComplete'

> & {
> ref: React.RefObject<MapViewNativeComponentType>;
> customMapStyleString?: string;
> handlePanDrag?: boolean;
> onChange?: (e: ChangeEvent) => void;
> };

type State = {
isReady: boolean;
};

class MapView extends React.Component<MapViewProps, State> {
static Animated: Animated.AnimatedComponent<typeof MapView>;
private map: NativeProps['ref'];

constructor(props: MapViewProps) {
super(props);

    this.map = React.createRef<MapViewNativeComponentType>();

    this.state = {
      isReady: Platform.OS === 'ios',
    };

    this._onMapReady = this._onMapReady.bind(this);
    this._onChange = this._onChange.bind(this);

}

setNativeProps(props: Partial<NativeProps>) {
// @ts-ignore
this.map.current?.setNativeProps(props);
}

private \_onMapReady() {
const {onMapReady} = this.props;
this.setState({isReady: true}, () => {
if (onMapReady) {
onMapReady();
}
});
}

private \_onChange({nativeEvent}: ChangeEvent) {
const isGesture = nativeEvent.isGesture;
const details = {isGesture};

    if (nativeEvent.continuous) {
      if (this.props.onRegionChange) {
        this.props.onRegionChange(nativeEvent.region, details);
      }
    } else if (this.props.onRegionChangeComplete) {
      this.props.onRegionChangeComplete(nativeEvent.region, details);
    }

}

getCamera(): Promise<Camera> {
if (Platform.OS === 'android') {
return NativeModules.AirMapModule.getCamera(this.\_getHandle());
} else if (Platform.OS === 'ios') {
return this.\_runCommand('getCamera', []);
}
return Promise.reject('getCamera not supported on this platform');
}

setCamera(camera: Partial<Camera>) {
if (this.map.current) {
Commands.setCamera(this.map.current, camera);
}
}

animateCamera(camera: Partial<Camera>, opts?: {duration?: number}) {
if (this.map.current) {
Commands.animateCamera(
this.map.current,
camera,
opts?.duration ? opts.duration : 500,
);
}
}

animateToRegion(region: Region, duration: number = 500) {
if (this.map.current) {
Commands.animateToRegion(this.map.current, region, duration);
}
}

fitToElements(options: FitToOptions = {}) {
if (this.map.current) {
const {
edgePadding = {top: 0, right: 0, bottom: 0, left: 0},
animated = true,
} = options;

      Commands.fitToElements(this.map.current, edgePadding, animated);
    }

}

fitToSuppliedMarkers(markers: string[], options: FitToOptions = {}) {
if (this.map.current) {
const {
edgePadding = {top: 0, right: 0, bottom: 0, left: 0},
animated = true,
} = options;

      Commands.fitToSuppliedMarkers(
        this.map.current,
        markers,
        edgePadding,
        animated,
      );
    }

}

fitToCoordinates(coordinates: LatLng[] = [], options: FitToOptions = {}) {
if (this.map.current) {
const {
edgePadding = {top: 0, right: 0, bottom: 0, left: 0},
animated = true,
} = options;

      Commands.fitToCoordinates(
        this.map.current,
        coordinates,
        edgePadding,
        animated,
      );
    }

}

/\*\*

- Get visible boudaries
-
- @return Promise Promise with the bounding box ({ northEast: <LatLng>, southWest: <LatLng> })
  \*/
  async getMapBoundaries(): Promise<BoundingBox> {
  if (Platform.OS === 'android') {
  return await NativeModules.AirMapModule.getMapBoundaries(
  this.\_getHandle(),
  );
  } else if (Platform.OS === 'ios') {
  return await this.\_runCommand('getMapBoundaries', []);
  }
  return Promise.reject('getMapBoundaries not supported on this platform');
  }

setMapBoundaries(northEast: LatLng, southWest: LatLng) {
if (this.map.current) {
Commands.setMapBoundaries(this.map.current, northEast, southWest);
}
}

setIndoorActiveLevelIndex(activeLevelIndex: number) {
if (this.map.current) {
Commands.setIndoorActiveLevelIndex(this.map.current, activeLevelIndex);
}
}

/\*\*

- Takes a snapshot of the map and saves it to a picture
- file or returns the image as a base64 encoded string.
-
- @param args Configuration options
- @param [args.width] Width of the rendered map-view (when omitted actual view width is used).
- @param [args.height] Height of the rendered map-view (when omitted actual height is used).
- @param [args.region] Region to render (Only supported on iOS).
- @param [args.format] Encoding format ('png', 'jpg') (default: 'png').
- @param [args.quality] Compression quality (only used for jpg) (default: 1.0).
- @param [args.result] Result format ('file', 'base64') (default: 'file').
-
- @return Promise Promise with either the file-uri or base64 encoded string
  \*/
  takeSnapshot(args: SnapshotOptions): Promise<string> {
  // Sanitize inputs
  const config = {
  width: args.width || 0,
  height: args.height || 0,
  region: args.region || {},
  format: args.format || 'png',
  quality: args.quality || 1.0,
  result: args.result || 'file',
  };
  if (config.format !== 'png' && config.format !== 'jpg') {
  throw new Error('Invalid format specified');
  }
  if (config.result !== 'file' && config.result !== 'base64') {
  throw new Error('Invalid result specified');
  }


    // Call native function
    if (Platform.OS === 'android') {
      return NativeModules.AirMapModule.takeSnapshot(this._getHandle(), config);
    } else if (Platform.OS === 'ios') {
      return new Promise((resolve, reject) => {
        this._runCommand('takeSnapshot', [
          config.width,
          config.height,
          config.region,
          config.format,
          config.quality,
          config.result,
          (err: unknown, snapshot: string) => {
            if (err) {
              reject(err);
            } else {
              resolve(snapshot);
            }
          },
        ]);
      });
    }
    return Promise.reject('takeSnapshot not supported on this platform');

}

/\*\*

- Convert a coordinate to address by using default Geocoder
-
- @param coordinate Coordinate
- @param [coordinate.latitude] Latitude
- @param [coordinate.longitude] Longitude
-
- @return Promise with return type Address
  \*/
  addressForCoordinate(coordinate: LatLng): Promise<Address> {
  if (Platform.OS === 'android') {
  return NativeModules.AirMapModule.getAddressFromCoordinates(
  this.\_getHandle(),
  coordinate,
  );
  } else if (Platform.OS === 'ios') {
  return this.\_runCommand('getAddressFromCoordinates', [coordinate]);
  }
  return Promise.reject('getAddress not supported on this platform');
  }

/\*\*

- Convert a map coordinate to user-space point
-
- @param coordinate Coordinate
- @param [coordinate.latitude] Latitude
- @param [coordinate.longitude] Longitude
-
- @return Promise Promise with the point ({ x: Number, y: Number })
  \*/
  pointForCoordinate(coordinate: LatLng): Promise<Point> {
  if (Platform.OS === 'android') {
  return NativeModules.AirMapModule.pointForCoordinate(
  this.\_getHandle(),
  coordinate,
  );
  } else if (Platform.OS === 'ios') {
  return this.\_runCommand('pointForCoordinate', [coordinate]);
  }
  return Promise.reject('pointForCoordinate not supported on this platform');
  }

/\*\*

- Convert a user-space point to a map coordinate
-
- @param point Point
- @param [point.x] X
- @param [point.x] Y
-
- @return Promise Promise with the coordinate ({ latitude: Number, longitude: Number })
  \*/
  coordinateForPoint(point: Point): Promise<LatLng> {
  if (Platform.OS === 'android') {
  return NativeModules.AirMapModule.coordinateForPoint(
  this.\_getHandle(),
  point,
  );
  } else if (Platform.OS === 'ios') {
  return this.\_runCommand('coordinateForPoint', [point]);
  }
  return Promise.reject('coordinateForPoint not supported on this platform');
  }

/\*\*

- Get markers' centers and frames in user-space coordinates
-
- @param onlyVisible boolean true to include only visible markers, false to include all
-
- @return Promise Promise with { <identifier>: { point: Point, frame: Frame } }
  \*/
  getMarkersFrames(onlyVisible: boolean = false): Promise<{
  [key: string]: {point: Point; frame: Frame};
  }> {
  if (Platform.OS === 'ios') {
  return this.\_runCommand('getMarkersFrames', [onlyVisible]);
  }
  return Promise.reject('getMarkersFrames not supported on this platform');
  }

/\*\*

- Get bounding box from region
-
- @param region Region
-
- @return Object Object bounding box ({ northEast: <LatLng>, southWest: <LatLng> })
  \*/
  boundingBoxForRegion(region: Region): BoundingBox {
  return {
  northEast: {
  latitude: region.latitude + region.latitudeDelta / 2,
  longitude: region.longitude + region.longitudeDelta / 2,
  },
  southWest: {
  latitude: region.latitude - region.latitudeDelta / 2,
  longitude: region.longitude - region.longitudeDelta / 2,
  },
  };
  }

private \_mapManagerCommand(name: NativeCommandName) {
return NativeModules[`${getNativeMapName(this.props.provider)}Manager`][ name ];
}

private \_getHandle() {
return findNodeHandle(this.map.current);
}

private \_runCommand(name: NativeCommandName, args: any[]) {
if (Platform.OS === 'ios') {
return this.\_mapManagerCommand(name)(this.\_getHandle(), ...args);
} else {
return Promise.reject(`Invalid platform was passed: ${Platform.OS}`);
}
}

render() {
let props: NativeProps;

    if (this.state.isReady) {
      props = {
        region: null,
        initialRegion: null,
        onChange: this._onChange,
        onMapReady: this._onMapReady,
        liteMode: this.props.liteMode,
        googleMapId: this.props.googleMapId,
        googleRenderer: this.props.googleRenderer,
        ref: this.map,
        customMapStyleString: this.props.customMapStyle
          ? JSON.stringify(this.props.customMapStyle)
          : undefined,
        ...this.props,
      };
      if (
        Platform.OS === 'ios' &&
        props.provider === ProviderConstants.PROVIDER_DEFAULT &&
        props.mapType &&
        GOOGLE_MAPS_ONLY_TYPES.includes(props.mapType)
      ) {
        props.mapType = MAP_TYPES.STANDARD;
      }
      if (props.onPanDrag) {
        props.handlePanDrag = !!props.onPanDrag;
      }
    } else {
      props = {
        style: this.props.style,
        region: null,
        liteMode: this.props.liteMode,
        googleMapId: this.props.googleMapId,
        googleRenderer: this.props.googleRenderer,
        initialRegion: this.props.initialRegion || null,
        initialCamera: this.props.initialCamera,
        ref: this.map,
        onChange: this._onChange,
        onMapReady: this._onMapReady,
        onLayout: this.props.onLayout,
        customMapStyleString: this.props.customMapStyle
          ? JSON.stringify(this.props.customMapStyle)
          : undefined,
      };
    }

    const AIRMap = getNativeMapComponent(this.props.provider);

    return (
      <ProviderContext.Provider value={this.props.provider}>
        <AIRMap {...props} />
      </ProviderContext.Provider>
    );

}
}

const airMaps: {
default: HostComponent<NativeProps>;
google: NativeComponent<NativeProps>;
} = {
default: requireNativeComponent<NativeProps>('AIRMap'),
google: () => null,
};
if (Platform.OS === 'android') {
airMaps.google = airMaps.default;
} else {
airMaps.google = googleMapIsInstalled
? requireNativeComponent<NativeProps>('AIRGoogleMap')
: createNotSupportedComponent(
'react-native-maps: AirGoogleMaps dir must be added to your xCode project to support GoogleMaps on iOS.',
);
}
const getNativeMapComponent = (provider: Provider) =>
airMaps[provider || 'default'];

export const AnimatedMapView = RNAnimated.createAnimatedComponent(MapView);

MapView.Animated = AnimatedMapView;

export default MapView;
</file>

<file path="src/MapView.types.ts">
import {ClickEvent, LatLng, Point, Region} from './sharedTypes';
import {NativeSyntheticEvent} from 'react-native';

// All types in this file are directly exported with the package for external
// use.

export type Camera = {
/\*\*

- Apple Maps
  \*/
  altitude?: number;
  center: LatLng;
  heading: number;
  pitch: number;

/\*\*

- Google Maps
  \*/
  zoom?: number;
  };

export type MapStyleElement = {
featureType?: string;
elementType?: string;
stylers: object[];
};

export type EdgePadding = {
top: number;
right: number;
bottom: number;
left: number;
};

export type MapType =
| 'hybrid'
| 'mutedStandard'
| 'none'
| 'satellite'
| 'standard'
| 'terrain'
| 'satelliteFlyover'
| 'hybridFlyover';

export type MapTypes = {
STANDARD: 'standard';
SATELLITE: 'satellite';
HYBRID: 'hybrid';
TERRAIN: 'terrain';
NONE: 'none';
MUTEDSTANDARD: 'mutedStandard';
SATELLITE_FLYOVER: 'satelliteFlyover';
HYBRID_FLYOVER: 'hybridFlyover';
};

export type IndoorLevel = {
index: number;
name: string;
shortName: string;
};

export type ActiveIndoorLevel = {
activeLevelIndex: number;
name: string;
shortName: string;
};

export type IndoorLevelActivatedEvent = NativeSyntheticEvent<{
IndoorLevel: ActiveIndoorLevel;
}>;

export type IndoorBuilding = {
underground: boolean;
activeLevelIndex: number;
levels: IndoorLevel[];
};

export type IndoorBuildingEvent = NativeSyntheticEvent<{
IndoorBuilding: IndoorBuilding;
}>;

export type KmlMarker = {
id: string;
title: string;
description: string;
coordinate: LatLng;
position: Point;
};

export type KmlMapEvent = NativeSyntheticEvent<{markers: KmlMarker[]}>;

export type LongPressEvent = ClickEvent<{
/\*\*

- @platform Android
  \*/
  action?: 'long-press';
  }>;

export type PanDragEvent = ClickEvent;

export type PoiClickEvent = NativeSyntheticEvent<{
placeId: string;
name: string;
coordinate: LatLng;

/\*\*

- @platform Android
  \*/
  position?: Point;
  }>;

export type MapPressEvent = ClickEvent<{
/\*\*

- @platform Android
  \*/
  action?: 'press' | 'marker-press';
  }>;

export type Details = {
isGesture?: boolean;
};

export type UserLocationChangeEvent = NativeSyntheticEvent<{
coordinate?: LatLng & {
altitude: number;
timestamp: number;
accuracy: number;
speed: number;
heading: number;

    /**
     * @platform iOS
     */
    altitudeAccuracy?: number;

    /**
     * @platform Android
     */
    isFromMockProvider?: boolean;

};

/\*\*

- @platform iOS
  \*/
  error?: {
  message: string;
  };
  }>;

export type ChangeEvent = NativeSyntheticEvent<{
continuous: boolean;
region: Region;
isGesture?: boolean;
}>;

export type FitToOptions = {
edgePadding?: EdgePadding;
animated?: boolean;
};

export type BoundingBox = {northEast: LatLng; southWest: LatLng};

export type SnapshotOptions = {
/** optional, when omitted the view-width is used \*/
width?: number;
/** optional, when omitted the view-height is used _/
height?: number;
/\*\* **iOS only**, optional region to render _/
region?: Region;
/** image formats, defaults to 'png' \*/
format?: 'png' | 'jpg';
/** image quality: 0..1 (only relevant for jpg, default: 1) _/
quality?: number;
/\*\* result types, defaults to 'file' _/
result?: 'file' | 'base64';
};

export type Address = {
administrativeArea: string;
country: string;
countryCode: string;
locality: string;
name: string;
postalCode: string;
subAdministrativeArea: string;
subLocality: string;
thoroughfare: string;
subThoroughfare?: string;
};

export type CameraZoomRange = {
minCenterCoordinateDistance?: number;
maxCenterCoordinateDistance?: number;
animated?: boolean;
};

export type NativeCommandName =
| 'animateCamera'
| 'animateToRegion'
| 'coordinateForPoint'
| 'fitToCoordinates'
| 'fitToElements'
| 'fitToSuppliedMarkers'
| 'getAddressFromCoordinates'
| 'getCamera'
| 'getMapBoundaries'
| 'getMarkersFrames'
| 'pointForCoordinate'
| 'setCamera'
| 'setIndoorActiveLevelIndex'
| 'setMapBoundaries'
| 'takeSnapshot';
</file>

<file path="src/MapView.web.ts">
//@ts-ignore
export {default} from 'react-native-web/dist/modules/UnimplementedView';
</file>

<file path="src/MapViewNativeComponent.ts">
import type {HostComponent} from 'react-native';
import codegenNativeCommands from 'react-native/Libraries/Utilities/codegenNativeCommands';
import {NativeProps} from './MapView';
import {Camera, EdgePadding} from './MapView.types';
import {LatLng, Region} from './sharedTypes';

export type MapViewNativeComponentType = HostComponent<NativeProps>;

interface NativeCommands {
animateToRegion: (
viewRef: NonNullable<
React.RefObject<MapViewNativeComponentType>['current'] >,
region: Region,
duration: number,
) => void;

setCamera: (
viewRef: NonNullable<
React.RefObject<MapViewNativeComponentType>['current'] >,
camera: Partial<Camera>,
) => void;

animateCamera: (
viewRef: NonNullable<
React.RefObject<MapViewNativeComponentType>['current'] >,
camera: Partial<Camera>,
duration: number,
) => void;

fitToElements: (
viewRef: NonNullable<
React.RefObject<MapViewNativeComponentType>['current'] >,
edgePadding: EdgePadding,
animated: boolean,
) => void;

fitToSuppliedMarkers: (
viewRef: NonNullable<
React.RefObject<MapViewNativeComponentType>['current'] >,
markers: string[],
edgePadding: EdgePadding,
animated: boolean,
) => void;

fitToCoordinates: (
viewRef: NonNullable<
React.RefObject<MapViewNativeComponentType>['current'] >,
coordinates: LatLng[],
edgePadding: EdgePadding,
animated: boolean,
) => void;

setMapBoundaries: (
viewRef: NonNullable<
React.RefObject<MapViewNativeComponentType>['current'] >,
northEast: LatLng,
southWest: LatLng,
) => void;

setIndoorActiveLevelIndex: (
viewRef: NonNullable<
React.RefObject<MapViewNativeComponentType>['current'] >,
activeLevelIndex: number,
) => void;
}

export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({
supportedCommands: [
'animateToRegion',
'setCamera',
'animateCamera',
'fitToElements',
'fitToSuppliedMarkers',
'fitToCoordinates',
'setMapBoundaries',
'setIndoorActiveLevelIndex',
],
});
</file>

<file path="src/MapWMSTile.tsx">
import * as React from 'react';
import {ViewProps} from 'react-native';

import decorateMapComponent, {
USES_DEFAULT_IMPLEMENTATION,
SUPPORTED,
ProviderContext,
NativeComponent,
MapManagerCommand,
UIManagerCommand,
} from './decorateMapComponent';

export type MapWMSTileProps = ViewProps & {
/\*\*

- The maximum native zoom level for this tile overlay i.e. the highest zoom level that the tile server provides.
- Tiles are auto-scaled for higher zoom levels.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  maximumNativeZ?: number;

/\*\*

- The maximum zoom level for this tile overlay.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  maximumZ?: number;

/\*\*

- The minimum zoom level for this tile overlay.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  minimumZ?: number;

/\*\*

- In offline-mode tiles are not fetched from the tile servers, rather only tiles stored in the cache directory are used.
- Furthermore automated tile scaling is activated: if tile at a desired zoom level is not found from the cache directory,
- then lower zoom level tile is used (up to 4 levels lower) and scaled.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  offlineMode?: boolean;

/\*\*

- Map layer opacity. Value between 0 - 1, with 0 meaning fully transparent.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  opacity?: number;

/\*\*

- Corresponds to MKTileOverlay canReplaceMapContent i.e. if true then underlying iOS basemap is not shown.
-
- @default false
- @platform iOS: Apple Maps only
- @platform Android: Not supported
  \*/
  shouldReplaceMapContent?: boolean;

/\*\*

- Defines maximum age in seconds for a cached tile before it's refreshed.
-
- NB! Refresh logic is "serve-stale-while-refresh"
- i.e. to ensure map availability a stale (over max age) tile is served
- while a tile refresh process is started in the background.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  tileCacheMaxAge?: number;

/\*\*

- Enable caching of tiles in the specified directory.
- Directory can be specified either as a normal path or in URL format (`file://`).
-
- Tiles are stored in tileCachePath directory as `/{z}/{x}/{y}` i.e. in sub-directories 2-levels deep,
- filename is tile y-coordinate without any filetype-extension.
-
- NB! All cache management needs to be implemented by client e.g. deleting tiles to manage use of storage space etc.
-
- @platform iOS: Apple Maps only
- @platform Android: Supported
  \*/
  tileCachePath?: string;

/\*\*

- Tile size, default size is 256 (for tiles of 256 \_ 256 pixels).
- High-res (aka 'retina') tiles are 512 (tiles of 512 \_ 512 pixels)
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  tileSize?: number;

/\*\*

- The url template of the map tileserver.
- (URLTile) The patterns {x} {y} {z} will be replaced at runtime.
- For example, http://c.tile.openstreetmap.org/{z}/{x}/{y}.png.
-
- It is also possible to refer to tiles in local filesystem with file:///top-level-directory/sub-directory/{z}/{x}/{y}.png URL-format.
- (WMSTile) The patterns {minX} {maxX} {minY} {maxY} {width} {height} will be replaced at runtime according to EPSG:900913 specification bounding box.
- For example, https://demo.geo-solutions.it/geoserver/tiger/wms?service=WMS&version=1.1.0&request=GetMap&layers=tiger:poi&styles=&bbox={minX},{minY},{maxX},{maxY}&width={width}&height={height}&srs=EPSG:900913&format=image/png&transparent=true&format_options=dpi:213.
-
- @platform iOS: Supported
- @platform Android: Supported
  \*/
  urlTemplate: string;

/\*\*

- The order in which this tile overlay is drawn with respect to other overlays.
- An overlay with a larger z-index is drawn over overlays with smaller z-indices.
- The order of overlays with the same z-index is arbitrary.
-
- @platform iOS: Google Maps only
- @platform Android: Supported
  \*/
  zIndex?: number;
  };

type NativeProps = MapWMSTileProps;

export class MapWMSTile extends React.Component<MapWMSTileProps> {
// declaration only, as they are set through decorateMap
declare context: React.ContextType<typeof ProviderContext>;
getNativeComponent!: () => NativeComponent<NativeProps>;
getMapManagerCommand!: (name: string) => MapManagerCommand;
getUIManagerCommand!: (name: string) => UIManagerCommand;

render() {
const AIRMapWMSTile = this.getNativeComponent();
return <AIRMapWMSTile {...this.props} />;
}
}

export default decorateMapComponent(MapWMSTile, 'WMSTile', {
google: {
ios: SUPPORTED,
android: USES_DEFAULT_IMPLEMENTATION,
},
});
</file>

<file path="src/ProviderConstants.ts">
export const PROVIDER_DEFAULT = undefined;
export const PROVIDER_GOOGLE = 'google';
</file>

<file path="src/sharedTypes.ts">
import {NativeSyntheticEvent} from 'react-native';

export type Provider = 'google' | undefined;

export type LatLng = {
latitude: number;
longitude: number;
};

export type Point = {
x: number;
y: number;
};

export type Region = LatLng & {
latitudeDelta: number;
longitudeDelta: number;
};

export type Frame = Point & {height: number; width: number};

export type CalloutPressEvent = NativeSyntheticEvent<{
action: 'callout-press';

/\*\*

- @platform iOS
  \*/
  frame?: Frame;

/\*\*

- @platform iOS
  \*/
  id?: string;

/\*\*

- @platform iOS
  \*/
  point?: Point;

/\*\*

- @platform Android
  \*/
  coordinate?: LatLng;

/\*\*

- @platform Android
  \*/
  position?: Point;
  }>;

export type LineCapType = 'butt' | 'round' | 'square';
export type LineJoinType = 'miter' | 'round' | 'bevel';

export type ClickEvent<T = {}> = NativeSyntheticEvent<
{coordinate: LatLng; position: Point} & T

> ;

export type MarkerDeselectEvent = Omit<
ClickEvent<{
action: 'marker-deselect';
id: string;
}>,
'position'

> ;

export type MarkerSelectEvent = Omit<
ClickEvent<{id: string; action: 'marker-select'}>,
'position'

> ;

export type MarkerDragEvent = ClickEvent<{
/\*\*

- @platform iOS
  \*/
  id?: string;
  }>;

export type MarkerDragStartEndEvent = NativeSyntheticEvent<{
coordinate: LatLng;

/\*\*

- @platform iOS
  \*/
  id?: string;

/\*\*

- @platform Android
  \*/
  position?: Point;
  }>;

export type MarkerPressEvent = NativeSyntheticEvent<{
id: string;
action: 'marker-press';
coordinate: LatLng;

/\*\*

- @platform Android
  \*/
  position?: Point;
  }>;
  </file>

<file path="src/sharedTypesInternal.ts">
export type Modify<T, R> = Omit<T, keyof R> & R;
</file>

<file path=".detoxrc.js">
/** @type {Detox.DetoxConfig} */
module.exports = {
  testRunner: {
    args: {
      $0: 'jest',
      config: 'e2e/jest.config.js',
    },
    jest: {
      setupTimeout: 120000,
    },
  },
  apps: {
    'ios.debug': {
      type: 'ios.app',
      binaryPath:
        'example/ios/build/Build/Products/Debug-iphonesimulator/example.app',
      build:
        'xcodebuild -workspace example/ios/example.xcworkspace -scheme example -configuration Debug -sdk iphonesimulator -derivedDataPath ios/build',
    },
    'ios.release': {
      type: 'ios.app',
      binaryPath:
        'example/ios/build/Build/Products/Release-iphonesimulator/example.app',
      build:
        'xcodebuild -workspace example/ios/example.xcworkspace -scheme example -configuration Release -sdk iphonesimulator -derivedDataPath ios/build',
    },
    'android.debug': {
      type: 'android.apk',
      binaryPath: 'example/android/app/build/outputs/apk/debug/app-debug.apk',
      build:
        'cd example/android && ./gradlew assembleDebug assembleAndroidTest -DtestBuildType=debug',
      reversePorts: [8081],
    },
    'android.release': {
      type: 'android.apk',
      binaryPath:
        'example/android/app/build/outputs/apk/release/app-release.apk',
      build:
        'cd example/android && ./gradlew assembleRelease assembleAndroidTest -DtestBuildType=release',
    },
  },
  devices: {
    simulator: {
      type: 'ios.simulator',
      device: {
        type: 'iPhone 14',
      },
    },
    attached: {
      type: 'android.attached',
      device: {
        adbName: '.*',
      },
    },
    emulator: {
      type: 'android.emulator',
      device: {
        avdName: 'Pixel_3a_API_30_x86',
      },
    },
  },
  configurations: {
    'ios.sim.debug': {
      device: 'simulator',
      app: 'ios.debug',
    },
    'ios.sim.release': {
      device: 'simulator',
      app: 'ios.release',
    },
    'android.att.debug': {
      device: 'attached',
      app: 'android.debug',
    },
    'android.att.release': {
      device: 'attached',
      app: 'android.release',
    },
    'android.emu.debug': {
      device: 'emulator',
      app: 'android.debug',
    },
    'android.emu.release': {
      device: 'emulator',
      app: 'android.release',
    },
  },
};
</file>

<file path=".eslintrc.js">
module.exports = {
  root: true,
  extends: '@react-native',
  ignorePatterns: 'lib', // ts outdir
  settings: {
    react: {
      version: '18.3.1',
    },
  },
};
</file>

<file path=".gitignore">
# OSX
#
.DS_Store

# Xcode

#

build/
_.pbxuser
!default.pbxuser
_.mode1v3
!default.mode1v3
_.mode2v3
!default.mode2v3
_.perspectivev3
!default.perspectivev3
xcuserdata
_.xccheckout
_.moved-aside
DerivedData
_.hmap
_.ipa
\*.xcuserstate
project.xcworkspace
Pods/
AirMapsExplorer.xcworkspace/
\*\*/.xcode.env.local

# Android/IntelliJ

#

build/
.idea
.gradle
local.properties
_.iml
_.hprof
.cxx/
\*.keystore
!debug.keystore

# node.js

#

node_modules/
npm-debug.log
yarn-error.log

# fastlane

#

# It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the

# screenshots whenever they are needed.

# For more information about the recommended setup visit:

# https://docs.fastlane.tools/best-practices/source-control/

**/fastlane/report.xml
**/fastlane/Preview.html
**/fastlane/screenshots
**/fastlane/test_output

# Bundle artifact

\*.jsbundle

# VSCode workspace settings

.vscode

# ts outDir

lib/

example/vendor/bundle/

example/ios/Config.xcconfig

# Ruby / CocoaPods

\*\*/Pods/
/vendor/bundle/

# Temporary files created by Metro to check the health of the file watcher

.metro-health-check\*

# testing

/coverage

# Yarn

.yarn/\*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
</file>

<file path=".prettierignore">
# Add files here to ignore them from prettier formatting

CHANGELOG.md
example/ios
example/android
android/build
example/vendor/bundle/
ios/DerivedData
</file>

<file path=".prettierrc">
{
  "arrowParens": "avoid",
  "bracketSameLine": true,
  "bracketSpacing": false,
  "singleQuote": true,
  "trailingComma": "all"
}
</file>

<file path=".releaserc.json">
{
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    [
      "@semantic-release/changelog",
      {
        "changelogTitle": "# Changelog"
      }
    ],
    "@semantic-release/npm",
    [
      "@semantic-release/git",
      {
        "assets": ["CHANGELOG.md"],
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ],
    "@semantic-release/github"
  ]
}
</file>

<file path="babel.config.js">
module.exports = {
  presets: ['module:@react-native/babel-preset'],
};
</file>

<file path="CHANGELOG.md">
# Changelog

## [1.20.1](https://github.com/react-native-maps/react-native-maps/compare/v1.20.0...v1.20.1) (2024-11-22)

### Bug Fixes

- **ios:** color update in AIRGoogleMap ([#5227](https://github.com/react-native-maps/react-native-maps/issues/5227)) ([f445546](https://github.com/react-native-maps/react-native-maps/commit/f44554637a93de5f505bbf199d2a5fee84c76695))

# [1.20.0](https://github.com/react-native-maps/react-native-maps/compare/v1.19.1...v1.20.0) (2024-11-10)

### Features

- **android:** add support for disabling PoIClick ([#5210](https://github.com/react-native-maps/react-native-maps/issues/5210)) ([d92e283](https://github.com/react-native-maps/react-native-maps/commit/d92e28365ac42fda4b298f0a6b352cc297566660))

## [1.19.1](https://github.com/react-native-maps/react-native-maps/compare/v1.19.0...v1.19.1) (2024-11-10)

### Bug Fixes

- Remove unstable_reactLegacyComponentNames ([#5209](https://github.com/react-native-maps/react-native-maps/issues/5209)) ([33112be](https://github.com/react-native-maps/react-native-maps/commit/33112be8bd4d8c817df5875e08131f3286a10477))

# [1.19.0](https://github.com/react-native-maps/react-native-maps/compare/v1.18.4...v1.19.0) (2024-11-09)

### Features

- add onRegionChangeStart event to MapView ([#5144](https://github.com/react-native-maps/react-native-maps/issues/5144)) ([eeb56f9](https://github.com/react-native-maps/react-native-maps/commit/eeb56f9f08c636eea928f383ce63d3ed1521ff8b))

## [1.18.4](https://github.com/react-native-maps/react-native-maps/compare/v1.18.3...v1.18.4) (2024-11-09)

### Bug Fixes

- **Android:** fix multiple padding related issues on Android ([#5150](https://github.com/react-native-maps/react-native-maps/issues/5150), [#5152](https://github.com/react-native-maps/react-native-maps/issues/5152), [#5153](https://github.com/react-native-maps/react-native-maps/issues/5153), [#5154](https://github.com/react-native-maps/react-native-maps/issues/5154)) ([#5151](https://github.com/react-native-maps/react-native-maps/issues/5151)) ([0009170](https://github.com/react-native-maps/react-native-maps/commit/0009170f26735eda47f1d7316a0642de3c9a952c))

## [1.18.3](https://github.com/react-native-maps/react-native-maps/compare/v1.18.2...v1.18.3) (2024-11-09)

### Bug Fixes

- **iOS:** Refactor onPress(Marker) to return nativeEvent.position for consistency with Android ([#5196](https://github.com/react-native-maps/react-native-maps/issues/5196)) ([956783f](https://github.com/react-native-maps/react-native-maps/commit/956783f90df7053536240a2f0bc51fee094a4b1e)), closes [#4996](https://github.com/react-native-maps/react-native-maps/issues/4996)

## [1.18.2](https://github.com/react-native-maps/react-native-maps/compare/v1.18.1...v1.18.2) (2024-10-14)

### Bug Fixes

- correctly check for iOS OS version before using cameraZoomRange ([#5185](https://github.com/react-native-maps/react-native-maps/issues/5185)) ([4efd881](https://github.com/react-native-maps/react-native-maps/commit/4efd881ffb4995f77d7f325455053d30c50cd429))

## [1.18.1](https://github.com/react-native-maps/react-native-maps/compare/v1.18.0...v1.18.1) (2024-10-12)

### Bug Fixes

- documentation on README.md ([#5174](https://github.com/react-native-maps/react-native-maps/issues/5174)) ([b853f3a](https://github.com/react-native-maps/react-native-maps/commit/b853f3ae28e72aa107eb61db79a90adb00f03492))

# [1.18.0](https://github.com/react-native-maps/react-native-maps/compare/v1.17.3...v1.18.0) (2024-08-18)

### Features

- add anchor and centerOffset prop to GeoJson component to be passed to Marker ([#5140](https://github.com/react-native-maps/react-native-maps/issues/5140)) ([266be79](https://github.com/react-native-maps/react-native-maps/commit/266be79e924298633e60aed5c0b86d077fa479cc)), closes [#5139](https://github.com/react-native-maps/react-native-maps/issues/5139)

## [1.17.3](https://github.com/react-native-maps/react-native-maps/compare/v1.17.2...v1.17.3) (2024-07-27)

### Bug Fixes

- **Android:** Added A11y for Map and Marker ([#5091](https://github.com/react-native-maps/react-native-maps/issues/5091)) ([f3f5a4e](https://github.com/react-native-maps/react-native-maps/commit/f3f5a4e45cb4a27624c87999d366710c17d4daee))

## [1.17.2](https://github.com/react-native-maps/react-native-maps/compare/v1.17.1...v1.17.2) (2024-07-27)

### Bug Fixes

- export PolylinePressEvent ([#5125](https://github.com/react-native-maps/react-native-maps/issues/5125)) ([27fec3a](https://github.com/react-native-maps/react-native-maps/commit/27fec3a993af8fc5a21b9a303b34d73bc34f1914))

## [1.17.1](https://github.com/react-native-maps/react-native-maps/compare/v1.17.0...v1.17.1) (2024-07-21)

### Bug Fixes

- **iOS:** ensure onPress(Marker) returns nativeEvent.position [#4996](https://github.com/react-native-maps/react-native-maps/issues/4996) ([#5092](https://github.com/react-native-maps/react-native-maps/issues/5092)) ([b2d2fd8](https://github.com/react-native-maps/react-native-maps/commit/b2d2fd8cddb8808a41ae881f87a7295ac78f5b06))

# [1.17.0](https://github.com/react-native-maps/react-native-maps/compare/v1.16.0...v1.17.0) (2024-07-21)

### Features

- **android:** add dash pattern for Android Polygon ([#5115](https://github.com/react-native-maps/react-native-maps/issues/5115)) ([#5121](https://github.com/react-native-maps/react-native-maps/issues/5121)) ([4001ae8](https://github.com/react-native-maps/react-native-maps/commit/4001ae89dd82e6f0a247d3255f3cdaba253a0fcd))

# [1.16.0](https://github.com/react-native-maps/react-native-maps/compare/v1.15.7...v1.16.0) (2024-07-20)

### Features

- **ios:** allow use of light compass theme with satellite/hybrid map ([#5099](https://github.com/react-native-maps/react-native-maps/issues/5099)) ([befb86e](https://github.com/react-native-maps/react-native-maps/commit/befb86e0aa4e8f517301d01bc084246e21c08c0b))

## [1.15.7](https://github.com/react-native-maps/react-native-maps/compare/v1.15.6...v1.15.7) (2024-07-20)

### Bug Fixes

- **ios:** Implement dash options for geojson polygon ([#5115](https://github.com/react-native-maps/react-native-maps/issues/5115)) ([5dc9381](https://github.com/react-native-maps/react-native-maps/commit/5dc9381ae600e239b5aa8a818f94a88dc161d8fb))

## [1.15.6](https://github.com/react-native-maps/react-native-maps/compare/v1.15.5...v1.15.6) (2024-05-30)

### Bug Fixes

- **iOS:** iOS PrivacyInfo fix ([#5078](https://github.com/react-native-maps/react-native-maps/issues/5078)) ([9f458d9](https://github.com/react-native-maps/react-native-maps/commit/9f458d956ba2c16ee3f2a9e8849d9330dcefdda2))

## [1.15.5](https://github.com/react-native-maps/react-native-maps/compare/v1.15.4...v1.15.5) (2024-05-30)

### Bug Fixes

- **android:** UIManagerModule fix for Bridgeless 0.74 ([#5061](https://github.com/react-native-maps/react-native-maps/issues/5061)) ([f194f99](https://github.com/react-native-maps/react-native-maps/commit/f194f9977ea7c6ab547b53e15b4d9a3480c8baa7))

## [1.15.4](https://github.com/react-native-maps/react-native-maps/compare/v1.15.3...v1.15.4) (2024-05-25)

### Bug Fixes

- **ios:** resolve issue with Pods installation ([#5065](https://github.com/react-native-maps/react-native-maps/issues/5065)) ([9992c36](https://github.com/react-native-maps/react-native-maps/commit/9992c36054b0a8a056f0ce97d4687fcdf18c2ca5))

## [1.15.3](https://github.com/react-native-maps/react-native-maps/compare/v1.15.2...v1.15.3) (2024-05-24)

### Bug Fixes

- **android:** move package namespace from Manifest to gradle ([d4916bb](https://github.com/react-native-maps/react-native-maps/commit/d4916bb6fff96f811d40c4d3b3bff8840442929d))

## [1.15.2](https://github.com/react-native-maps/react-native-maps/compare/v1.15.1...v1.15.2) (2024-05-20)

### Bug Fixes

- use initialProps to set zoomTapEnabled in google-maps-ios ([#5059](https://github.com/react-native-maps/react-native-maps/issues/5059)) ([524194f](https://github.com/react-native-maps/react-native-maps/commit/524194ff62859cd82d78cbcca53c6f8e2da29bb7))

## [1.15.1](https://github.com/react-native-maps/react-native-maps/compare/v1.15.0...v1.15.1) (2024-05-05)

### Bug Fixes

- **android:** fix non working tile update ([#5041](https://github.com/react-native-maps/react-native-maps/issues/5041)) ([29107d5](https://github.com/react-native-maps/react-native-maps/commit/29107d516ac6f6cb0ecbd604a5ebe43dfae339a2))

# [1.15.0](https://github.com/react-native-maps/react-native-maps/compare/v1.14.0...v1.15.0) (2024-05-04)

### Features

- **ios:** Add possibility to use both MKMarkerAnnotationView and MKPinAnnotationView ([#5005](https://github.com/react-native-maps/react-native-maps/issues/5005)) ([6e4f49e](https://github.com/react-native-maps/react-native-maps/commit/6e4f49ead61557ca0eed6fd764317a848981e353))

# [1.14.0](https://github.com/react-native-maps/react-native-maps/compare/v1.13.2...v1.14.0) (2024-04-14)

### Bug Fixes

- **android:** map initialization as expected ([b57d22f](https://github.com/react-native-maps/react-native-maps/commit/b57d22f887f352d7be636b3cc9b60be8254ab850))
- **android:** map initialization as expected ([8ba7608](https://github.com/react-native-maps/react-native-maps/commit/8ba7608e90d188ee8bad50392968c60c5a2f15be))
- **android:** map initialization as expected ([7e1dd58](https://github.com/react-native-maps/react-native-maps/commit/7e1dd58e3bf3ea174e0a526926b14ef38340a195))
- **android:** map initialization as expected ([73640a6](https://github.com/react-native-maps/react-native-maps/commit/73640a6232f7e523c8962f6ab315bc9772ae154c))
- **android:** map initialization as expected ([6554793](https://github.com/react-native-maps/react-native-maps/commit/6554793a0287060dd946edae0a92de3482c2b14d))

### Features

- add support for new React Native architecture ([630b72e](https://github.com/react-native-maps/react-native-maps/commit/630b72ef90c2bcb8611ce907c4f359eefe40c555))
- add support for new React Native architecture ([48665da](https://github.com/react-native-maps/react-native-maps/commit/48665da2a581d300557d40fe740b8a28bb1cdc43))
- add support for new React Native architecture ([794c64f](https://github.com/react-native-maps/react-native-maps/commit/794c64f9288310a8da0bb5450011a8ef6236b952))
- add support for new React Native architecture ([1310985](https://github.com/react-native-maps/react-native-maps/commit/1310985e6e2c0d5b915d7364cf52a99cca43ec8f))
- add support for new React Native architecture ([39fd4e6](https://github.com/react-native-maps/react-native-maps/commit/39fd4e6e57cad141e640e4baf4ed3f60eccd6db4))
- Enable new arch for the example project ([1a21f86](https://github.com/react-native-maps/react-native-maps/commit/1a21f862b3b781707ae88e44db501f7453e95ac1))

## [1.13.2](https://github.com/react-native-maps/react-native-maps/compare/v1.13.1...v1.13.2) (2024-04-13)

### Bug Fixes

- **android:** googleMapOptions / initialising multiple maps on android is buggy ([#5034](https://github.com/react-native-maps/react-native-maps/issues/5034)) ([be28937](https://github.com/react-native-maps/react-native-maps/commit/be2893701f4d92e6e7d1b3917626c74352f75303))

## [1.13.1](https://github.com/react-native-maps/react-native-maps/compare/v1.13.0...v1.13.1) (2024-04-13)

### Bug Fixes

- **android:** onSelect was crashing android ([#5032](https://github.com/react-native-maps/react-native-maps/issues/5032)) ([b3ce3fc](https://github.com/react-native-maps/react-native-maps/commit/b3ce3fc4731b86107ea205d9ddb4743443c9523b))

# [1.13.0](https://github.com/react-native-maps/react-native-maps/compare/v1.12.0...v1.13.0) (2024-04-01)

### Features

- **google-init:** Improve Google Maps Initialisation on Android ([a1be51b](https://github.com/react-native-maps/react-native-maps/commit/a1be51bd882933da93dc50fcc7ae2219a1df58b4))

# [1.12.0](https://github.com/react-native-maps/react-native-maps/compare/v1.11.3...v1.12.0) (2024-03-29)

### Features

- **google-maps:** add onSelect/onDeselect support fo google maps ([#4990](https://github.com/react-native-maps/react-native-maps/issues/4990)) ([b9fbe31](https://github.com/react-native-maps/react-native-maps/commit/b9fbe31bb1feca4281a3131cc2a78dd64cca96d3))

## [1.11.3](https://github.com/react-native-maps/react-native-maps/compare/v1.11.2...v1.11.3) (2024-03-11)

### Bug Fixes

- AnimatedRegion types ([#4909](https://github.com/react-native-maps/react-native-maps/issues/4909)) ([5fd9ca6](https://github.com/react-native-maps/react-native-maps/commit/5fd9ca6dfb655145cfbf41f7f977855d8265b1f1))

## [1.11.2](https://github.com/react-native-maps/react-native-maps/compare/v1.11.1...v1.11.2) (2024-03-11)

### Bug Fixes

- **iOS:** removing polylines on iOS with googleProvider ([#4973](https://github.com/react-native-maps/react-native-maps/issues/4973)) ([6603060](https://github.com/react-native-maps/react-native-maps/commit/66030603a1808ef2c055f0abe2ab02f5e47cdf4c))

## [1.11.1](https://github.com/react-native-maps/react-native-maps/compare/v1.11.0...v1.11.1) (2024-03-10)

### Bug Fixes

- **android:** custom maker performance improvements when view tracking ([#4969](https://github.com/react-native-maps/react-native-maps/issues/4969)) ([f30c9d7](https://github.com/react-native-maps/react-native-maps/commit/f30c9d7624aa2f50afb7da97b6749fc45eb3125c))

# [1.11.0](https://github.com/react-native-maps/react-native-maps/compare/v1.10.4...v1.11.0) (2024-03-10)

### Features

- **android:** add bridgeless support ([#4985](https://github.com/react-native-maps/react-native-maps/issues/4985)) ([3ad0265](https://github.com/react-native-maps/react-native-maps/commit/3ad0265cd2e1fc357713ae2b8de71249c8425b50))

## [1.10.4](https://github.com/react-native-maps/react-native-maps/compare/v1.10.3...v1.10.4) (2024-03-10)

### Bug Fixes

- **android:** remove dangling map marker views causing memory leak ([#4992](https://github.com/react-native-maps/react-native-maps/issues/4992)) ([02ed7c0](https://github.com/react-native-maps/react-native-maps/commit/02ed7c04ec51789462a234cbddf0483d2c8116cd))

## [1.10.3](https://github.com/react-native-maps/react-native-maps/compare/v1.10.2...v1.10.3) (2024-02-18)

### Bug Fixes

- **animation:** Marker Animation using reanimated ([#4974](https://github.com/react-native-maps/react-native-maps/issues/4974)) ([7455ed0](https://github.com/react-native-maps/react-native-maps/commit/7455ed022117cbb45d232bc0f2a8ac5982bb8fd6))

## [1.10.2](https://github.com/react-native-maps/react-native-maps/compare/v1.10.1...v1.10.2) (2024-02-10)

### Bug Fixes

- **AIRMap:** support iOS MapKit zoomConstraints for better zoom handling especially for 3d maps ([#4905](https://github.com/react-native-maps/react-native-maps/issues/4905)) ([d83e1a9](https://github.com/react-native-maps/react-native-maps/commit/d83e1a9f4e5e93e0826ec810a35688eb6b4b4026))

## [1.10.1](https://github.com/react-native-maps/react-native-maps/compare/v1.10.0...v1.10.1) (2024-02-04)

### Bug Fixes

- EdgePadding types ([#4956](https://github.com/react-native-maps/react-native-maps/issues/4956)) ([de9e205](https://github.com/react-native-maps/react-native-maps/commit/de9e205c0955aee1951426bb9bf78440acac7119))

# [1.10.0](https://github.com/react-native-maps/react-native-maps/compare/v1.9.1...v1.10.0) (2024-01-21)

### Features

- **map:** add numberOfTouches to onPanDrag event on iOS ([#4934](https://github.com/react-native-maps/react-native-maps/issues/4934)) ([13f3903](https://github.com/react-native-maps/react-native-maps/commit/13f39030e35472ec639733ba3c469ae51283d806))

## [1.9.1](https://github.com/react-native-maps/react-native-maps/compare/v1.9.0...v1.9.1) (2024-01-05)

### Bug Fixes

- crash due to casting subview in iOS AIRGoogleMapMarker.m ([#4930](https://github.com/react-native-maps/react-native-maps/issues/4930)) ([4f38bd5](https://github.com/react-native-maps/react-native-maps/commit/4f38bd54e61bd93e26708c4d317ced3fa632cea9))

# [1.9.0](https://github.com/react-native-maps/react-native-maps/compare/v1.8.4...v1.9.0) (2024-01-02)

### Features

- **googleMaps:** add support for the new Google's cloud based maps / styling via googleMapId prop ([77610e9](https://github.com/react-native-maps/react-native-maps/commit/77610e96360a7cba3df72e8082d0eb4cae310d38))

## [1.8.4](https://github.com/react-native-maps/react-native-maps/compare/v1.8.3...v1.8.4) (2023-12-15)

### Bug Fixes

- **AIRMap:** fix location change timestamp ([7e5fb71](https://github.com/react-native-maps/react-native-maps/commit/7e5fb712f6f38973b666b406d904f51934f0fb55))

## [1.8.3](https://github.com/react-native-maps/react-native-maps/compare/v1.8.2...v1.8.3) (2023-12-07)

### Bug Fixes

- add missing subThoroughfare to Address type ([435798b](https://github.com/react-native-maps/react-native-maps/commit/435798b58cb7907cb43caf75fec6286fe0840d28))

## [1.8.2](https://github.com/react-native-maps/react-native-maps/compare/v1.8.1...v1.8.2) (2023-12-07)

### Bug Fixes

- **ios:** update google-maps-ios-utils version to 4.2.2 ([28f59c9](https://github.com/react-native-maps/react-native-maps/commit/28f59c9891ddd9f4f4774e1b4104f44d26f466f3))

## [1.8.1](https://github.com/react-native-maps/react-native-maps/compare/v1.8.0...v1.8.1) (2023-12-06)

### Bug Fixes

- **example:** fix typo in AndroidManifest.xml for ACCESS_COARSE_LOCATION permission ([a4a0f0d](https://github.com/react-native-maps/react-native-maps/commit/a4a0f0d91b9098b18081aab493a70008b0ca1436))

# [1.8.0](https://github.com/react-native-maps/react-native-maps/compare/v1.7.1...v1.8.0) (2023-10-09)

### Features

- **android:** Add android namespace to support react-native 0.73 ([#4859](https://github.com/react-native-maps/react-native-maps/issues/4859)) ([1c6c13d](https://github.com/react-native-maps/react-native-maps/commit/1c6c13d05705ed73c5ffdaf9f26648b44b7cb523))

## [1.7.1](https://github.com/react-native-maps/react-native-maps/compare/v1.7.0...v1.7.1) (2023-04-23)

### Bug Fixes

- **android:** crash when removing feature belonging to collection ([#4707](https://github.com/react-native-maps/react-native-maps/issues/4707)) ([ae6fe90](https://github.com/react-native-maps/react-native-maps/commit/ae6fe90d3f0c727441dd2cdc84c1800e18f18d04)), closes [#4706](https://github.com/react-native-maps/react-native-maps/issues/4706)

# [1.7.0](https://github.com/react-native-maps/react-native-maps/compare/v1.6.0...v1.7.0) (2023-04-23)

### Bug Fixes

- **ios:** followsUserLocation changes zoom level ([#4696](https://github.com/react-native-maps/react-native-maps/issues/4696)) ([3b9491e](https://github.com/react-native-maps/react-native-maps/commit/3b9491e39529f11b32b4da9eb4ef36353c0033d9)), closes [#4585](https://github.com/react-native-maps/react-native-maps/issues/4585)

### Features

- **android:** bump android-maps-utils to 3.4.0 ([#4699](https://github.com/react-native-maps/react-native-maps/issues/4699)) ([6b26c23](https://github.com/react-native-maps/react-native-maps/commit/6b26c235a26e2708497e5caf31176d8599441d9e))

# [1.7.0-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.6.1-beta.1...v1.7.0-beta.1) (2023-04-21)

### Features

- **android:** bump android-maps-utils to 3.4.0 ([#4699](https://github.com/react-native-maps/react-native-maps/issues/4699)) ([6b26c23](https://github.com/react-native-maps/react-native-maps/commit/6b26c235a26e2708497e5caf31176d8599441d9e))

## [1.6.1-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.6.0...v1.6.1-beta.1) (2023-04-21)

### Bug Fixes

- **ios:** followsUserLocation changes zoom level ([#4696](https://github.com/react-native-maps/react-native-maps/issues/4696)) ([3b9491e](https://github.com/react-native-maps/react-native-maps/commit/3b9491e39529f11b32b4da9eb4ef36353c0033d9)), closes [#4585](https://github.com/react-native-maps/react-native-maps/issues/4585)

# [1.6.0](https://github.com/react-native-maps/react-native-maps/compare/v1.5.0...v1.6.0) (2023-04-20)

### Bug Fixes

- **ios:** crash on Apple Maps when loading large polylines ([#4468](https://github.com/react-native-maps/react-native-maps/issues/4468)) ([e48e1af](https://github.com/react-native-maps/react-native-maps/commit/e48e1afc9e045fc97044a4c2e8623ad2173ef7b6))
- **ios:** support for use_frameworks! :linkage => :static ([b0c2d42](https://github.com/react-native-maps/react-native-maps/commit/b0c2d42454ef72ff2037103218f799801aa83ebf))
- **marker:** remove spamming warning from MapMarker ([#4644](https://github.com/react-native-maps/react-native-maps/issues/4644)) ([8825312](https://github.com/react-native-maps/react-native-maps/commit/8825312bd267b4ed94a21c8793839146e3dd5563)), closes [#4536](https://github.com/react-native-maps/react-native-maps/issues/4536)
- **types:** missing PolygonPressEvent type export ([#4410](https://github.com/react-native-maps/react-native-maps/issues/4410)) ([d3557a3](https://github.com/react-native-maps/react-native-maps/commit/d3557a39b9356c9d762c631bab6050f33967a510))

### Features

- enable npm provenance ([#4686](https://github.com/react-native-maps/react-native-maps/issues/4686)) ([3498c3f](https://github.com/react-native-maps/react-native-maps/commit/3498c3f8d9bf2184abdc01d00ff4a3ffb8ab28d3))
- **ios:** bump googlemaps to 7.4.0 ([#4679](https://github.com/react-native-maps/react-native-maps/issues/4679)) ([661cddb](https://github.com/react-native-maps/react-native-maps/commit/661cddb4b21ebe6aecb90d7f4e49be14285f1ec7))

# [1.6.0-beta.3](https://github.com/react-native-maps/react-native-maps/compare/v1.6.0-beta.2...v1.6.0-beta.3) (2023-04-20)

### Features

- enable npm provenance ([#4686](https://github.com/react-native-maps/react-native-maps/issues/4686)) ([3498c3f](https://github.com/react-native-maps/react-native-maps/commit/3498c3f8d9bf2184abdc01d00ff4a3ffb8ab28d3))

# [1.6.0-beta.3](https://github.com/react-native-maps/react-native-maps/compare/v1.6.0-beta.2...v1.6.0-beta.3) (2023-04-20)

### Features

- enable npm provenance ([#4686](https://github.com/react-native-maps/react-native-maps/issues/4686)) ([3498c3f](https://github.com/react-native-maps/react-native-maps/commit/3498c3f8d9bf2184abdc01d00ff4a3ffb8ab28d3))

# [1.6.0-beta.2](https://github.com/react-native-maps/react-native-maps/compare/v1.6.0-beta.1...v1.6.0-beta.2) (2023-04-18)

### Bug Fixes

- **marker:** remove spamming warning from MapMarker ([#4644](https://github.com/react-native-maps/react-native-maps/issues/4644)) ([8825312](https://github.com/react-native-maps/react-native-maps/commit/8825312bd267b4ed94a21c8793839146e3dd5563)), closes [#4536](https://github.com/react-native-maps/react-native-maps/issues/4536)

# [1.6.0-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.5.1-beta.3...v1.6.0-beta.1) (2023-04-18)

### Features

- **ios:** bump googlemaps to 7.4.0 ([#4679](https://github.com/react-native-maps/react-native-maps/issues/4679)) ([661cddb](https://github.com/react-native-maps/react-native-maps/commit/661cddb4b21ebe6aecb90d7f4e49be14285f1ec7))

## [1.5.1-beta.3](https://github.com/react-native-maps/react-native-maps/compare/v1.5.1-beta.2...v1.5.1-beta.3) (2023-04-18)

### Bug Fixes

- **ios:** support for use_frameworks! :linkage => :static ([b0c2d42](https://github.com/react-native-maps/react-native-maps/commit/b0c2d42454ef72ff2037103218f799801aa83ebf))

## [1.5.1-beta.2](https://github.com/react-native-maps/react-native-maps/compare/v1.5.1-beta.1...v1.5.1-beta.2) (2023-04-16)

### Bug Fixes

- **ios:** crash on Apple Maps when loading large polylines ([#4468](https://github.com/react-native-maps/react-native-maps/issues/4468)) ([e48e1af](https://github.com/react-native-maps/react-native-maps/commit/e48e1afc9e045fc97044a4c2e8623ad2173ef7b6))

## [1.5.1-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.5.0...v1.5.1-beta.1) (2023-04-16)

### Bug Fixes

- **types:** missing PolygonPressEvent type export ([#4410](https://github.com/react-native-maps/react-native-maps/issues/4410)) ([d3557a3](https://github.com/react-native-maps/react-native-maps/commit/d3557a39b9356c9d762c631bab6050f33967a510))

# [1.5.0](https://github.com/react-native-maps/react-native-maps/compare/v1.4.0...v1.5.0) (2023-04-15)

### Features

- **android:** pin androidx.work version ([73f21c7](https://github.com/react-native-maps/react-native-maps/commit/73f21c7ef447340fb8632ea597232d01ab9ae3d7))

# [1.5.0-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.4.0...v1.5.0-beta.1) (2023-04-15)

### Features

- **android:** pin androidx.work version ([73f21c7](https://github.com/react-native-maps/react-native-maps/commit/73f21c7ef447340fb8632ea597232d01ab9ae3d7))

# [1.4.0](https://github.com/react-native-maps/react-native-maps/compare/v1.3.2...v1.4.0) (2023-01-25)

### Bug Fixes

- **ios:** remove custom podspec xcconfig ([7f6ef12](https://github.com/react-native-maps/react-native-maps/commit/7f6ef121aeea4c4a0f662c017b0515f4ed92ac14))

### Features

- **ios:** support apple silicon macs without rosetta ([da7ba81](https://github.com/react-native-maps/react-native-maps/commit/da7ba81c5d7bd202e10ab2e443a3ba4c2f0eba63))

# [1.4.0-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.3.2...v1.4.0-beta.1) (2022-10-10)

### Features

- **android:** pin androidx.work version ([73f21c7](https://github.com/react-native-maps/react-native-maps/commit/73f21c7ef447340fb8632ea597232d01ab9ae3d7))

## [1.3.2](https://github.com/react-native-maps/react-native-maps/compare/v1.3.1...v1.3.2) (2022-09-26)

### Bug Fixes

- **android:** initialCamera delay ([b4c20b0](https://github.com/react-native-maps/react-native-maps/commit/b4c20b0882730e7a98477fb1e279120a103dc455)), closes [#4442](https://github.com/react-native-maps/react-native-maps/issues/4442)
- **ios:** add header paths required for use_frameworks compilation ([e98be83](https://github.com/react-native-maps/react-native-maps/commit/e98be837ab256c6b7f593182e754579779aebd92)), closes [/github.com/react-native-maps/react-native-maps/discussions/4389#discussioncomment-3658882](https://github.com//github.com/react-native-maps/react-native-maps/discussions/4389/issues/discussioncomment-3658882)

## [1.3.2-beta.2](https://github.com/react-native-maps/react-native-maps/compare/v1.3.2-beta.1...v1.3.2-beta.2) (2022-09-21)

### Bug Fixes

- **android:** initialCamera delay ([b4c20b0](https://github.com/react-native-maps/react-native-maps/commit/b4c20b0882730e7a98477fb1e279120a103dc455)), closes [#4442](https://github.com/react-native-maps/react-native-maps/issues/4442)

## [1.3.2-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.3.1...v1.3.2-beta.1) (2022-09-18)

### Bug Fixes

- **ios:** add header paths required for use_frameworks compilation ([e98be83](https://github.com/react-native-maps/react-native-maps/commit/e98be837ab256c6b7f593182e754579779aebd92)), closes [/github.com/react-native-maps/react-native-maps/discussions/4389#discussioncomment-3658882](https://github.com//github.com/react-native-maps/react-native-maps/discussions/4389/issues/discussioncomment-3658882)

## [1.3.1](https://github.com/react-native-maps/react-native-maps/compare/v1.3.0...v1.3.1) (2022-08-29)

### Bug Fixes

- **MapView:** invalid parameter passed to nativemodule methods ([#4423](https://github.com/react-native-maps/react-native-maps/issues/4423)) ([e4c6b86](https://github.com/react-native-maps/react-native-maps/commit/e4c6b8691375fb120abcc39bd20f0bf6703f10f1)), closes [#4415](https://github.com/react-native-maps/react-native-maps/issues/4415)

# [1.3.0](https://github.com/react-native-maps/react-native-maps/compare/v1.2.0...v1.3.0) (2022-08-22)

### Bug Fixes

- **android:** onLayout not being called ([#4404](https://github.com/react-native-maps/react-native-maps/issues/4404)) ([0596061](https://github.com/react-native-maps/react-native-maps/commit/0596061fc0712b732f0530403d489429110cc9a8)), closes [#4402](https://github.com/react-native-maps/react-native-maps/issues/4402)
- **ios-google:** circle & polygon props not being applied ([ecc1a9a](https://github.com/react-native-maps/react-native-maps/commit/ecc1a9a33d9399eaf3c8a3bed7d68247c12fc8d9)), closes [#3057](https://github.com/react-native-maps/react-native-maps/issues/3057)
- make viewRef for native commands NonNullable ([d35000e](https://github.com/react-native-maps/react-native-maps/commit/d35000e92528082bd4f16499bdd8278a2587bb3c))

### Features

- **MapMarker:** migrate off dispatchViewManagerCommand ([7b01625](https://github.com/react-native-maps/react-native-maps/commit/7b0162553a7a57e902f38d2b473116e62e8789e5))
- **MapView:** migrate off dispatchViewManagerCommand ([794727e](https://github.com/react-native-maps/react-native-maps/commit/794727e59b53cf1a647098139ef0093ad30a74f9))
- migrate off findNodeHandle ([08ffc4a](https://github.com/react-native-maps/react-native-maps/commit/08ffc4ac398b38e0efe7c4d8da52e56f924f028d))

# [1.3.0-beta.3](https://github.com/react-native-maps/react-native-maps/compare/v1.3.0-beta.2...v1.3.0-beta.3) (2022-08-18)

### Bug Fixes

- **android:** onLayout not being called ([#4404](https://github.com/react-native-maps/react-native-maps/issues/4404)) ([0596061](https://github.com/react-native-maps/react-native-maps/commit/0596061fc0712b732f0530403d489429110cc9a8)), closes [#4402](https://github.com/react-native-maps/react-native-maps/issues/4402)

# [1.3.0-beta.2](https://github.com/react-native-maps/react-native-maps/compare/v1.3.0-beta.1...v1.3.0-beta.2) (2022-08-12)

### Bug Fixes

- **ios-google:** circle & polygon props not being applied ([ecc1a9a](https://github.com/react-native-maps/react-native-maps/commit/ecc1a9a33d9399eaf3c8a3bed7d68247c12fc8d9)), closes [#3057](https://github.com/react-native-maps/react-native-maps/issues/3057)
- make viewRef for native commands NonNullable ([d35000e](https://github.com/react-native-maps/react-native-maps/commit/d35000e92528082bd4f16499bdd8278a2587bb3c))

### Features

- migrate off findNodeHandle ([08ffc4a](https://github.com/react-native-maps/react-native-maps/commit/08ffc4ac398b38e0efe7c4d8da52e56f924f028d))

# [1.3.0-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.2.0...v1.3.0-beta.1) (2022-08-11)

### Features

- **MapMarker:** migrate off dispatchViewManagerCommand ([7b01625](https://github.com/react-native-maps/react-native-maps/commit/7b0162553a7a57e902f38d2b473116e62e8789e5))
- **MapView:** migrate off dispatchViewManagerCommand ([794727e](https://github.com/react-native-maps/react-native-maps/commit/794727e59b53cf1a647098139ef0093ad30a74f9))

# [1.2.0](https://github.com/react-native-maps/react-native-maps/compare/v1.1.0...v1.2.0) (2022-08-05)

### Bug Fixes

- **ci:** changelog.md generation ([c842a2b](https://github.com/react-native-maps/react-native-maps/commit/c842a2bb7cbbbc0ccee8322b9790c7d6829d253b))

### Features

- **android:** code cleanup ([#4352](https://github.com/react-native-maps/react-native-maps/issues/4352)) ([e56c787](https://github.com/react-native-maps/react-native-maps/commit/e56c7873c990113cb4a92436297a56be1c194961))
- **geojson:** support for tracksViewChanges in Geojson component ([#4347](https://github.com/react-native-maps/react-native-maps/issues/4347)) ([d7046bb](https://github.com/react-native-maps/react-native-maps/commit/d7046bbc64afb66d12776fab79930c546f2d6674))

# [1.2.0-beta.2](https://github.com/react-native-maps/react-native-maps/compare/v1.2.0-beta.1...v1.2.0-beta.2) (2022-08-05)

### Features

- **geojson:** support for tracksViewChanges in Geojson component ([#4347](https://github.com/react-native-maps/react-native-maps/issues/4347)) ([d7046bb](https://github.com/react-native-maps/react-native-maps/commit/d7046bbc64afb66d12776fab79930c546f2d6674))

# [1.2.0-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.1.1-beta.1...v1.2.0-beta.1) (2022-07-24)

### Features

- **android:** code cleanup ([#4352](https://github.com/react-native-maps/react-native-maps/issues/4352)) ([e56c787](https://github.com/react-native-maps/react-native-maps/commit/e56c7873c990113cb4a92436297a56be1c194961))

## [1.1.1-beta.1](https://github.com/react-native-maps/react-native-maps/compare/v1.1.0...v1.1.1-beta.1) (2022-07-22)

### Bug Fixes

- **ci:** changelog.md generation ([c842a2b](https://github.com/react-native-maps/react-native-maps/commit/c842a2bb7cbbbc0ccee8322b9790c7d6829d253b))

# [1.1.0](https://github.com/react-native-maps/react-native-maps/compare/v1.0.3...v1.1.0) (2022-07-20)

### Bug Fixes

- **mapview:** re-add setNativeProps helper function ([c6e34ea](https://github.com/react-native-maps/react-native-maps/commit/c6e34ea3109784e1632981df6a00156904f9ce7c))

### Features

- **android:** bump play-services-base to 18.1.0 ([f90a3f6](https://github.com/react-native-maps/react-native-maps/commit/f90a3f66680988de0cadd04c71d062627fa66ce2))
- **android:** bump play-services-location to 20.0.0 ([440f5b3](https://github.com/react-native-maps/react-native-maps/commit/440f5b332020a7e8909cb1658bc786b377b42dc4))
- **ios-google:** enable metal renderer ([#4336](https://github.com/react-native-maps/react-native-maps/issues/4336)) ([d8770fa](https://github.com/react-native-maps/react-native-maps/commit/d8770faa36ddb8c8bb3057f95d3bf220c889ba47)), closes [#4130](https://github.com/react-native-maps/react-native-maps/issues/4130)
- **mapview:** remove componentDidUpdate logic ([625e765](https://github.com/react-native-maps/react-native-maps/commit/625e765c132ef551588dcd25249c118702def751))
- **mapview:** remove use of setNativeProps for customMapStyleString ([7d9ebf8](https://github.com/react-native-maps/react-native-maps/commit/7d9ebf8b3248518da6a2bf11b3d474cebc51abb6))
- **mapview:** stop intercepting onLayout ([0554cdc](https://github.com/react-native-maps/react-native-maps/commit/0554cdcc666f8ace40b5e94de17598c2f1b5d528))
- **mapview:** stop setting region and initialregion in onMapReady js side ([13817ca](https://github.com/react-native-maps/react-native-maps/commit/13817cad34062fe8bf997855367a140daaca87a9))

## [1.0.3](https://github.com/react-native-maps/react-native-maps/compare/v1.0.2...v1.0.3) (2022-07-19)

### Bug Fixes

- **android:** animateToRegion not working with duration 0 ([#4339](https://github.com/react-native-maps/react-native-maps/issues/4339)) ([a6d9ce2](https://github.com/react-native-maps/react-native-maps/commit/a6d9ce2ec79f7ab256bfedb0f5f092f389b725be)), closes [#4338](https://github.com/react-native-maps/react-native-maps/issues/4338)

## [1.0.2](https://github.com/react-native-maps/react-native-maps/compare/v1.0.1...v1.0.2) (2022-07-15)

### Bug Fixes

- **types:** missing marker-press action for MapPressEvent ([#4330](https://github.com/react-native-maps/react-native-maps/issues/4330)) ([7461e48](https://github.com/react-native-maps/react-native-maps/commit/7461e48409d6667a38f219bafc7b77a281cca35c)), closes [#4320](https://github.com/react-native-maps/react-native-maps/issues/4320)

## [1.0.1](https://github.com/react-native-maps/react-native-maps/compare/v1.0.0...v1.0.1) (2022-07-15)

### Bug Fixes

- **ios-google:** crash when setting initialCamera prop ([2b80944](https://github.com/react-native-maps/react-native-maps/commit/2b809446286a0b922bb7f5643c69792eaf6cc90c)), closes [#4321](https://github.com/react-native-maps/react-native-maps/issues/4321)

# [1.0.0](https://github.com/react-native-maps/react-native-maps/compare/v0.31.1...v1.0.0) (2022-07-07)

### Bug Fixes

- **android:** longLogTag debug error ([fa452ec](https://github.com/react-native-maps/react-native-maps/commit/fa452eca5559f79c73afec0afe387ca2f23cfd10)), closes [#4233](https://github.com/react-native-maps/react-native-maps/issues/4233)
- **android:** wrong coordinates on press polyline ([1868b42](https://github.com/react-native-maps/react-native-maps/commit/1868b42e5003d99314b7570c0a2cdbc94b73b318))
- **ios:** camera being set repeatedly in didPrepareMap ([46b52d4](https://github.com/react-native-maps/react-native-maps/commit/46b52d40b70e0ac146c92b24932e5e76fb839ef6)), closes [/github.com/react-native-maps/react-native-maps/pull/4241#issuecomment-1142160942](https://github.com//github.com/react-native-maps/react-native-maps/pull/4241/issues/issuecomment-1142160942)
- **ios:** icon flash glitch from [#3657](https://github.com/react-native-maps/react-native-maps/issues/3657) and [#3418](https://github.com/react-native-maps/react-native-maps/issues/3418) ([#4229](https://github.com/react-native-maps/react-native-maps/issues/4229)) ([b734a5a](https://github.com/react-native-maps/react-native-maps/commit/b734a5a28ece0b21eef9b5ef7df8d9d25ab5cdde))
- **ios:** initialRegion on Google Maps ([d6e0ce7](https://github.com/react-native-maps/react-native-maps/commit/d6e0ce7e2087022fe7d0922a008a02100fc65eab)), closes [#4244](https://github.com/react-native-maps/react-native-maps/issues/4244)
- **ios:** onMapReady not always called with google provider ([e035c8d](https://github.com/react-native-maps/react-native-maps/commit/e035c8dc16361412f9b42674e96bca152a158d99)), closes [#4066](https://github.com/react-native-maps/react-native-maps/issues/4066)
- **ios:** wrong coordinates on pressing polyline ([#4304](https://github.com/react-native-maps/react-native-maps/issues/4304)) ([27cc80a](https://github.com/react-native-maps/react-native-maps/commit/27cc80a046d84a88636b9e6af1c6ff40dd9c2eb0))
- **mapkit:** onRegionChangeComplete called before region change completed ([7ea9658](https://github.com/react-native-maps/react-native-maps/commit/7ea9658c87ac0382157df47873444d803bd51dfe)), closes [#4265](https://github.com/react-native-maps/react-native-maps/issues/4265)
- missing context provider ([b43c62e](https://github.com/react-native-maps/react-native-maps/commit/b43c62e4eb45e4368b635046bc9d05a3414da892))
- **types:** export types that were present before v1 ([#4267](https://github.com/react-native-maps/react-native-maps/issues/4267)) ([fd798c9](https://github.com/react-native-maps/react-native-maps/commit/fd798c9826a9edfa936716e8ed78d40c07ccb9c7))
- **types:** showsBuilding prop on MapView ([#4283](https://github.com/react-native-maps/react-native-maps/issues/4283)) ([593768f](https://github.com/react-native-maps/react-native-maps/commit/593768fae7a5ae2d8dcb863cc879078d8a24e4f7))

### Features

- **android:** remove internet & location permissions from AndroidManifest ([849b1bc](https://github.com/react-native-maps/react-native-maps/commit/849b1bc4859cf3667ae374fc597a4b9ebf67e865))
- **android:** support files from AssetManager in LocalTile ([f885d4b](https://github.com/react-native-maps/react-native-maps/commit/f885d4b9b6ab09656cef3df008afe79665cd4f72)), closes [#4153](https://github.com/react-native-maps/react-native-maps/issues/4153)
- **ios-google:** bump maps sdk to 7.0.0 ([32eb294](https://github.com/react-native-maps/react-native-maps/commit/32eb294ad551955efcbb7b9add380d3234930052))
- **ios-google:** move initial region logic to layoutSubviews ([d8f20cd](https://github.com/react-native-maps/react-native-maps/commit/d8f20cdac7861ef3dc276c050e45a43bcb8df534))
- **ios-google:** stop setting the camera if layoutSubviews wasn't triggered ([5b6b3bc](https://github.com/react-native-maps/react-native-maps/commit/5b6b3bc651eeff2fb4858273789337bbeea5b8c0))
- **ios:** bump google maps sdk to 6.2.1 ([b1df2e2](https://github.com/react-native-maps/react-native-maps/commit/b1df2e2339e97c07011e72dad5566897d180d08e))
- **ios:** remove deprecated snapshot method ([c0bb8f3](https://github.com/react-native-maps/react-native-maps/commit/c0bb8f37cea1aa515beb54a2a0070360d55d1c1c))
- **ios:** stop requesting location permissions in showsUserLocation ([1d0e381](https://github.com/react-native-maps/react-native-maps/commit/1d0e381e4a2803f8e41e7d73516fff57a1b14cd5)), closes [#4166](https://github.com/react-native-maps/react-native-maps/issues/4166)
- migrate to typescript ([adc7670](https://github.com/react-native-maps/react-native-maps/commit/adc76701cf3a0c076680441aa1cac7827a4d9f42))
- remove deprecated mapview methods ([d053fd2](https://github.com/react-native-maps/react-native-maps/commit/d053fd2e7736e3e2ea9baf7376a947c3b0b92a58))
- require react-native >= 0.64.3 ([8b852c1](https://github.com/react-native-maps/react-native-maps/commit/8b852c17b923e00970be8f462e76802eec8a1a3f))
- use package.json as source of truth for podspecs ([d48fab5](https://github.com/react-native-maps/react-native-maps/commit/d48fab5c2527722e6fd19206cd49f4e9470dd0c3))

### BREAKING CHANGES

- **ios:** polyline onPress returns tapLocation instead of the first point in the polyline
- **ios-google:** Using Google Maps on iOS now requires iOS >= 13.0 and XCode >= 13
- **android:** polyline onPress returns tapLocation instead of the first point in the polyline
- **ios:** Requesting location permissions manually is now needed for showsUserLocation.
- **android:** internet & location permissions removed from AndroidManifest
- **ios:** legacy iOS snapshot method removed
- removed animateTo{Navigation,Coordinate,Bearing,ViewingAngle}.
- types are now being emitted automatically and some might have changed.
- react-native-maps now requires react-native >= 0.64.3.
- Components are no longer exported as members of MapView. Import the components you need, e.g. `import MapView, {Marker} from 'react-native-maps';` instead.

## [0.30.2](https://github.com/react-native-maps/react-native-maps/compare/v0.30.1...v0.30.2) (2022-05-17)

### Bug Fixes

- **android:** android 12 crash ([7cffb97](https://github.com/react-native-maps/react-native-maps/commit/7cffb9737244edf28b6682520cc28e1ef98160e3))
- migrate to deprecated-react-native-prop-types ([4bfb8a1](https://github.com/react-native-maps/react-native-maps/commit/4bfb8a1f561d77dabf0e81ef4ff6a208fe3f5ae5))

## [0.31.1](https://github.com/react-native-maps/react-native-maps/compare/v0.31.0...v0.31.1) (2022-04-30)

### Bug Fixes

- **ios:** pod install failing with deployment target 11.0 ([f7c8903](https://github.com/react-native-maps/react-native-maps/commit/f7c8903501f4adbf982462d605c5c8d548e777ff))

# [0.31.0](https://github.com/react-native-maps/react-native-maps/compare/v0.30.0...v0.31.0) (2022-04-24)

### Bug Fixes

- **android:** add null checks for map in MapView ([585d89e](https://github.com/react-native-maps/react-native-maps/commit/585d89e84ba52f2e463300451693b53c3758e649)), closes [#4074](https://github.com/react-native-maps/react-native-maps/issues/4074)
- **android:** android 12 crash ([7ccc65d](https://github.com/react-native-maps/react-native-maps/commit/7ccc65d83b409735034912279d72a7c6dc232066))
- **android:** initialRegion delay ([609571f](https://github.com/react-native-maps/react-native-maps/commit/609571fa2dedd7670bd85596a60e26f9c0f27293)), closes [#4060](https://github.com/react-native-maps/react-native-maps/issues/4060)
- **android:** opacity is ignored on first render of overlay ([#4141](https://github.com/react-native-maps/react-native-maps/issues/4141)) ([9a7621c](https://github.com/react-native-maps/react-native-maps/commit/9a7621c2ba957e574eb6f96b266a40dd76f7e262))
- **android:** remove use of lambda expression ([4592499](https://github.com/react-native-maps/react-native-maps/commit/4592499c153804de5dca5a17c2015338baf2767b)), closes [#4160](https://github.com/react-native-maps/react-native-maps/issues/4160)
- remove upper react version limit ([70e34a1](https://github.com/react-native-maps/react-native-maps/commit/70e34a13a9e7bb51f21a67df8f123ad930281212)), closes [#4167](https://github.com/react-native-maps/react-native-maps/issues/4167)

### Features

- **android:** add support for new google maps renderer ([#4055](https://github.com/react-native-maps/react-native-maps/issues/4055)) ([bb08557](https://github.com/react-native-maps/react-native-maps/commit/bb0855714895e5264f4f6b3ebc9f3cdc6350b39a))
- **ios:** bump google maps pods ([73e6ef6](https://github.com/react-native-maps/react-native-maps/commit/73e6ef6cd3b1e448f1395cdec80cd19f354ab8f6)), closes [#4157](https://github.com/react-native-maps/react-native-maps/issues/4157)
- migrate to deprecated-react-native-prop-types ([5bc1cc6](https://github.com/react-native-maps/react-native-maps/commit/5bc1cc67ab1a110e53bde238ccbb40d7dfef547f))

## 0.30.1 - (January 3, 2022)

- Common: [#4011](https://github.com/react-native-maps/react-native-maps/pull/4011) Feature fix AnimatedRegion getAnimatedValue Issue

## 0.30.0 - (November 10, 2021)

- Common: [#3789](https://github.com/react-native-maps/react-native-maps/pull/3789) URLTile tile caching
- Common: [#3938](https://github.com/react-native-maps/react-native-maps/pull/3938) Add URLTile & WMSTile opacity property
- Common: [#3996](https://github.com/react-native-maps/react-native-maps/pull/3996) Allow wider version range for react-native-web peer dependency
- Common: [#3977](https://github.com/react-native-maps/react-native-maps/pull/3977) Upgrade example app to React Native 0.65.1
- Common: [#3972](https://github.com/react-native-maps/react-native-maps/pull/3972) Fix default color and stroke width properties for Geojson component
- Common: [#3965](https://github.com/react-native-maps/react-native-maps/pull/3965) GeoJSON Marker Title Prop & A bit Refactor
- Common: [#3744](https://github.com/react-native-maps/react-native-maps/pull/3744) Updates AnimatedRegion component
- Common: [#3966](https://github.com/react-native-maps/react-native-maps/pull/3966) Fix polygon on press wrong coordinates
- iOS: [#3997](https://github.com/react-native-maps/react-native-maps/pull/3997) Allow markers to be un-tappable on ios gmaps
- iOS: [#3944](https://github.com/react-native-maps/react-native-maps/pull/3944) Add heading to onUserLocationChange
- iOS: [#3956](https://github.com/react-native-maps/react-native-maps/pull/3956) Add missing export for AIRMapMarker isPreselected view property
- iOS: [#3973](https://github.com/react-native-maps/react-native-maps/pull/3973) Version bump googleMaps and Google-Maps-iOS-Utils
- Android: [#3945](https://github.com/react-native-maps/react-native-maps/pull/3945) Bump minSDKVersion to 21

## 0.29.4 - (November 10, 2021)

- Common: [#3996](https://github.com/react-native-maps/react-native-maps/pull/3996) Allow wider version range for react-native-web peer dependency

## 0.29.3 - (August 29, 2021)

- Common: [#3920](https://github.com/react-native-maps/react-native-maps/pull/3920) GeoJSON onPress Crash Fix and Marker Customization Options
- Common: [#3930](https://github.com/react-native-maps/react-native-maps/pull/3930) Updated peer deps to maintain compatibility with expo init

## 0.29.2 - (July 5, 2021)

- Android: **Revert** [#3797](https://github.com/react-native-maps/react-native-maps/pull/3797) Allow a previously dashed line to be made solid

## 0.29.1 - (July 5, 2021)

- Common: [#3855](https://github.com/react-native-maps/react-native-maps/pull/3855) Fix crashes related to getAddressFromCoordinates for android and iOS
- Common: [#3871](https://github.com/react-native-maps/react-native-maps/pull/3871) Allow React 17 peer dependency

## 0.29.0 - (June 8, 2021)

- Common: [#3779](https://github.com/react-native-maps/react-native-maps/pull/3779) Polyline tappable feature on GeoJson
- Common: [#3784](https://github.com/react-native-maps/react-native-maps/pull/3784) Implemented scrollDuringRotateOrZoom control for Google Maps
- Common: [#3739](https://github.com/react-native-maps/react-native-maps/pull/3739) Use Default Geocoder to convert Coordinates by getting address
- Common: [#3728](https://github.com/react-native-maps/react-native-maps/pull/3728) Add `onPress` for GeoJSON
- Common: [#3737](https://github.com/react-native-maps/react-native-maps/pull/3737) Added support for overlay rotations in Google Maps API
- iOS: [#3754](https://github.com/react-native-maps/react-native-maps/pull/3754) Fix indoor events on iOS for multiple MapViews
- iOS: [#3762](https://github.com/react-native-maps/react-native-maps/pull/3762) Add support for disabling userLocation callout
- iOS: [#3746](https://github.com/react-native-maps/react-native-maps/pull/3746) Fix in WMSTile: typings & component removal on iOS
- iOS: [#3764](https://github.com/react-native-maps/react-native-maps/pull/3764) Provide a way to override mapkit style
- Android: [#3726](https://github.com/react-native-maps/react-native-maps/pull/3726) Use double on `setCamera` to fix zoom precision.
- Android: [#3308](https://github.com/react-native-maps/react-native-maps/pull/3308) Fix fitToCoordinates with preset mapPadding
- Android: [#3797](https://github.com/react-native-maps/react-native-maps/pull/3797) Allow a previously dashed line to be made solid
- Docs: [#3768](https://github.com/react-native-maps/react-native-maps/pull/3768) Clean up old installation instructions
- Docs: [#3771](https://github.com/react-native-maps/react-native-maps/pull/3771) Better docs for custom markers
- Docs: [#3716](https://github.com/react-native-maps/react-native-maps/pull/3716) Update Mapview docs
- Docs: [#3793](https://github.com/react-native-maps/react-native-maps/pull/3793) Update Polygon docs

## 0.28.1 - (November 10, 2021)

- Common: [#3996](https://github.com/react-native-maps/react-native-maps/pull/3996) Allow wider version range for react-native-web peer dependency

## 0.28.0 (April 20, 2021)

- Common: [#3705](https://github.com/react-native-maps/react-native-maps/pull/3705) Update example project
- Common: [#3424](https://github.com/react-native-maps/react-native-maps/pull/3424) Bugfix for the "require cycles" warning
- Common: [#3452](https://github.com/react-native-maps/react-native-maps/pull/3452) Ability to pass a Marker image as Geojson prop
- Common: [#3516](https://github.com/react-native-maps/react-native-maps/pull/3516) Polyline props to obtain dashed/dotted lines in Geojson component
- Common: [#3358](https://github.com/react-native-maps/react-native-maps/pull/3358) onRegionChange sends a boolean indicating if the move was from the user (true) or an animation (false)
- Common: [#3658](https://github.com/react-native-maps/react-native-maps/pull/#3658) Geojson stroke color, stroke width, fill color, and marker color properties preserved
- Common: [#3695](https://github.com/react-native-maps/react-native-maps/pull/3695) AnimateCamera duration bugfixed
- iOS: [#3383](https://github.com/react-native-maps/react-native-maps/pull/3383) Added tintColor prop for setting the color of the map
- Android: [#3414](https://github.com/react-native-maps/react-native-maps/pull/3414) Play services version updated

## 0.27.1 (March 19, 2020)

- Android: [#3345](https://github.com/react-native-maps/react-native-maps/pull/3345) Protect against null Location in FusedLocationSource
- Android: [#3351](https://github.com/react-native-maps/react-native-maps/pull/3351) Revert "android google map callout support <Image/>

## 0.27.0 (March 4, 2020)

- iOS: [#3115](https://github.com/react-native-maps/react-native-maps/pull/3115) Expose isAccessibilityElement as a prop
- iOS: [#3119](https://github.com/react-native-maps/react-native-maps/pull/3119) Add `mapPadding` prop
- iOS: [#3134](https://github.com/react-native-maps/react-native-maps/pull/3134) Add `isPreselected` prop
- iOS: [#3120](https://github.com/react-native-maps/react-native-maps/pull/3120) Keep current mapType when taking snapshot
- iOS: [#2889](https://github.com/react-native-maps/react-native-maps/pull/2889) Implement onUserLocationChange
- iOS: [#3136](https://github.com/react-native-maps/react-native-maps/pull/3136) Use RCTImageLoaderProtocol for RN v0.61.0
- iOS: [#3125](https://github.com/react-native-maps/react-native-maps/pull/3125) Replace deprecated bridge.imageLoader calls with moduleForClass API
- iOS: [#3309](https://github.com/react-native-maps/react-native-maps/pull/3309) Fixes for polygon custom styles not being applied when provider is Google maps
- iOS: [#3104](https://github.com/react-native-maps/react-native-maps/pull/3104) Only handle cacheEnable when app is active
- Android: [#2993](https://github.com/react-native-maps/react-native-maps/pull/2993) Improved user location
- Common: [#3163](https://github.com/react-native-maps/react-native-maps/pull/3163) Opacity prop for MapOverlay on Android and iOS (Google Maps)
- Common: [#3131](https://github.com/react-native-maps/react-native-maps/pull/3131) AnimatedRegion.addListener() property setting

## 0.26.1 (October 3, 2019)

- Android: [#3103](https://github.com/react-native-maps/react-native-maps/pull/3103) Support for RN 0.60.5
- Android: [#3103](https://github.com/react-native-maps/react-native-maps/pull/3103) "AIRMap" was not found in the UIManager

## 0.26.0 (September 30, 2019)

- iOS: [#2999](https://github.com/react-native-maps/react-native-maps/pull/2999) Update GoogleMaps pod to 3.2.0
- iOS: [#2395](https://github.com/react-native-maps/react-native-maps/pull/2395) Allow using onPanDrag while scrollEnabled=true
- iOS: [#3051](https://github.com/react-native-maps/react-native-maps/pull/3051) Add flat property binding on Marker for iOS
- Android: [#3007](https://github.com/react-native-maps/react-native-maps/pull/3007) Add Overlay onPress event
- Android: [#3001](https://github.com/react-native-maps/react-native-maps/pull/3001) Add @ReactModule annotation to help turbo modules processor
- Common: [#3045](https://github.com/react-native-maps/react-native-maps/pull/3045) Add heading to the onUserLocationChange listener
- Common: [#2937](https://github.com/react-native-maps/react-native-maps/pull/2937) Add onDoublePress callback
- Common: [#2960](https://github.com/react-native-maps/react-native-maps/pull/2959) Heatmaps for Android and iOS
- Common: [#2959](https://github.com/react-native-maps/react-native-maps/pull/2959) Added GeoJSON support by default
- Common: [#2975](https://github.com/react-native-maps/react-native-maps/pull/2975) Convert to new react native config format (RN 0.60)
- Common: [#2973](https://github.com/react-native-maps/react-native-maps/pull/2973) Fix select annotation when show/hide callout view

## 0.25.0 (July 11, 2019)

- Android: [#2941](https://github.com/react-native-maps/react-native-maps/pull/2941) Fix build gradle to allow jettifier to run correctly
- Android: [#2741](https://github.com/react-native-maps/react-native-maps/pull/2741) Use a shared image icon for markers when they share the same image URI
- Android: [#2557](https://github.com/react-native-maps/react-native-maps/pull/2557) Fix bug when changing subview of Marker to icon
- Android: [#2392](https://github.com/react-native-maps/react-native-maps/pull/2392) Add support for loading base64 encoded image
- iOS: [#2423](https://github.com/react-native-maps/react-native-maps/pull/2423) Handle annotations without images on iOS map snapshot
- iOS: [#2881](https://github.com/react-native-maps/react-native-maps/pull/2881) Update podspec to use GoogleMaps 3.1.0
- iOS: [#2253](https://github.com/react-native-maps/react-native-maps/pull/2253) TestID's for e2e automation
- iOS: [#2826](https://github.com/react-native-maps/react-native-maps/pull/2826) Follow up for [#2253](https://github.com/react-native-maps/react-native-maps/pull/2253)
- iOS: [#2397](https://github.com/react-native-maps/react-native-maps/pull/2397) Add compass location offsets for iOS maps
- Common: [#2568](https://github.com/react-native-maps/react-native-maps/pull/2568) Support for WMS Layer support
- Common: [#2017](https://github.com/react-native-maps/react-native-maps/pull/2017) Update the Google Maps custom map style if changed after initialization
- Common: [#2903](https://github.com/react-native-maps/react-native-maps/pull/2903) Fix react snapshot undefined warning

## 0.24.2 (April 17, 2019)

- iOS: [#2818](https://github.com/react-native-maps/react-native-maps/pull/2818) Google Maps - Weak refs to gesture targets to address memory leak

## 0.24.1 (April 16, 2019)

- iOS: [#2815](https://github.com/react-native-maps/react-native-maps/pull/2815) Google Maps - Free instance variable in getActionForTarget to address memory leak

## 0.24.0 (April 11, 2019)

- Common: [#2740](https://github.com/react-native-maps/react-native-maps/pull/2740) Fix deprecated UIManager usage when accessing component names
- Common: [#2393](https://github.com/react-native-maps/react-native-maps/pull/2393) add typings for pointForCoordinate & coordinateForPoint
- Common: [#2732](https://github.com/react-native-maps/react-native-maps/pull/2732) Implement ability to flip y coordinate for Google Map tiles.
- Android: [#2765](https://github.com/react-native-maps/react-native-maps/pull/2765) Allow setting of play-services version through ext
- Android: [#2702](https://github.com/react-native-maps/react-native-maps/pull/2702) Enable RN projects to define the Android AppCompat Library version
- Android: [#2720](https://github.com/react-native-maps/react-native-maps/pull/2720) Fix Android dependencies and build errors
- Android: [#2682](https://github.com/react-native-maps/react-native-maps/pull/2682) Implement 'tappable' prop on polyline for Android
- Android: [#2417](https://github.com/react-native-maps/react-native-maps/pull/2417) Support for lineCap and lineDash pattern
- Android: [#2727](https://github.com/react-native-maps/react-native-maps/pull/2727) fix build: only apply mvn push gradle plugin if POM_ARTIFACT_ID is set
- iOS: [#2446](https://github.com/react-native-maps/react-native-maps/pull/2446) fix iOS GoogleMaps camera always animate
- iOS: [#2746](https://github.com/react-native-maps/react-native-maps/pull/2746) onPanDrag support for iOS
- iOS: [#2581](https://github.com/react-native-maps/react-native-maps/pull/2581) Custom callout improvements 
- iOS: [#2794](https://github.com/react-native-maps/react-native-maps/pull/2794) Fix CalloutSubview on Apple maps
- iOS: [#2716](https://github.com/react-native-maps/react-native-maps/pull/2716) Fix Memory Leaks
- Docs: [#2675](https://github.com/react-native-maps/react-native-maps/pull/2675) [#2685](https://github.com/react-native-maps/react-native-maps/pull/2685) [#2707](https://github.com/react-native-maps/react-native-maps/pull/2707) [#2704](https://github.com/react-native-maps/react-native-maps/pull/2704)
- Example: [#2792](https://github.com/react-native-maps/react-native-maps/pull/2792) Upgrade Example to react-native to 0.59.3
- TypeScript: [#2705](https://github.com/react-native-maps/react-native-maps/pull/2705) Add Marker icon property introduced in [#2650](https://github.com/react-native-maps/react-native-maps/pull/2650) to index.d.ts

## 0.23.0 (January 17, 2019)

- Common: [#2651](https://github.com/react-native-maps/react-native-maps/pull/2651) Use `resolveAssetSource` method from Image
- Common: [#2576](https://github.com/react-native-maps/react-native-maps/pull/2576) Fix import error for `MapMarker` and `MapOverlay`
- Common: [#2615](https://github.com/react-native-maps/react-native-maps/pull/2615) Added helper method for calculating bounding box from region
- Common: [#2607](https://github.com/react-native-maps/react-native-maps/pull/2607) Fix camera type definition error
- Common: [#2563](https://github.com/react-native-maps/react-native-maps/pull/2563) Added camera system and deprecate `animateTo` methods
- Common: [#2571](https://github.com/react-native-maps/react-native-maps/pull/2571) Added `getMapBoundaries` to `MapView`
- Common/iOS: [#2650](https://github.com/react-native-maps/react-native-maps/pull/2650) Added `icon` prop for `MapMarker`
- iOS: [#2414](https://github.com/react-native-maps/react-native-maps/pull/2414) Fix path for yoga in Podfile
- iOS: [#2627](https://github.com/react-native-maps/react-native-maps/pull/2627) Added `tileSize` prop for `MapUrlTile`
- iOS: [#2608](https://github.com/react-native-maps/react-native-maps/pull/2608) Fix `animateToCamera`
- Android: [#2653](https://github.com/react-native-maps/react-native-maps/pull/2653) Defaults to the map services version instead of play services
- Android: [#2587](https://github.com/react-native-maps/react-native-maps/pull/2587) Allow specifying a different version for base and maps on android
- Android: [#2598](https://github.com/react-native-maps/react-native-maps/pull/2598) Fix crash for cannot getActiveLevelIndex
- Docs: [#2639](https://github.com/react-native-maps/react-native-maps/pull/2639) Added note about recursive framework search paths
- Docs: [#2631](https://github.com/react-native-maps/react-native-maps/pull/2631) Added notes for Google Play Services

## 0.22.1 (November 8, 2018)

- Common: [#2548](https://github.com/react-community/react-native-maps/pull/2548) Moved `babel-plugin-module-resolver` and `babel-preset-react-native` from dependencies to devDependencies
- Android: [#2555](https://github.com/react-community/react-native-maps/pull/2555) Fixed [#2507](https://github.com/react-community/react-native-maps/issues/2507)
- Android: [#2545](https://github.com/react-community/react-native-maps/pull/2545) Fixed The specified child already has a parent
- Docs: [#2541](https://github.com/react-community/react-native-maps/pull/2541) Improve installation docs
- Docs: [#2550](https://github.com/react-community/react-native-maps/pull/2550) Specify how to use Google Maps
- Docs: [#2559](https://github.com/react-community/react-native-maps/pull/2559) Clarify cacheEnabled is apple maps only

## 0.22.0 (October 11, 2018)

- Common: [#2049](https://github.com/react-community/react-native-maps/pull/2049) Added `animateToNavigation` method to `MapView`
- Common: [#2207](https://github.com/react-community/react-native-maps/pull/2207), [#2232](https://github.com/react-community/react-native-maps/pull/2232) Added `timestamp` property to `onUserLocationChange` event callback
- Common: [#2479](https://github.com/react-community/react-native-maps/pull/2479), [#2524](https://github.com/react-community/react-native-maps/pull/2524) Added `edgePadding` to `fitToSuppliedMarkers` function
- Common: [#2448](https://github.com/react-community/react-native-maps/pull/2448) Added custom indoor picker level
- Common: [#2238](https://github.com/react-community/react-native-maps/pull/2238) Support the `asset://` scheme for images
- Common: [#2136](https://github.com/react-community/react-native-maps/pull/2136), [#2184](https://github.com/react-community/react-native-maps/pull/2184) Modifications/Enhancements to MapView.UrlTile
- Common: [#2039](https://github.com/react-community/react-native-maps/pull/2039) Fix for `pointForCoordinate` and `coordinateForPoint`
- Common: [#2217](https://github.com/react-community/react-native-maps/pull/2217) Using `ColorPropType` to validate all color props more accurately
- iOS: [#2396](https://github.com/react-community/react-native-maps/pull/2396) Added installation for iOS via `react-native link`
- iOS: [#2243](https://github.com/react-community/react-native-maps/pull/2243) Added support of `lineDashPattern` polyline props to iOS Google Maps
- iOS: [#2149](https://github.com/react-community/react-native-maps/pull/2149) Added `paddingAdjustmentBehavior` for Google Maps on iOS
- iOS: [#2231](https://github.com/react-community/react-native-maps/pull/2231) Prefix DummyView class
- iOS: [#2229](https://github.com/react-community/react-native-maps/pull/2229) Use global imports for new Pods dependencies in AIRGoogleMap
- iOS: [#2248](https://github.com/react-community/react-native-maps/pull/2248) Make tiles display at the same physical size regardless of pixel density on iOS devices
- iOS: [#2306](https://github.com/react-community/react-native-maps/pull/2306) Prefix or eliminate globals in AIRMapMarker
- iOS: [#2351](https://github.com/react-community/react-native-maps/pull/2351) Added support for `calloutAnchor` with Google Maps on iOS
- iOS: [#2501](https://github.com/react-community/react-native-maps/pull/2501) Fixed issue that app crashes after trigger Marker `onDragEnd`
- iOS: [#2359](https://github.com/react-community/react-native-maps/pull/2359) Fixed zIndex didn't work on map moving on iOS 11
- iOS: [#2185](https://github.com/react-community/react-native-maps/pull/2185) Fixed Xcode warnings for format, pointer type, unused var
- iOS: [#2154](https://github.com/react-community/react-native-maps/pull/2154) Fixed CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF warnings
- iOS: [#2341](https://github.com/react-community/react-native-maps/pull/2341) Fixed warnings about `self`
- Android: [#2224](https://github.com/react-community/react-native-maps/pull/2224) Respect `tappable` prop on Android
- Android: [#2390](https://github.com/react-community/react-native-maps/pull/2390) Consider pixel density in coordinate<->point conversion
- Android: [#2477](https://github.com/react-community/react-native-maps/pull/2477), [#2487](https://github.com/react-community/react-native-maps/pull/2487) Implemented `tracksViewChanges` on Android
- Android: [#2478](https://github.com/react-community/react-native-maps/pull/2478) Let `onVisibilityChanged()` be called on children (mainly fixes `Image` issues)
- Android: [#2375](https://github.com/react-community/react-native-maps/pull/2375) Fixed `lineCap` of Polyline
- Android: [#2320](https://github.com/react-community/react-native-maps/pull/2320) Fixed custom marker updates on Android
- Android: [#2197](https://github.com/react-community/react-native-maps/pull/2197) Fixed overlay removal bug
- Android: [#2317](https://github.com/react-community/react-native-maps/pull/2317) Fixed disabling the toolbar and my location button
- Android: [#2472](https://github.com/react-community/react-native-maps/pull/2472) Fixed compilation error due to minSDK in manifest
- Android: [#2172](https://github.com/react-community/react-native-maps/pull/2172) Fixed crash for Android API level below 18 on isFromMockProvider
- Internal: [#2462](https://github.com/react-community/react-native-maps/pull/2462) Fixed packager script path in `pacakage.json`
- Internal: [#2480](https://github.com/react-community/react-native-maps/pull/2480) Fix peer dependencies
- TypeScript: [#2165](https://github.com/react-community/react-native-maps/pull/2165) Typings improvements & fixes
- Docs: [#2541](https://github.com/react-community/react-native-maps/pull/2541) Vastly improved installation guideline
- Docs: [#2171](https://github.com/react-community/react-native-maps/pull/2171) Add 'none' option to docs for `mapType` of `MapView`
- Docs: [#2174](https://github.com/react-community/react-native-maps/pull/2174) Add opacity to `Marker` API docs
- Docs: [#2181](https://github.com/react-community/react-native-maps/pull/2181), [#2219](https://github.com/react-community/react-native-maps/pull/2219) Add note about mandatory `NSLocationWhenInUseUsageDescription`
- Docs: [#2381](https://github.com/react-community/react-native-maps/pull/2381), [#2358](https://github.com/react-community/react-native-maps/pull/2358), [#2363](https://github.com/react-community/react-native-maps/pull/2363), [#2429](https://github.com/react-community/react-native-maps/pull/2429), [#2425](https://github.com/react-community/react-native-maps/pull/2425) Documentation improvements

## 0.21.0 (March 31, 2018)

- Common: [#2030](https://github.com/react-community/react-native-maps/pull/2030) Broadened peer-dependency support
- Common: [#2035](https://github.com/react-community/react-native-maps/pull/2035), [#2113](https://github.com/react-community/react-native-maps/pull/2113), & [#2141](https://github.com/react-community/react-native-maps/pull/2141) Typescript improvements and fixes
- Common: [#2011](https://github.com/react-community/react-native-maps/pull/2011) Add suport for KML file (Only Markers)
- Common: [#2053](https://github.com/react-community/react-native-maps/pull/2053) Fix 'module undefined' for React Native >= 0.54
- Common: [#2131](https://github.com/react-community/react-native-maps/pull/2131) Fix initialRegion for React Native >= 0.54
- Common: [#2115](https://github.com/react-community/react-native-maps/pull/2115) Upgrade React Native peer dependency to 0.54
- Common: [#2032](https://github.com/react-community/react-native-maps/pull/2032) Add onMyLocationChange event
- Common: [#2039](https://github.com/react-community/react-native-maps/pull/2039) Fixed problem with pointForCoordinate and coordinateForPoint methods
- Common: [#2050](https://github.com/react-community/react-native-maps/pull/2050) Add support for onPoiClick
- iOS: [#2022](https://github.com/react-community/react-native-maps/pull/2022) Add support for Map.Overlay
- iOS: [#2068](https://github.com/react-community/react-native-maps/pull/2068) Prevent marker press from calling MapView onPress
- iOS: [#2057](https://github.com/react-community/react-native-maps/pull/2057) Fixed polygon and polyline not re-rendering when changing tile URL (AirMaps)
- iOS: [#2101](https://github.com/react-community/react-native-maps/pull/2101) Fixed re-render not updating MapView.Circle component in UI when radius or center coordinates change (AirMaps)
- Android: [#2111](https://github.com/react-community/react-native-maps/pull/2111) Allow vector drawables to be used as markers
- Android: [#2132](https://github.com/react-community/react-native-maps/pull/2132) Add mock-provider boolean on each location update
- Android: [#2047](https://github.com/react-community/react-native-maps/pull/2047) Check for presence of project-wide (ext) Gradle configuration properties `compileSdkVersion`, `targetSdkVersion`, `buildToolsVersion`, `supportLibVersion`, `googlePlayServicesVersion`, and `androidMapsUtilsVersion`. This provides a better mechanism for aligning the requirements of the module with that of the host project.
- Android: [#2096](https://github.com/react-community/react-native-maps/pull/2096) Updated gradle configuration for gradle 3.0.0+

## 0.20.1 (February 13, 2018)

- Common: [hotfix PROVIDER_GOOGLE](https://github.com/react-community/react-native-maps/commit/cd868ea7b33a04c8bdd5e909cf134a133b2cb316)
- iOS: [#2019](https://github.com/airbnb/react-native-maps/pull/2019) Exposing the maximumZ property to AIRMapUrlTile

## 0.20.0 (February 9, 2018)

- Common: [#1889](https://github.com/airbnb/react-native-maps/pull/1889) Fix for 'Animated.Region undefined constructor' in recent react-native version.
- iOS: [#1853](https://github.com/airbnb/react-native-maps/pull/1853) Fixed onMapReady no longer getting called on iOS
- Android: [#1906](https://github.com/airbnb/react-native-maps/pull/1906) Manage Zoom Controls visibility on the map
- iOS: [#1911](https://github.com/airbnb/react-native-maps/pull/1911) Add gradient/multi-color polyline support for iOS (MapKit)
- Android: [#1918](https://github.com/airbnb/react-native-maps/pull/1918) Ground Overlay Support
- Common: [#1851](https://github.com/airbnb/react-native-maps/pull/1851) New methods to convert between LatLng and Point
- iOS: [#1846](https://github.com/airbnb/react-native-maps/pull/1846) Fix callouts appearing behind markers
- iOS: [#1969](https://github.com/airbnb/react-native-maps/pull/1969) Added tracksInfoWindowChanges property to iOS Google Maps
- iOS: [#1960](https://github.com/airbnb/react-native-maps/pull/1960) Fixed gradient polyline not always fully drawn + stability issues
- iOS: [#1953](https://github.com/airbnb/react-native-maps/pull/1953) Fix onMapReady not getting called after first time, initialRegion lat/lng delta not setting properly, setRegion method getting called even when map is not ready and prevent onRegionChange/ onRegionChangeComplete event until initialRegion or region is set.
- Android: [#1781](https://github.com/airbnb/react-native-maps/pull/1781) Polygon holes support
- Android: [#1976](https://github.com/airbnb/react-native-maps/pull/1976) Add native animation for Markers on Android

## 0.19.0 (December 14, 2017)

- Common: [#1715](https://github.com/airbnb/react-native-maps/pull/1715) Fixed region/initialRegion null overrides of this.props
- Common: [#1876](https://github.com/airbnb/react-native-maps/pull/1876) Added support for locally stored tile overlay
- iOS: [#1854](https://github.com/airbnb/react-native-maps/pull/1854) Update GoogleMaps dependency to 2.5.0

## 0.18.3 (November 30, 2017)

- Android: [#1839](https://github.com/airbnb/react-native-maps/pull/1839) [AirGoogleMapManager] Use RCTDirectEventBlock for onMarkerPress

## 0.18.2 (November 29, 2017)

- Android: [#1835](https://github.com/airbnb/react-native-maps/pull/1835) [AirMapView] Null check map instance on view methods

## 0.18.1 (November 28, 2017)

- Android: [#1828](https://github.com/airbnb/react-native-maps/pull/1828) [AirMapManager] Update MapBuilder for getCommandsMap to support all entires

## 0.18.0 (November 28, 2017)

- Android/iOS: [#1587](https://github.com/airbnb/react-native-maps/pull/1750) Add support to set map boundaries
- Android/iOS: [#1750](https://github.com/airbnb/react-native-maps/pull/1750) Add mapPadding property
- Common: [#1792](https://github.com/airbnb/react-native-maps/pull/1792) Make all components use ViewPropTypes || View.propTypes
- iOS: [#1774](https://github.com/airbnb/react-native-maps/pull/1774) Added missing parameters to google map screenshot
- iOS: [#1824](https://github.com/airbnb/react-native-maps/pull/1824) Add new iOS `mutedStandard` map-type
- iOS: [#1705](https://github.com/airbnb/react-native-maps/pull/1705) Enable control of Google Maps Marker tracksViewChanges property.
- Android: [#1710](https://github.com/airbnb/react-native-maps/pull/1710) Added support for new Android camera movement APIs
- iOS: [#1741](https://github.com/airbnb/react-native-maps/pull/1741) Fixed iOS google MapView.onMarkerPress not receiving the marker identifier
- iOS: [#1816](https://github.com/airbnb/react-native-maps/pull/1816) Fix The name of the given podspec yoga' doesn't match the expected one Yoga'
- iOS: [#1797](https://github.com/airbnb/react-native-maps/pull/1797) Fixed onMapReady event on iOS to resemble onMapReady on Android
- Common: [#1817](https://github.com/airbnb/react-native-maps/pull/1817) Allow fitToCoordinates to be called without options parameter

## 0.17.1 (October 18, 2017)

- Common: [#1687](https://github.com/airbnb/react-native-maps/pull/1687) Fixed TypeScript definitions

## 0.17.0 (October 11, 2017)

- iOS: [#1527](https://github.com/airbnb/react-native-maps/pull/1527) Added [iOS / Google Maps] support for showsIndoorLevelPicker
- iOS/Android: [#1544](https://github.com/airbnb/react-native-maps/pull/1544) Adds support to animateToBearing and animateToViewingAngle ( IOS + Android )
- JS: [#1503](https://github.com/airbnb/react-native-maps/pull/1503) Remove caret from "react": "^16.0.0-alpha.12
- Android: [#1521](https://github.com/airbnb/react-native-maps/pull/1521) Fix rare android crashes when map size is 0
- Common: [#1601](https://github.com/airbnb/react-native-maps/pull/1610) Added Typescript Definitions
- Android: [#1612](https://github.com/airbnb/react-native-maps/pull/1612) Remove legalNotice from android AirMapModule

## 0.16.4 (September 13, 2017)

- Android: [#1643](https://github.com/airbnb/react-native-maps/pull/1643) [MapMarker] fix android release crash on custom marker

## 0.16.3 (September 2, 2017)

- iOS: [#1603](https://github.com/airbnb/react-native-maps/pull/1603) Added missing satellite option for iOS Google Maps
- iOS: [#1579](https://github.com/airbnb/react-native-maps/pull/1579) Set initial region on view

## 0.16.2 (August 17, 2017)

- Android: [#1563](https://github.com/airbnb/react-native-maps/pull/#1563) Add missing native method for setting initial region
- iOS: [#1187](https://github.com/airbnb/react-native-maps/pull/1187) Reverted due to build issues

## 0.16.1 (August 15, 2017)

- Android: [#1428](https://github.com/airbnb/react-native-maps/pull/#1428) Add ability to load marker image from drawable
- iOS: [#1187](https://github.com/airbnb/react-native-maps/pull/1187) Improve marker performance
- iOS/Android: [#1458](https://github.com/airbnb/react-native-maps/pull/1458) Add Google Maps legalNotice constant
- JS: [#1546](https://github.com/airbnb/react-native-maps/pull/1546) Fix initial region native prop

## 0.16.0 (August 9, 2017)

- Android: [#1481](https://github.com/airbnb/react-native-maps/pull/1481) Handle Android RN 0.47 breaking change
- iOS: [#1357](https://github.com/airbnb/react-native-maps/pull/1357) add MKTileOverlayRenderer
- iOS: [#1369](https://github.com/airbnb/react-native-maps/pull/1369) Add onMapReady callback
- Android/iOS/JS: [#1360](https://github.com/airbnb/react-native-maps/pull/1360) Add minZoom and maxZoom properties for android and ios
- JS: [#1479](https://github.com/airbnb/react-native-maps/pull/1479) Fix timing function used in AnimatedRegion.spring

## 0.15.3 (June 27, 2017)

- iOS: [#1362](https://github.com/airbnb/react-native-maps/pull/1362) Updates for React 0.43-0.45 and React 16.
- JS: [#1323](https://github.com/airbnb/react-native-maps/pull/1323) Updates for React 0.43-0.45 and React 16.
- Android/iOS/JS: [#1440](https://github.com/airbnb/react-native-maps/pull/1440) Updates for React 0.43-0.45 and React 16.
- iOS: [#1115](https://github.com/airbnb/react-native-maps/pull/1115) Fix animateToCoordinate and animateToRegion
- Android: [#1403](https://github.com/airbnb/react-native-maps/pull/1403) Fix an NPE

## 0.15.2 (May 20, 2017)

- iOS: [#1351](https://github.com/airbnb/react-native-maps/pull/1351) Fix file references

## 0.15.1 (May 19, 2017)

- iOS: [#1341](https://github.com/airbnb/react-native-maps/pull/1341) Fix compile error in rn version >= 0.40
- iOS: [#1194](https://github.com/airbnb/react-native-maps/pull/1194) Add onPress support for Google Maps Polyline
- iOS: [#1326](https://github.com/airbnb/react-native-maps/pull/1326) Add Marker rotation for Google Maps on iOS
- Android: [#1311](https://github.com/airbnb/react-native-maps/pull/1311) Fix overlay issue
- Common [#1313](https://github.com/airbnb/react-native-maps/pull/1313) Fix Android sourceDir for react-native-link

## 0.15.0 (May 8, 2017)

- iOS: [#1195](https://github.com/airbnb/react-native-maps/pull/1195) Rename project file to fix iOS build error
- Android: Update Google Play Services to version `10.2.4`

## 0.14.0 (April 4, 2017)

## Enhancements

- Restructure project #1164

- Add showsIndoorLevelPicker -> setIndoorLevelPickerEnabled to MapView #1019
  [#1188](https://github.com/airbnb/react-native-maps/pull/1188)

- iOS - Added onPress support for Polygons on Google Maps
  [#1024](https://github.com/airbnb/react-native-maps/pull/1024)

- Add customized user location annotation text
  [#1049](https://github.com/airbnb/react-native-maps/pull/1049)

- iOS - Google Maps - Add `showsMyLocationButton` support
  [#1157](https://github.com/airbnb/react-native-maps/pull/1157)

## Patches

- Fix getResources() null crash in mapview
  [#1188](https://github.com/airbnb/react-native-maps/pull/1188)

- Rename MapKit category to avoid conflicts with the one in RN
  [#1172](https://github.com/airbnb/react-native-maps/pull/1172)

- Upgrade GMS dependencies to 10.2.0
  [#1169](https://github.com/airbnb/react-native-maps/pull/1169)

- fix multiple-instance memory leak
  [#1130](https://github.com/airbnb/react-native-maps/pull/1130)

- fix onSelected event for markers with custom view
  [#1079](https://github.com/airbnb/react-native-maps/pull/1079)

- Crash in our App fix
  [#1096](https://github.com/airbnb/react-native-maps/pull/1096)

- Use local RCTConvert+MapKit instead of the one in React Native
  [#1138](https://github.com/airbnb/react-native-maps/pull/1138)

## 0.13.1 (March 21, 2017)

## Enhancements

- Add id identifier to marker-press event on Android
  [#1008](https://github.com/airbnb/react-native-maps/pull/1008)
  (@stan229)

- setNativeProps, marker opacity, nested components
  [#940](https://github.com/airbnb/react-native-maps/pull/940)
  (@unboundfire)

## Patches

- Update the android buildToolsVersion to 25.0.0
  [#1152](https://github.com/airbnb/react-native-maps/pull/1152)
  (@markusguenther)

- use `provided` for RN gradle dependency
  [#1151](https://github.com/airbnb/react-native-maps/pull/1151)
  (@gpeal)

- fix null activity crash
  [#1150](https://github.com/airbnb/react-native-maps/pull/1150)
  (@lelandrichardson)

- Updated Google play services and gradle build plugin
  [#1023](https://github.com/airbnb/react-native-maps/pull/1023)
  (@chris-at-translate)

- Sets the map value for the AirMapUrlTile so that it can be updated properly
  [#992](https://github.com/airbnb/react-native-maps/pull/992)
  (@jschloer)

- onPress and onCalloutPress doesn't trigger on markers in iOS
  [#954](https://github.com/airbnb/react-native-maps/pull/954)
  (@RajkumarPunchh)

## 0.13.0 (January 6, 2017)

### Breaking Changes

- Update iOS header imports and JS SyntheticEvent import for RN 0.40
  [#923](https://github.com/airbnb/react-native-maps/pull/923)
  (@ide)

### Patches

- Fix issue where callouts sometimes overlap or don't appear
  [#936](https://github.com/airbnb/react-native-maps/pull/936)
  (@RajkumarPunchh)

## 0.12.3 (January 6, 2017)

### Patches

- Fix "Animating with MapViews" example  fixes #763
  [#888](https://github.com/airbnb/react-native-maps/pull/888)
  (@javiercr)
- [iOS] Fix "Option 2" method of building Google Maps
  [#900](https://github.com/airbnb/react-native-maps/pull/900)
  (@vjeranc)
- [Android] Fix exception when animating region during initialization
  [#901](https://github.com/airbnb/react-native-maps/pull/901)
  (@mlanter)
- Updated documentation
  [#902](https://github.com/airbnb/react-native-maps/pull/902),
  [#904](https://github.com/airbnb/react-native-maps/pull/904),
  [#910](https://github.com/airbnb/react-native-maps/pull/910)
  (@anami, @dboydor, @ali-alamine)

## 0.12.2 (December 9, 2016)

### Patches

- [Android] Added support for taking snapshots on Android
  [#625](https://github.com/airbnb/react-native-maps/pull/625)
  (@IjzerenHein)
- [iOS] Allow legalLabelInsets to be changed and animated
  [#873](https://github.com/airbnb/react-native-maps/pull/873)
  (@scarlac)
- Added rotation attribute documentation
  [#871](https://github.com/airbnb/react-native-maps/pull/871)
  (@Arman92)
- Update mapview.md documentation
  [#866](https://github.com/airbnb/react-native-maps/pull/866)
  (@dccarmo)

## 0.12.1 (December 6, 2016)

This release only corrects the version in package.json.

## 0.12.0 (December 6, 2016)

NOTE: This version was not published because package.json was not properly updated

### Breaking Changes

- [android] If we've disabled scrolling within the map, then don't capture the touch events
  [#664](https://github.com/airbnb/react-native-maps/pull/664)
  (@mikelambert)
- [android] Use latest Google Play Services
  [#731](https://github.com/airbnb/react-native-maps/pull/731)
  (@mlanter)
- [android] update google play services
  [#805](https://github.com/airbnb/react-native-maps/pull/805)
  (@lrivera)

### Patches

- [iOS] Support iOS SDK < 10 ( XCode < 8 )
  [#708](https://github.com/airbnb/react-native-maps/pull/708)
  (@rops)
- [iOS] Added showsUserLocation property support for Google Maps
  [#721](https://github.com/airbnb/react-native-maps/pull/721)
  (@julien-rodrigues)
- [iOS] Added Google Maps Circle, Polygon, Polyline, MapType Support
  [#722](https://github.com/airbnb/react-native-maps/pull/722)
  (@unboundfire)
- [iOS] Fix Anchor point on Google Maps iOS
  [#734](https://github.com/airbnb/react-native-maps/pull/734)
  (@btoueg)
- [Google Maps iOS] Marker init with image props.
  [#738](https://github.com/airbnb/react-native-maps/pull/738)
  (@btoueg)
- [iOS] Fix dynamic imageSrc removal
  [#737](https://github.com/airbnb/react-native-maps/pull/737)
  (@btoueg)
- [iOS] implement fitToSuppliedMarkers and fitToCoordinates for google
  [#750](https://github.com/airbnb/react-native-maps/pull/750)
  (@gilbox)
- [iOS][android] Add onPress for polygons and polylines on iOS and Android
  [#760](https://github.com/airbnb/react-native-maps/pull/760)
  (@frankrowe)
- [iOS] Fix flicker of map pins on state change
  [#728](https://github.com/airbnb/react-native-maps/pull/728)
  (@mlanter)
- [iOS] Set region only when view has width&height
  [#785](https://github.com/airbnb/react-native-maps/pull/785)
  (@gilbox)
- [iOS] Implements animateToRegion for Google
  [#779](https://github.com/airbnb/react-native-maps/pull/779)
  (@btoueg)
- [iOS] Google Maps Custom Tile Support
  [#770](https://github.com/airbnb/react-native-maps/pull/770)
  (@unboundfire)
- [android] Map Styling for android
  [#808](https://github.com/airbnb/react-native-maps/pull/808)
  (@ali-alamine using @azt3k code)
- [iOS] IOS Google Map styling
  [#817](https://github.com/airbnb/react-native-maps/pull/817)
  (@ali-alamine using @azt3k code)
- [iOS] Add support for polygon holes for Apple Maps and Google Maps on iOS
  [#801](https://github.com/airbnb/react-native-maps/pull/801)
  (@therealgilles)
- [iOS] Fixes #470. Support legalLabelInsets on Apple Maps
  [#840](https://github.com/airbnb/react-native-maps/pull/840)
  (@scarlac)

## 0.11.0 (October 16, 2016)

NOTE: `0.10.4` was released _after_ this version, and it's possible
`0.11.0` does not include everything in `0.10.4`. (see #851)

### Breaking Changes

- Update example app for RN 0.35, fix Gmaps bug for 0.35
  [#695](https://github.com/airbnb/react-native-maps/pull/695)
  (@spikebrehm)
- Upgraded to RN 0.35
  [#680](https://github.com/airbnb/react-native-maps/pull/680)
  (@eugenehp)

### Patches

- Update installation.md
  [#696](https://github.com/airbnb/react-native-maps/pull/696)
  (@securingsincity)
- [android] Fixes crash during Activity onPause()
  [#694](https://github.com/airbnb/react-native-maps/pull/694)
  (@felipecsl)
- Included MapUrlTile usage in README.md
  [#687](https://github.com/airbnb/react-native-maps/pull/687)
  (@ochanje210)
- [android] Add parameter to disable the moving on marker press
  [#676](https://github.com/airbnb/react-native-maps/pull/676)
  (@mlanter)
- Add support for setting zIndex on markers
  [#675](https://github.com/airbnb/react-native-maps/pull/675)
  (@mlanter)

## 0.10.4 (October 31, 2016)

### Patches

- [iOS] implement fitToSuppliedMarkers and fitToCoordinates for google maps
  [#750](https://github.com/airbnb/react-native-maps/pull/750)
  (@gilbox)
- [android] If we've disabled scrolling within the map, then don't capture the touch events
  [#664](https://github.com/airbnb/react-native-maps/pull/664)
  (@mikelambert)
- [iOS] Fix Anchor point on Google Maps iOS
  [#734](https://github.com/airbnb/react-native-maps/pull/734)
  (@btoueg)
- [iOS] Added showsUserLocation property support for Google Maps
  [#721](https://github.com/airbnb/react-native-maps/pull/721)
  (@julien-rodrigues)
- [iOS][android] Add support for setting zIndex on markers
  [#675](https://github.com/airbnb/react-native-maps/pull/675)
  (@mlanter)
- [android] Add parameter to disable the moving on marker press
  [#676](https://github.com/airbnb/react-native-maps/pull/676)
  (@mlanter)
- NOTE: v0.10.3 was not published

## 0.10.2 (October 19, 2016)

### Patches

- [android] Fixes crash during Activity onPause() (fixes #414)
  [#694](https://github.com/airbnb/react-native-maps/pull/694)
  (@felipecsl)

## 0.10.1 (October 10, 2016)

This release fixes issue [#656](https://github.com/airbnb/react-native-maps/issues/656)

### Patches

- [android] fix gradle build setup for explorer, bump to gradle 2.2.0
  [#666](https://github.com/airbnb/react-native-maps/pull/666)
  (@gilbox)
- [android] fix getAirMapName to fix ref-based commands
  [#665](https://github.com/airbnb/react-native-maps/pull/665)
  (@gilbox)

## 0.10.0 (October 5, 2016)

### Breaking Changes

- Upgrade to `react-native@0.33.0`

## 0.9.0 (September 28, 2016)

As of this release, this repository has moved from
`lelandrichardson/react-native-maps` to `airbnb/react-native-maps`.

### Breaking Changes

- [iOS] Support Google Maps on iOS
  [#548](https://github.com/airbnb/react-native-maps/pull/548)
  (@gilbox)

### Patches

- Added support for AnimatedRegion without modifying the AnimatedImplementation.js of react-native
  [#608](https://github.com/airbnb/react-native-maps/pull/608)
  (@IjzerenHein)
- [iOS] Remove pod stuff. Fix AirMaps.xcodeproj related to missing pod stuff
  [#620](https://github.com/airbnb/react-native-maps/pull/620)
  (@gilbox)
- [iOS] Fix import of AIRMapSnapshot
  [#622](https://github.com/airbnb/react-native-maps/pull/622)
  (@spikebrehm)
- [iOS] Fix nullability issue
  [#614](https://github.com/airbnb/react-native-maps/pull/614)
  (@simonmitchell)
- [iOS] Added support for drawing polylines on snapshots on iOS
  [#615](https://github.com/airbnb/react-native-maps/pull/615)
  (@IjzerenHein)
- Add `fitToCoordinates` method
  [#545](https://github.com/airbnb/react-native-maps/pull/545)
  (@naoufal)
- [Android] Fix list of examples on Android
  [#597](https://github.com/airbnb/react-native-maps/pull/597)
  (@spikebrehm)
- [Android] Fix overlapping map issue
  [#589](https://github.com/airbnb/react-native-maps/pull/589)
  (@fdnhkj)
- Add tile overlay support
  [#595](https://github.com/airbnb/react-native-maps/pull/595)
  (@cascadian, @spikebrehm)
- [Android] Support Android LiteMode
  [#546](https://github.com/airbnb/react-native-maps/pull/546)
  (@rops)
- s/lelandrichardson/airbnb/
  [#573](https://github.com/airbnb/react-native-maps/pull/573)
  (@spikebrehm)
- [Android] Don't fit to elements if no positions added
  [#567](https://github.com/airbnb/react-native-maps/pull/567)
  (@ryankask)
- [iOS] Add class prefix to EmptyCalloutBackgroundView
  [#563](https://github.com/airbnb/react-native-maps/pull/563)
  (@terribleben)
- [Android] Minor code cleanup
  [#564](https://github.com/airbnb/react-native-maps/pull/564)
  (@felipecsl)
- Documentation updates
  [#566](https://github.com/airbnb/react-native-maps/pull/566),
  [#591](https://github.com/airbnb/react-native-maps/pull/591),
  [#601](https://github.com/airbnb/react-native-maps/pull/601),
  [#602](https://github.com/airbnb/react-native-maps/pull/602),
  [#624](https://github.com/airbnb/react-native-maps/pull/624)
  (@felipecsl, @Alastairm, @Keksike, @bbodenmiller)

## 0.8.2 (September 8, 2016)

We realized immediately after publishing 0.8.1 that the NPM package contained
some test code in the `example2/` directory that contained a copy of the
`react-native` package, causing this packager error:

```
Failed to build DependencyGraph: @providesModule naming collision:
  Duplicate module name: String.prototype.es6
  Paths: /Users/<path to project>/node_modules/react-native-maps/example2/node_modules/react-native/packager/react-packager/src/Resolver/polyfills/String.prototype.es6.js collides with /Users/<path to project>/node_modules/react-native/packager/react-packager/src/Resolver/polyfills/String.prototype.es6.js

This error is caused by a @providesModule declaration with the same name across two different files.
```

0.8.2 is identical to 0.8.1, except with the offending code removed from the NPM package.

## 0.8.1 (September 8, 2016) _[DEPRECATED]_

#### _NOTE: 0.8.1 has been unpublished from NPM because it was faulty. Please use 0.8.2._

### Patches

- [Android] Use latest available (wildcard version) of RN to build Android ([PR #547](https://github.com/airbnb/react-native-maps/pull/547))
- [Android] Use `Activity` to call `MapsInitialier.initialize()` ([PR #449](https://github.com/airbnb/react-native-maps/pull/449))
- [Android] Fix file path for `AirMapModule` ([PR #526](https://github.com/airbnb/react-native-maps/pull/526))
- [Android] Fix path to React Native in `node_modules` ([PR #527](https://github.com/airbnb/react-native-maps/pull/527))
- [Android] Bump Google Play Services dependency to `9.4.0` ([PR #533](https://github.com/airbnb/react-native-maps/pull/533))
- [iOS] Fix a few warnings ([PR #534](https://github.com/airbnb/react-native-maps/pull/534))
- [JS] Fix ESLint violations ([PR #515](https://github.com/airbnb/react-native-maps/pull/515))

## 0.8.0 (August 30, 2016)

### Breaking Changes

- Upgrade to `react-native@0.32.0`, and update Android code to match ([#502](https://github.com/airbnb/react-native-maps/pull/502))

### Patches

- [android] Add `showsMyLocationButton` prop ([#382](https://github.com/airbnb/react-native-maps/pull/382))

- Add `fitToSuppliedMarkers()` method ([#386](https://github.com/airbnb/react-native-maps/pull/386))

- [ios] Update AirMapMarker to use loadImageWithURLRequest ([#389](https://github.com/airbnb/react-native-maps/pull/389))

- Improvements to watch and copy script ([#445](https://github.com/airbnb/react-native-maps/pull/445))

- [ios] Added check on marker class in predicate ([#485](https://github.com/airbnb/react-native-maps/pull/485))

- Use `StyleSheet.absoluteFillObject` where appropriate ([#500](https://github.com/airbnb/react-native-maps/pull/500)) and ([#493](https://github.com/airbnb/react-native-maps/pull/493))

- Add ESLint and fix a number of linting violations ([#501](https://github.com/airbnb/react-native-maps/pull/501))

- Remove unused `NativeMethodsMixin` for compat with RN 0.32 ([#511](https://github.com/airbnb/react-native-maps/pull/511))

## 0.7.1 (July 9, 2016)

### Patches

- Fix iOS CocoaPods Issue ([#308](https://github.com/airbnb/react-native-maps/pull/308))

## 0.7.0 (July 9, 2016)

### Breaking Changes

- RN 0.29 compatibility changes ([#363](https://github.com/airbnb/react-native-maps/pull/363) and [#370](https://github.com/airbnb/react-native-maps/pull/370))

### Patches

- Fixing scrolling map inside a scrollView ([#343](https://github.com/airbnb/react-native-maps/pull/343))

- Fix shouldUsePinView ([#344](https://github.com/airbnb/react-native-maps/pull/344))

- Not calling setLoadingIndicatorColor when null ([#337](https://github.com/airbnb/react-native-maps/pull/337))

- Fixes `Undefined symbols for architecture x86_64: std::terminate()` ([#329](https://github.com/airbnb/react-native-maps/pull/329))

## 0.6.0

## 0.5.0

- [Android] Updated package to `com.airbnb.android.react.maps` (PR #225)
- [Android] Lint fixes (PR #232)

## 0.4.0

- Initial release
  </file>

<file path="commitlint.config.js">
module.exports = {extends: ['@commitlint/config-conventional']};
</file>

<file path="CONTRIBUTING.md">
# Contributing

Thank you for helping this project become a better library :)

- [Triage](#triage)
- [Reporting Bugs](#reporting-bugs)
- [Providing a feature request](#providing-a-feature-request)
- [Pull requests](#pull-requests)

## Triage

This is one of the easiest and most effective ways of helping out. If you see an open issue, try and reproduce the bug yourself, and comment with the result. If the issue is lacking any information to reproduce the bug, let the author know.

## Reporting Bugs

Open an issue, making sure to follow the bug report template.

## Providing a feature request

Open an issue, making sure to follow the Feature request template.

## Pull requests

### Getting started

- If there isn't one already, open an issue describing the bug or feature request that you are going to solve in your pull request.
- Create a fork of react-native-maps
  - If you already have a fork, make sure it is up to date
- Git clone your fork and run `yarn` in the base of the cloned repo to setup your local development environment.
- Create a branch from the master branch to start working on your changes.

### Committing

- When you made your changes, run `yarn lint` & `yarn test` to make sure the code you introduced doesn't cause any obvious issues.
- When you are ready to commit your changes, use the [Angular conventional commits](https://www.conventionalcommits.org/en/v1.0.0-beta.4/#summary) convention for you commit messages, as we use your commits when releasing new versions.
- Use present tense: "add awesome component" not "added awesome component"
- Limit the first line of the commit message to 100 characters
- Reference issues and pull requests before committing

### Creating the pull request

- The title of the PR needs to follow the same conventions as your commit messages, as it might be used in case of a squash merge.
- Create the pull request against the beta branch.
  </file>

<file path="LICENSE">
The MIT License (MIT)

Copyright (c) 2015 Airbnb

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "react-native-maps",
  "description": "React Native Mapview component for iOS + Android",
  "source": "src/index",
  "main": "lib/index.js",
  "author": "Leland Richardson <leland.m.richardson@gmail.com>",
  "homepage": "https://github.com/react-native-maps/react-native-maps#readme",
  "version": "0.0.0",
  "license": "MIT",
  "scripts": {
    "lint": "eslint . --max-warnings 0",
    "tscheck": "tsc --noEmit",
    "format-check": "prettier --check .",
    "build": "tsc --project tsconfig.build.json",
    "test": "jest",
    "prepare": "husky install",
    "release": "semantic-release",
    "bundle-install": "cd example && bundle install",
    "pod-install": "cd example/ios && bundle exec pod install",
    "bootstrap": "yarn --cwd example && yarn && yarn bundle-install && yarn pod-install"
  },
  "files": [
    "lib",
    "android",
    "ios",
    "react-native-google-maps.podspec",
    "react-native-maps.podspec",
    "!android/build",
    "!ios/build",
    "!**/__tests__",
    "!**/__fixtures__",
    "!**/__mocks__"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/react-native-maps/react-native-maps"
  },
  "keywords": [
    "react",
    "react-native",
    "react-component",
    "map",
    "mapview",
    "google-maps",
    "mapkit"
  ],
  "peerDependencies": {
    "react": ">= 17.0.1",
    "react-native": ">= 0.64.3",
    "react-native-web": ">= 0.11"
  },
  "peerDependenciesMeta": {
    "react-native-web": {
      "optional": true
    }
  },
  "devDependencies": {
    "@commitlint/cli": "17.6.1",
    "@commitlint/config-conventional": "17.6.1",
    "@semantic-release/changelog": "6.0.3",
    "@semantic-release/git": "10.0.1",
    "semantic-release": "24.2.0",
    "husky": "8.0.3",
    "@types/react-native": "0.72.8",
    "@babel/core": "^7.25.2",
    "@babel/preset-env": "^7.25.3",
    "@babel/runtime": "^7.25.0",
    "react-native": "^0.76.1",
    "react": "^18.3.1",
    "@react-native/babel-preset": "0.76.1",
    "@react-native/eslint-config": "0.76.1",
    "@react-native/metro-config": "0.76.1",
    "@react-native/typescript-config": "0.76.1",
    "@types/react": "^18.2.6",
    "@types/react-test-renderer": "^18.0.0",
    "babel-jest": "^29.6.3",
    "eslint": "^8.19.0",
    "@types/jest": "29.5.1",
    "jest": "^29.6.3",
    "prettier": "2.8.8",
    "react-test-renderer": "18.3.1",
    "typescript": "5.0.4"
  },
  "dependencies": {
    "@types/geojson": "^7946.0.13"
  },
  "jest": {
    "preset": "react-native",
    "testPathIgnorePatterns": [
      "/node_modules/",
      "e2e"
    ]
  },
  "engines": {
    "node": ">=18"
  }
}
</file>

<file path="react-native-google-maps.podspec">
require 'json'

package = JSON.parse(File.read(File.join(**dir**, 'package.json')))

Pod::Spec.new do |s|
s.name = "react-native-google-maps"
s.version = package['version']
s.summary = package["description"]
s.authors = package["author"]
s.homepage = package["homepage"]
s.license = package["license"]
s.platform = :ios, "14"

s.source = { :git => "https://github.com/react-native-maps/react-native-maps.git", :tag=> "v#{s.version}" }
s.source_files = "ios/AirGoogleMaps/\*_/_.{h,m}"
s.resource_bundles = {
'GoogleMapsPrivacy' => ['ios/AirGoogleMaps/Resources/GoogleMapsPrivacy.bundle']
}
s.compiler_flags = '-DHAVE_GOOGLE_MAPS=1', '-DHAVE_GOOGLE_MAPS_UTILS=1'
s.pod_target_xcconfig = { 'FRAMEWORK_SEARCH_PATHS' => '"${PODS_CONFIGURATION_BUILD_DIR}/react-native-maps"' }

s.dependency 'React-Core'
s.dependency 'GoogleMaps', '8.4.0'
s.dependency 'Google-Maps-iOS-Utils', '5.0.0'
end
</file>

<file path="react-native-maps.podspec">
require 'json'

package = JSON.parse(File.read(File.join(**dir**, 'package.json')))

Pod::Spec.new do |s|
s.name = "react-native-maps"
s.version = package['version']
s.summary = package["description"]
s.authors = package["author"]
s.homepage = package["homepage"]
s.license = package["license"]
s.platform = :ios, "11.0"

s.source = { :git => "https://github.com/react-native-maps/react-native-maps.git", :tag=> "v#{s.version}" }
s.source_files = "ios/AirMaps/\*_/_.{h,m}"
s.resource_bundles = {
'ReactNativeMapsPrivacy' => ['ios/PrivacyInfo.xcprivacy']
}
s.dependency 'React-Core'
end
</file>

<file path="README.md">
# react-native-maps [![npm version](https://img.shields.io/npm/v/react-native-maps.svg?style=flat)](https://www.npmjs.com/package/react-native-maps)

React Native Map components for iOS + Android

## Contributing

This project is being maintained by a small group of people, and any help with issues and pull requests are always appreciated. If you are able and willing to contribute, please read the [guidelines](./CONTRIBUTING.md).

## Installation

See [Installation Instructions](docs/installation.md).

See [Setup Instructions for the Included Example Project](docs/examples-setup.md).

## Compatibility

## React Native Compatibility

### Important Notes:

- **Fabric is not yet supported**:  
  This feature is currently under development. Fabric is enabled by default in React Native `0.76` and above, so **please disable it** for now.  
  Follow updates on this issue here: [react-native-maps/issues/5206](https://github.com/react-native-maps/react-native-maps/issues/5206).  
  Kindly refrain from opening duplicate tickets regarding this matter.

### Version Requirements:

- **Version `1.14.0` and above**: Requires **React Native `>= 0.74`**.
- **Versions below `1.14.0`**: Require **React Native `>= 0.64.3`**.

## Component API

[`<MapView />` Component API](docs/mapview.md)

[`<Marker />` Component API](docs/marker.md)

[`<Callout />` Component API](docs/callout.md)

[`<Polygon />` Component API](docs/polygon.md)

[`<Polyline />` Component API](docs/polyline.md)

[`<Circle />` Component API](docs/circle.md)

[`<Overlay />` Component API](docs/overlay.md)

[`<Heatmap />` Component API](docs/heatmap.md)

[`<Geojson />` Component API](docs/geojson.md)

## General Usage

```js
import MapView from "react-native-maps";
```

or

```js
var MapView = require("react-native-maps");
```

This MapView component is built so that features on the map (such as Markers, Polygons, etc.) are
specified as children of the MapView itself. This provides an intuitive and react-like API for
declaratively controlling features on the map.

### Rendering a Map with an initial region

## MapView

```jsx
<MapView
  initialRegion={{
    latitude: 37.78825,
    longitude: -122.4324,
    latitudeDelta: 0.0922,
    longitudeDelta: 0.0421,
  }}
/>
```

### Using a MapView while controlling the region as state

```jsx
getInitialState() {
  return {
    region: {
      latitude: 37.78825,
      longitude: -122.4324,
      latitudeDelta: 0.0922,
      longitudeDelta: 0.0421,
    },
  };
}

onRegionChange(region) {
  this.setState({ region });
}

render() {
  return (
    <MapView
      region={this.state.region}
      onRegionChange={this.onRegionChange}
    />
  );
}
```

### Rendering a list of markers on a map

```jsx
import { Marker } from "react-native-maps";

<MapView region={this.state.region} onRegionChange={this.onRegionChange}>
  {this.state.markers.map((marker, index) => (
    <Marker
      key={index}
      coordinate={marker.latlng}
      title={marker.title}
      description={marker.description}
    />
  ))}
</MapView>;
```

### Rendering a Marker with a custom image

1. You need to generate an `png` image with various resolution (lets call them `custom_pin`) - for more information go to [Android](https://developer.android.com/studio/write/resource-manager#import), [iOS](https://developer.apple.com/documentation/xcode/adding-images-to-your-xcode-project)
2. put all images in Android drawables and iOS assets dir
3. Now you can use the following code:

```jsx
<Marker
  coordinate={{ latitude: latitude, longitude: longitude }}
  image={{ uri: "custom_pin" }}
/>
```

Note: You can also pass the image binary data like `image={require('custom_pin.png')}`, but this will not scale good with the different screen sizes.

### Rendering a Marker with a custom view

Note: This has performance implications, if you wish for a simpler solution go with a custom image (save your self the headache)

```jsx
<Marker coordinate={{ latitude: latitude, longitude: longitude }}>
  <MyCustomMarkerView {...marker} />
</Marker>
```

### Rendering a custom Marker with a custom Callout

```jsx
import { Callout } from "react-native-maps";

<Marker coordinate={marker.latlng}>
  <MyCustomMarkerView {...marker} />
  <Callout>
    <MyCustomCalloutView {...marker} />
  </Callout>
</Marker>;
```

### Draggable Markers

```jsx
<MapView initialRegion={...}>
  <Marker draggable
    coordinate={this.state.x}
    onDragEnd={(e) => this.setState({ x: e.nativeEvent.coordinate })}
  />
</MapView>
```

### Using a custom Tile Overlay

#### Tile Overlay using tile server

```jsx
import { UrlTile } from "react-native-maps";

<MapView region={this.state.region} onRegionChange={this.onRegionChange}>
  <UrlTile
    /**
     * The url template of the tile server. The patterns {x} {y} {z} will be replaced at runtime
     * For example, http://c.tile.openstreetmap.org/{z}/{x}/{y}.png
     */
    urlTemplate={this.state.urlTemplate}
    /**
     * The maximum zoom level for this tile overlay. Corresponds to the maximumZ setting in
     * MKTileOverlay. iOS only.
     */
    maximumZ={19}
    /**
     * flipY allows tiles with inverted y coordinates (origin at bottom left of map)
     * to be used. Its default value is false.
     */
    flipY={false}
  />
</MapView>;
```

For Android: add the following line in your AndroidManifest.xml

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

For IOS: configure [App Transport Security](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33) in your app

## React Native Configuration for Fabric / New Architecture

This library works with Fabric using the [New Renderer Interop Layer](https://github.com/reactwg/react-native-new-architecture/discussions/135)

There is a warning message that those steps are not necessary; but we couldn't get the example working without them so far.

### Configuration Steps

1. **Open your configuration file**: Locate the `react-native-config` file in your project directory.

2. **Add the following configuration**: Include the `unstable_reactLegacyComponentNames` array for both Android and iOS platforms as shown below:

```javascript
module.exports = {
  project: {
    android: {
      unstable_reactLegacyComponentNames: [
        "AIRMap",
        "AIRMapCallout",
        "AIRMapCalloutSubview",
        "AIRMapCircle",
        "AIRMapHeatmap",
        "AIRMapLocalTile",
        "AIRMapMarker",
        "AIRMapOverlay",
        "AIRMapPolygon",
        "AIRMapPolyline",
        "AIRMapUrlTile",
        "AIRMapWMSTile",
      ],
    },
    ios: {
      unstable_reactLegacyComponentNames: [
        "AIRMap",
        "AIRMapCallout",
        "AIRMapCalloutSubview",
        "AIRMapCircle",
        "AIRMapHeatmap",
        "AIRMapLocalTile",
        "AIRMapMarker",
        "AIRMapOverlay",
        "AIRMapPolygon",
        "AIRMapPolyline",
        "AIRMapUrlTile",
        "AIRMapWMSTile",
      ],
    },
  },
};
```

checkout the example project to see it in action.

#### Tile Overlay using local tiles

Tiles can be stored locally within device using xyz tiling scheme and displayed as tile overlay as well. This is usefull especially for offline map usage when tiles are available for selected map region within device storage.

```jsx
import { LocalTile } from "react-native-maps";

<MapView region={this.state.region} onRegionChange={this.onRegionChange}>
  <LocalTile
    /**
     * The path template of the locally stored tiles. The patterns {x} {y} {z} will be replaced at runtime
     * For example, /storage/emulated/0/mytiles/{z}/{x}/{y}.png
     */
    pathTemplate={this.state.pathTemplate}
    /**
     * The size of provided local tiles (usually 256 or 512).
     */
    tileSize={256}
  />
</MapView>;
```

For Android: LocalTile is still just overlay over original map tiles. It means that if device is online, underlying tiles will be still downloaded. If original tiles download/display is not desirable set mapType to 'none'. For example:

```
<MapView
  mapType={Platform.OS == "android" ? "none" : "standard"}
>
```

See [OSM Wiki](https://wiki.openstreetmap.org/wiki/Category:Tile_downloading) for how to download tiles for offline usage.

### Overlaying other components on the map

Place components that you wish to overlay `MapView` underneath the `MapView` closing tag. Absolutely position these elements.

```jsx
render() {
  return (
    <MapView
      region={this.state.region}
    />
    <OverlayComponent
      style={{position: "absolute", bottom: 50}}
    />
  );
}
```

### Customizing the map style (Google Maps Only)

The `<MapView provider="google" googleMapId="yourStyledMapId" />` Google Maps on iOS and Android supports styling via google cloud platform, the styled maps are published under a googleMapId, by simply setting the property googleMapId to the MapView you can use that styled map
more info here: [google map id](https://developers.google.com/maps/documentation/get-map-id)

### MapView Events

The `<MapView />` component and its child components have several events that you can subscribe to.
This example displays some of them in a log as a demonstration.

![](http://i.giphy.com/3o6UBpncYQASu2WTW8.gif) ![](http://i.giphy.com/xT77YdviLqtjaecRYA.gif)

### Tracking Region / Location

![](http://i.giphy.com/3o6UBoPSLlIKQ2dv7q.gif) ![](http://i.giphy.com/xT77XWjqECvdgjx9oA.gif)

### Programmatically Changing Region

One can change the mapview's position using refs and component methods, or by passing in an updated
`region` prop. The component methods will allow one to animate to a given position like the native
API could.

![](http://i.giphy.com/3o6UB7poyB6YJ0KPWU.gif) ![](http://i.giphy.com/xT77Yc4wK3pzZusEbm.gif)

### Changing the style of the map

![](http://i.imgur.com/a9WqCL6.png)

### Arbitrary React Views as Markers

![](http://i.giphy.com/3o6UBcsCLoLQtksJxe.gif) ![](http://i.giphy.com/3o6UB1qGEM9jYni3KM.gif)

### Using the MapView with the Animated API

The `<MapView />` component can be made to work with the Animated API, having the entire `region` prop
be declared as an animated value. This allows one to animate the zoom and position of the MapView along
with other gestures, giving a nice feel.

Further, Marker views can use the animated API to enhance the effect.

![](http://i.giphy.com/xT77XMw9IwS6QAv0nC.gif) ![](http://i.giphy.com/3o6UBdGQdM1GmVoIdq.gif)

Issue: Since android needs to render its marker views as a bitmap, the animations APIs may not be
compatible with the Marker views. Not sure if this can be worked around yet or not.

Markers' coordinates can also be animated, as shown in this example:

![](http://i.giphy.com/xTcnTelp1OwGPu1Wh2.gif) ![](http://i.giphy.com/xTcnT6WVpwlCiQnFW8.gif)

### Polygon Creator

![](http://i.giphy.com/3o6UAZWqQBkOzs8HE4.gif) ![](http://i.giphy.com/xT77XVBRErNZl3zyWQ.gif)

### Other Overlays

So far, `<Circle />`, `<Polygon />`, and `<Polyline />` are available to pass in as children to the
`<MapView />` component.

![](http://i.giphy.com/xT77XZCH8JpEhzVcNG.gif) ![](http://i.giphy.com/xT77XZyA0aYeOX5jsA.gif)

### Gradient Polylines (iOS MapKit only)

Gradient polylines can be created using the `strokeColors` prop of the `<Polyline>` component.

![](https://i.imgur.com/P7UeqAm.png?1)

### Default Markers

Default markers will be rendered unless a custom marker is specified. One can optionally adjust the
color of the default marker by using the `pinColor` prop.

![](http://i.giphy.com/xT77Y0pWKmUUnguHK0.gif) ![](http://i.giphy.com/3o6UBfk3I58VIwZjVe.gif)

### Custom Callouts

Callouts to markers can be completely arbitrary react views, similar to markers. As a result, they
can be interacted with like any other view.

Additionally, you can fall back to the standard behavior of just having a title/description through
the `<Marker />`'s `title` and `description` props.

Custom callout views can be the entire tooltip bubble, or just the content inside of the system
default bubble.

To handle press on specific subview of callout use `<CalloutSubview />` with `onPress`.
See `Callouts.js` example.

![](http://i.giphy.com/xT77XNePGnMIIDpbnq.gif) ![](http://i.giphy.com/xT77YdU0HXryvoRqaQ.gif)

### Image-based Markers

Markers can be customized by just using images, and specified using the `image` prop.

![](http://i.imgur.com/mzrOjTR.png)

### Draggable Markers

Markers are draggable, and emit continuous drag events to update other UI during drags.

![](http://i.giphy.com/l2JImnZxdv1WbpQfC.gif) ![](http://i.giphy.com/l2JIhv4Jx6Ugx1EGI.gif)

### Lite Mode ( Android )

Enable lite mode on Android with `liteMode` prop. Ideal when having multiple maps in a View or ScrollView.

![](http://i.giphy.com/qZ2lAf18s89na.gif)

### On Poi Click (Google Maps Only)

Poi are clickable, you can catch the event to get its information (usually to get the full detail from Google Place using the placeId).

![](https://media.giphy.com/media/3480VsCKnHr31uCLU3/giphy.gif)

### Animated Region

The MapView can accept an `AnimatedRegion` value as its `region` prop. This allows you to utilize the Animated API to control the map's center and zoom.

```jsx
import MapView, { AnimatedRegion, Animated } from 'react-native-maps';

getInitialState() {
  return {
    region: new AnimatedRegion({
      latitude: LATITUDE,
      longitude: LONGITUDE,
      latitudeDelta: LATITUDE_DELTA,
      longitudeDelta: LONGITUDE_DELTA,
    }),
  };
}

onRegionChange(region) {
  this.state.region.setValue(region);
}

render() {
  return (
    <Animated
      region={this.state.region}
      onRegionChange={this.onRegionChange}
    />
  );
}
```

### Animated Marker Position

Markers can also accept an `AnimatedRegion` value as a coordinate.

```jsx
import MapView, { AnimatedRegion, MarkerAnimated } from 'react-native-maps';

getInitialState() {
  return {
    coordinate: new AnimatedRegion({
      latitude: LATITUDE,
      longitude: LONGITUDE,
    }),
  };
}

componentWillReceiveProps(nextProps) {
  const duration = 500

  if (this.props.coordinate !== nextProps.coordinate) {
    if (Platform.OS === 'android') {
      if (this.marker) {
        this.marker.animateMarkerToCoordinate(
          nextProps.coordinate,
          duration
        );
      }
    } else {
      this.state.coordinate.timing({
        ...nextProps.coordinate,
        useNativeDriver: true, // defaults to false if not passed explicitly
        duration
      }).start();
    }
  }
}

render() {
  return (
    <MapView initialRegion={...}>
      <MarkerAnimated
        ref={marker => { this.marker = marker }}
        coordinate={this.state.coordinate}
      />
    </MapView>
  );
}
```

### Take Snapshot of map

```jsx
import MapView, { Marker } from 'react-native-maps';

getInitialState() {
  return {
    coordinate: {
      latitude: LATITUDE,
      longitude: LONGITUDE,
    },
  };
}

takeSnapshot () {
  // 'takeSnapshot' takes a config object with the
  // following options
  const snapshot = this.map.takeSnapshot({
    width: 300,      // optional, when omitted the view-width is used
    height: 300,     // optional, when omitted the view-height is used
    region: {..},    // iOS only, optional region to render
    format: 'png',   // image formats: 'png', 'jpg' (default: 'png')
    quality: 0.8,    // image quality: 0..1 (only relevant for jpg, default: 1)
    result: 'file'   // result types: 'file', 'base64' (default: 'file')
  });
  snapshot.then((uri) => {
    this.setState({ mapSnapshot: uri });
  });
}

render() {
  return (
    <View>
      <MapView initialRegion={...} ref={map => { this.map = map }}>
        <Marker coordinate={this.state.coordinate} />
      </MapView>
      <Image source={{ uri: this.state.mapSnapshot.uri }} />
      <TouchableOpacity onPress={this.takeSnapshot}>
        Take Snapshot
      </TouchableOpacity>
    </View>
  );
}
```

### Zoom to Specified Markers

Pass an array of marker identifiers to have the map re-focus.

![](http://i.giphy.com/3o7qEbOQnO0yoXqKJ2.gif) ![](http://i.giphy.com/l41YdrQZ7m6Dz4h0c.gif)

### Zoom to Specified Coordinates

Pass an array of coordinates to focus a map region on said coordinates.

![](https://cloud.githubusercontent.com/assets/1627824/18609960/da5d9e06-7cdc-11e6-811e-34e255093df9.gif)

### Troubleshooting

#### My map is blank

- Make sure that you have [properly installed](docs/installation.md) react-native-maps.
- Check in the logs if there is more informations about the issue.
- Try setting the style of the MapView to an absolute position with top, left, right and bottom values set.
- Make sure you have enabled Google Maps API in [Google developer console](https://console.developers.google.com/apis/library)

```javascript
const styles = StyleSheet.create({
  map: {
    ...StyleSheet.absoluteFillObject,
  },
});
```

```jsx
<MapView
  style={styles.map}
  // other props
/>
```

#### Inputs don't focus

- When inputs don't focus or elements don't respond to tap, look at the order of the view hierarchy, sometimes the issue could be due to ordering of rendered components, prefer putting MapView as the first component.

Bad:

```jsx
<View>
  <TextInput />
  <MapView />
</View>
```

Good:

```jsx
<View>
  <MapView />
  <TextInput />
</View>
```

#### Children Components Not Re-Rendering

Components that aren't declared by this library (Ex: Markers, Polyline) must not be children of the MapView component due to MapView's unique rendering methodology. Have your custom components / views outside the MapView component and position absolute to ensure they only re-render as needed.
Example:
Bad:

```jsx
<View style={StyleSheet.absoluteFillObject}>
  <MapView style={StyleSheet.absoluteFillObject}>
    <View style={{ position: "absolute", top: 100, left: 50 }} />
  </MapView>
</View>
```

Good:

```jsx
<View style={StyleSheet.absoluteFillObject}>
  <MapView style={StyleSheet.absoluteFillObject} />
  <View style={{ position: "absolute", top: 100, left: 50 }} />
</View>
```

Source: https://github.com/react-native-maps/react-native-maps/issues/1901

#### Crashing with EXC_BAD_ACCESS on iOS when switching apps

`<MapView>` using Apple Maps in `mapType: "standard"` will sometimes crash when you background the app or switch into another app. This is only an issue in XCode using Metal API Validation, and won't happen in production. To eliminate this problem even while debugging in XCode, go to `Edit Scheme... -> Run (Debug) -> Diagnostics` and uncheck `Metal -> API Validation`. (h/t [@Simon-TechForm](https://github.com/Simon-TechForm)).

Source: https://github.com/react-native-maps/react-native-maps/issues/3957#issuecomment-924161121

#### onRegionChangeComplete() callback is called infinitely

If changing the state in `onRegionChangeComplete` is called infinitely, add a condition to limit these calls to occur only when the region change was done as a result of a user's action.

```javascript
onRegionChangeComplete={ (region, gesture) => {
	// This fix only works on Google Maps because isGesture is NOT available on Apple Maps
	if (!gesture.isGesture) {
    return;
  }

  // You can use
  dispatch({ type: "map_region", payload: { mapRegion: region }}); // if using useReducer
	// setMapRegionState(region); // if using useState
}}
```

Source: https://github.com/react-native-maps/react-native-maps/issues/846#issuecomment-1210079461

## License

     Copyright (c) 2017 Airbnb

     Licensed under the The MIT License (MIT) (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

        https://raw.githubusercontent.com/airbnb/react-native-maps/master/LICENSE

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.

</file>

<file path="SECURITY.md">
# Security Policy

## Reporting a Vulnerability

**Please do not report security vulnerabilities through any public method** Instead, please make use of private vulnerability reporting (you can learn how to do so [here](https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability#privately-reporting-a-security-vulnerability)).
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig",
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      "react-native-maps": ["./src/index"]
    },
    "allowJs": true,
    "allowSyntheticDefaultImports": true,
    "declaration": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "jsx": "react-native",
    "lib": ["es2017"],
    "module": "commonjs",
    "moduleResolution": "node",
    "outDir": "lib",
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "target": "esnext"
  }
}
</file>

</files>
